<MessageCollection>

  <!--
  **********************************************************************
  Detectors
  **********************************************************************
   -->


  <Detector class="edu.umd.cs.findbugs.detect.InheritanceUnsafeGetResource">
    <Details>
<![CDATA[
<p> Looks for uses of this.getClass().getResource(...), which can give
unexpected results if the class is extended by a class in
another package.</p>

]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.VolatileUsage">
    <Details>
<![CDATA[
<p> Looks for bug patterns in the usage of volatile fields.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.EmptyZipFileEntry">
    <Details>
<![CDATA[
<p> This looks for creation of empty zip file entries.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.TestingGround">
    <Details>
<![CDATA[
<p> This detector is just a hook for testing new detectors.
Normally, this detector does nothing.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.SwitchFallthrough">
    <Details>
<![CDATA[
<p> This detector looks for switch statements containing fall through.
It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindFieldSelfAssignment">
    <Details>
<![CDATA[
<p> This detector looks for places where a field is assigned
by reading the value of the same field.  It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindNonShortCircuit">
    <Details>
<![CDATA[
<p> This detector looks for suspicious uses of non-short-circuiting
boolean operators (<code>|</code> and <code>&amp;</code> instead of
<code>||</code> and <code>&amp;&amp;</code>).</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.DontCatchIllegalMonitorStateException">
    <Details>
<![CDATA[
<p> This detector looks for try-catch blocks that catch a IllegalMonitorStateException.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindFloatMath">
    <Details>
<![CDATA[
<p> This detector looks for uses of floating path math.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CloneIdiom">
    <Details>
<![CDATA[
<p> This detector looks for violations of the idioms for writing
cloneable classes.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DroppedException">
    <Details>
<![CDATA[
<p> This detector looks for code where an exception is caught,
but nothing is done to handle the exception.  It is a fast detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DumbMethods">
    <Details>
<![CDATA[
<p> This detector looks for calls to pointless methods,
such as the no-argument String constructor.
It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindDoubleCheck" >
    <Details>
<![CDATA[
<p> This detector looks for instances of double checked locking.
It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindFinalizeInvocations" >
    <Details>
<![CDATA[
<p> This detector looks for calls to finalize() and other finalizer-related
issues.  It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindHEmismatch" >
    <Details>
<![CDATA[
<p> This detector looks for problems in the definition of the hashCode() and equals()
methods.  It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindNakedNotify" >
    <Details>
<![CDATA[
<p> This detector looks for calls to notify() that don't seem
to modify mutable object state.  It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindReturnRef" >
    <Details>
<![CDATA[
<p> This detector looks for methods that return mutable static data.
It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindRunInvocations" >
    <Details>
<![CDATA[
<p> This detector looks for calls to Thread.run().  It is a fast
detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindSpinLoop" >
    <Details>
<![CDATA[
<p> This detector looks for loops that spin reading from a field.
It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindTwoLockWait" >
    <Details>
<![CDATA[
<p> This detector looks for calls to wait() with two (or more) locks held.
It is a slow detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUnconditionalWait" >
    <Details>
<![CDATA[
<p> This detector looks for calls to wait() not in a conditional or loop.
It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUninitializedGet" >
    <Details>
<![CDATA[
<p> This detector looks for reads of uninitialized fields in constructors.
It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUnsyncGet" >
    <Details>
<![CDATA[
<p> This detector looks for get and set methods where the get is unsynchronized
while the set is synchronized.  It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.InitializationChain" >
    <Details>
<![CDATA[
<p> This detector looks for potentially circular class initialization
dependencies.  It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.IteratorIdioms" >
    <Details>
<![CDATA[
<p> This iterator looks for problems in how Iterator classes are defined.
It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.LockedFields" disabled="true" >
    <Details>
<![CDATA[
<p> This detector looks for fields that are accessed in an inconsistent manner
with respect to locking.  It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.EqStringTest" >
    <Details>
<![CDATA[
<p> This detector looks for comparisons of String objects using the == or !=
operators.
 It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.MutableLock" >
    <Details>
<![CDATA[
<p> This detector looks for synchronization on objects read from
modified fields.  It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.MutableStaticFields" >
    <Details>
<![CDATA[
<p> This detector looks for static fields that may be modified by
malicious code.  It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.Naming" >
    <Details>
<![CDATA[
<p> This detector looks for suspiciously-named methods.  It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.ReadReturnShouldBeChecked" >
    <Details>
<![CDATA[
<p> This detector looks for calls to InputStream.read() or InputStream.skip() where the
return value is ignored.  It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.SerializableIdiom" >
    <Details>
<![CDATA[
<p> This detector looks for potential problems in the implementation
of Serializable classes.  It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.StartInConstructor" >
    <Details>
<![CDATA[
<p> This detector looks for constructors that start threads.  It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.UnreadFields" >
    <Details>
<![CDATA[
<p> This detector looks for fields whose value is never read.  It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.WaitInLoop" >
    <Details>
<![CDATA[
<p> This detector looks for calls to wait() that are not in a loop.
It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.BCPDoubleCheck" disabled="true" >
    <Details>
<![CDATA[
<p> This detector looks for instances of double checked locking.
It is implemented using the ByteCodePattern class.  You might want to
take a look at its source code as an example of an easy way to implement a bug
pattern detector.  It is a fairly fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.BCPMethodReturnCheck" >
    <Details>
<![CDATA[
<p> This detector looks for calls to methods where the return value
is suspiciously ignored.  It is a slow detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindNullDeref">
    <Details>
<![CDATA[
<p> This detector looks for places where a null pointer exception might
occur.  It also looks for redundant comparisons of reference values against
null.  It is a moderately fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindOpenStream">
    <Details>
<![CDATA[
<p> This detector looks for IO stream objects which do not escape the
method and do not appear to be closed on all paths out of the method.
It is a moderately fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.PreferZeroLengthArrays">
    <Details>
<![CDATA[
<p> This detector looks for methods that return either arrays or an explicit null reference.
Returning a zero length array is generally preferred in this context to returning a null reference.
It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUselessControlFlow">
    <Details>
<![CDATA[
<p> This detector looks for control flow statements which have no effect.
It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUnreleasedLock">
    <Details>
<![CDATA[
<p> This detector looks for JSR-166 (<code>java.util.concurrent</code>)
locks which are acquired, but not released on all paths out of the method.&nbsp;
It is a moderately fast detector.&nbsp; Note that in order to use this
detector, you need to have the <code>java.util.concurrent</code> package
in the auxiliary classpath (or be analyzing the package itself).</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindRefComparison">
    <Details>
<![CDATA[
<p> This detector looks for places where two reference values are compared
with the == or != operator, and the class is of a type (such as <code>java.lang.String</code>)
where comparing reference values is generally an error.  It is a moderately
fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindMismatchedWaitOrNotify">
    <Details>
<![CDATA[
<p> This detector looks for calls to wait(), notify(), or notifyAll()
which do not appear to be made on an object which is currently locked.&nbsp;
It is a moderately fast detector.&nbsp; <b>This detector is disabled because
it is still under development, and produces too many false positives.</b></p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindInconsistentSync2" >
    <Details>
<![CDATA[
<p> This detector looks for fields that are accessed in an inconsistent manner
with respect to locking.  It is a slow detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindLocalSelfAssignment">
    <Details>
<![CDATA[
<p> This detector looks for self assignments of local variables.
It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.IncompatMask">
    <Details>
<![CDATA[
<p> This detector looks for suspicious bitwise logical expressions.
It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.LazyInit">
    <Details>
<![CDATA[
<p> This detector looks for lazy field initialization where the
field is not volatile.  It is a moderately fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindJSR166LockMonitorenter">
    <Details>
<![CDATA[
<p> This detector looks for ordinary synchronization performed
on JSR166 locks.  It is a moderately fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUncalledPrivateMethods">
    <Details>
<![CDATA[
<p> This detector looks for private methods that are never called.
It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.StringConcatenation">
    <Details>
<![CDATA[
<p> This detector looks for String concatenation in loops using +.
It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.InefficientToArray">
    <Details>
<![CDATA[
<p> This detector looks for code that converts Collections to arrays
using the toArray() method that takes a prototype array, passing
an array argument which is zero-length.
It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindMaskedFields">
    <Details>
<![CDATA[
<p> This detector looks for class level fields that are masked by
local fields defined in methods.
It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.InvalidJUnitTest">
    <Details>
<![CDATA[
<p> This detector looks for JUnit tests that are malformed.
It is a fast detector.</p>
]]>
    </Details>
  </Detector>
  
  <Detector class="edu.umd.cs.findbugs.detect.BadlyOverriddenAdapter">
    <Details>
<![CDATA[
<p> This detector looks for code that extends an Adapter class and overrides a Listener
method with the wrong signature. It is a fast detector.</p>
]]>
    </Details>
  </Detector>
  
  <Detector class="edu.umd.cs.findbugs.detect.BadResultSetAccess">
    <Details>
<![CDATA[
<p> This detector looks for calls to getXXX or setXXX methods of a result set where the
field index is 0. As ResultSet fields start at index 1, this is always a mistake.
It is a fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.SuperfluousInstanceOf">
    <Details>
<![CDATA[
<p> This detector looks for type checks using the instanceof operator where the determination
can be done statically. It is a fast detector.</p>
]]>
    </Details>
  </Detector>
  
  <Detector class="edu.umd.cs.findbugs.detect.FindBugsSummaryStats">
    <Details>
<![CDATA[
<p> This detector just collects summary statistics information about the analysis process. </p>
]]>
    </Details>
  </Detector>

  <!--
  **********************************************************************
  BugPatterns
  **********************************************************************
   -->


  <BugPattern type="MF_METHOD_MASKS_FIELD">
    <ShortDescription>Method defines a variable that obscures a field</ShortDescription>
    <LongDescription>Method {1} defines a variable that obscures field {2}</LongDescription>
    <Details>
<![CDATA[
<p> This method defines a local variable with the same name as a field
in this class or a superclass.  This may cause the method to
read an uninitialized value from the field, leave the field uninitialized,
or both.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="MF_CLASS_MASKS_FIELD">
    <ShortDescription>Class defines field that obscures a superclass field</ShortDescription>
    <LongDescription>Class {0} defines field that obscures superclass field {1}</LongDescription>
    <Details>
<![CDATA[
<p> This class defines a field with the same name as a visible
instance field in a superclass.  This is confusing, and
may indicate an error if methods update or access one of
the fields when they wanted the other.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SW_SWING_METHODS_INVOKED_IN_SWING_THREAD">
    <ShortDescription>Certain swing methods should only be invoked from the Swing event thread</ShortDescription>
    <LongDescription>Call to swing method in {1} needs to be performed in Swing event thread</LongDescription>
    <Details>
<![CDATA[
<p>(<a href="http://java.sun.com/developer/JDCTechTips/2003/tt1208.html#1">From JDC Tech Tip</a>): The Swing methods
show(), setVisible(), and pack() will create the associated peer for the frame. 
With the creation of the peer, the system creates the event dispatch thread. 
This makes things problematic because the event dispatch thread could be notifying 
listeners while pack and validate are still processing. This situation could result in 
two threads going through the Swing component-based GUI -- it's a serious flaw that 
could result in deadlocks or other related threading issues. A pack call causes 
components to be realized. As they are being realized (that is, not necessarily 
visible), they could trigger listener notification on the event dispatch thread.</p>

]]>
    </Details>
  </BugPattern>


  <BugPattern type="VO_VOLATILE_REFERENCE_TO_ARRAY">
    <ShortDescription>A volatile reference to an array doesn't treat the array elements as volatile</ShortDescription>
    <LongDescription>{1} is a volatile reference to an array; the array elements
are non-volatile.</LongDescription>
    <Details>
<![CDATA[
<p>This declares a volatile reference to an array, which might not be what
you want. With a volatile reference to an array, reads and writes of
the reference to the array are treated as volatile, but the array elements
are non-volatile. To get volatile array elements, you will need to use
one of the atomic array classes in java.util.concurrent (provided
in Java 5.0).</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="UI_INHERITANCE_UNSAFE_GETRESOURCE">
    <ShortDescription>Usage of GetResource may be unsafe if class is extended</ShortDescription>
    <LongDescription>Usage of GetResource in {1} may be unsafe if class is extended</LongDescription>
    <Details>
<![CDATA[
<p>Calling <code>this.getClass().getResource(...)</code> could give
results other than expected if this class is extended by a class in 
another package.</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="TESTING">
    <ShortDescription>Testing</ShortDescription>
    <LongDescription>Test warning generated in {1}</LongDescription>
    <Details>
<![CDATA[
<p>This bug pattern is only generated by new, incompletely implemented
bug detectors.</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="AM_CREATES_EMPTY_ZIP_FILE_ENTRY">
    <ShortDescription>Creates an empty zip file entry</ShortDescription>
    <LongDescription>Empty zip file entry created in {1}</LongDescription>
    <Details>
<![CDATA[
<p>The code calls <code>putNextEntry()</code>, immediately
followed by a call to <code>closeEntry()</code>. This results
in an empty ZipFile entry. The contents of the entry
should be written to the ZipFile between the calls to 
<code>putNextEntry()</code> and
<code>closeEntry()</code>.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="AM_CREATES_EMPTY_JAR_FILE_ENTRY">
    <ShortDescription>Creates an empty jar file entry</ShortDescription>
    <LongDescription>Empty jar file entry created in {1}</LongDescription>
    <Details>
<![CDATA[
<p>The code calls <code>putNextEntry()</code>, immediately
followed by a call to <code>closeEntry()</code>. This results
in an empty JarFile entry. The contents of the entry
should be written to the JarFile between the calls to 
<code>putNextEntry()</code> and
<code>closeEntry()</code>.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="IMSE_DONT_CATCH_IMSE">
    <ShortDescription>Dubious catching of IllegalMonitorStateException</ShortDescription>
    <LongDescription>Dubious catching of IllegalMonitorStateException in {1}</LongDescription>
    <Details>
<![CDATA[
<p>IllegalMonitorStateException is generally only
	thrown in case of a design flaw in your code (calling wait or
	notify on an object you do not hold a lock on).</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="FL_MATH_USING_FLOAT_PRECISION">
    <ShortDescription>Method performs math using floating point precision</ShortDescription>
    <LongDescription>{1} performs math using floating point precision</LongDescription>
    <Details>
<![CDATA[
<p>
	The method performs math operations using floating point precision.
	Floating point precision is very imprecise. For example,
	16777216.0f + 1.0f = 16777216.0f. Consider using double math instead.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="CN_IDIOM">
    <ShortDescription>Class implements Cloneable but does not define or use clone method</ShortDescription>
    <LongDescription>Class {0} implements Cloneable but does not define or use clone method</LongDescription>
    <Details>
<![CDATA[
<p>
	Class implements Cloneable but does not define or
	use clone method.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="CN_IDIOM_NO_SUPER_CALL">
    <ShortDescription>clone method does not call super.clone()</ShortDescription>
    <LongDescription>clone method {1} does not call super.clone()</LongDescription>
    <Details>
<![CDATA[
<p> This class defines a clone() method that does not call super.clone(),
and is not final.
If this class ("<i>A</i>") is extended by a subclass ("<i>B</i>"),
and the subclass <i>B</i> calls super.clone(), then it is likely that
<i>B</i>'s clone() method will return an object of type <i>A</i>,
which violates the standard contract for clone().</p>

<p> If all clone() methods call super.clone(), then they are guaranteed
to use Object.clone(), which always returns an object of the correct type.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="DE_MIGHT_DROP">
    <ShortDescription>Method might drop exception</ShortDescription>
    <LongDescription>{1} might drop {3}</LongDescription>
    <Details>
<![CDATA[
  <p> This method might drop an exception.&nbsp; In general, exceptions
  should be handled or reported in some way, or they should be thrown
  out of the method.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DE_MIGHT_IGNORE">
    <ShortDescription>Method might ignore exception</ShortDescription>
    <LongDescription>{1} might ignore {3}</LongDescription>
    <Details>
<![CDATA[
  <p> This method might ignore an exception.&nbsp; In general, exceptions
  should be handled or reported in some way, or they should be thrown
  out of the method.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_EXIT">
    <ShortDescription>Method invokes System.exit(...)</ShortDescription>
    <LongDescription>{1} invokes System.exit(...), which shuts down the entire virtual machine</LongDescription>
    <Details>
<![CDATA[
  <p> Invoking System.exit shuts down the entire Java virtual machine. This
	should only been done when it is appropriate. Such calls make it 
	hard or impossible for your code to be invoked by other code.
	Consider throwing a RuntimeException instead.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_CTOR">
    <ShortDescription>Method invokes dubious new String(String) constructor; just use the argument</ShortDescription>
    <LongDescription>{1} invokes dubious new String(String) constructor; just use the argument</LongDescription>
    <Details>
<![CDATA[
  <p> Using the <code>java.lang.String(String)</code> constructor wastes memory
  because the object so constructed will be functionally indistinguishable
  from the <code>String</code> passed as a parameter.&nbsp; Just use the
  argument <code>String</code> directly.</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="DM_STRING_VOID_CTOR">
    <ShortDescription>Method invokes dubious new String() constructor; just use ""</ShortDescription>
    <LongDescription>{1} invokes dubious new String() constructor; just use ""</LongDescription>
    <Details>
<![CDATA[
  <p> Creating a new <code>java.lang.String</code> object using the
  no-argument constructor wastes memory because the object so created will
  be functionally indistinguishable from the empty string constant
  <code>""</code>.&nbsp; Java guarantees that identical string constants
  will be represented by the same <code>String</code> object.&nbsp; Therefore,
  you should just use the empty string constant directly.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_TOSTRING">
    <ShortDescription>Method invokes toString() method on a String; just use the String</ShortDescription>
    <LongDescription>Method {1} invokes toString() method on a String; just use the String</LongDescription>
    <Details>
<![CDATA[
  <p> Calling <code>String.toString()</code> is just a redundant operation.
  Just use the String.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_GC">
    <ShortDescription>Explicit garbage collection; extremely dubious except in benchmarking code</ShortDescription>
    <LongDescription>{1} forces garbage collection; extremely dubious except in benchmarking code</LongDescription>
    <Details>
<![CDATA[
  <p> Code explicitly invokes garbage collection.
  Except for specific use in benchmarking, this is very dubious.
  <p>In the past, situations where people have explicitly invoked 
  the garbage collector in routines such as close or finalize methods
  has led to huge performance black holes. Garbage collection 
	can be expensive. Any situation that forces hundreds or thousands
	of garbage collections will bring the machine to a crawl.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_BOOLEAN_CTOR">
    <ShortDescription>Method invokes dubious Boolean constructor; use Boolean.valueOf(...) instead</ShortDescription>
    <LongDescription>{1} invokes dubious Boolean constructor; use Boolean.valueOf(...) instead</LongDescription>
    <Details>
<![CDATA[
  <p> Creating new instances of <code>java.lang.Boolean</code> wastes
  memory, since <code>Boolean</code> objects are immutable and there are
  only two useful values of this type.&nbsp; Use the <code>Boolean.valueOf()</code>
  method to create <code>Boolean</code> objects instead.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_EMPTY_EQUALS">
    <ShortDescription>Method invokes dubious String.equals(""); use String.length() == 0 instead</ShortDescription>
    <LongDescription>Method invokes dubious String.equals(""); use String.length() == 0 instead</LongDescription>
    <Details>
<![CDATA[
  <p> An object is compared to the empty String object using the equals() method here.
      Checking that the String object's length is zero may be faster.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_ARRAY_COMPARE">
    <ShortDescription>Method invokes dubious equals method on an array. Use Arrays.equals instead</ShortDescription>
    <LongDescription>Method invokes dubious equals method on an array. Use Arrays.equals instead</LongDescription>
    <Details>
<![CDATA[
  <p> An array is being compared to another object using the equals method of the array. This is the same as 
      comparing the object using ==, meaning it compares whether the array is the same as the object passed as a parameter.
      To compare the contents of the array, use Arrays.equals( array1, array2 );</p>
]]>
    </Details>  
  </BugPattern>
  <BugPattern type="DC_DOUBLECHECK">
    <ShortDescription>Possible double check of field</ShortDescription>
    <LongDescription>Possible doublecheck on {2} in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This method may contain an instance of double-checked locking.&nbsp;
  This idiom is not correct according to the semantics of the Java memory
  model.&nbsp; For more information, see the web page
  <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html"
  >http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</a>.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="FI_PUBLIC_SHOULD_BE_PROTECTED">
    <ShortDescription>Finalizer should be protected, not public</ShortDescription>
    <LongDescription>{1} is public; should be protected</LongDescription>
    <Details>
<![CDATA[
  <p> A class's <code>finalize()</code> method should have protected access,
   not public.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_EMPTY">
    <ShortDescription>Empty finalizer should be deleted</ShortDescription>
    <LongDescription>{1} is empty and should be deleted</LongDescription>
    <Details>
<![CDATA[
  <p> Empty <code>finalize()</code> methods are useless, so they should
  be deleted.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_NULLIFY_SUPER">
    <ShortDescription>Finalizer nullifies superclass finalizer</ShortDescription>
    <LongDescription>{1} is nullifying {2}.finalize(); is this intended?</LongDescription>
    <Details>
<![CDATA[
  <p> This empty <code>finalize()</code> method explicitly negates the
  effect of any finalizer defined by its superclass.&nbsp; Any finalizer
  actions defined for the superclass will not be performed.&nbsp;
  Unless this is intended, delete this method.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_USELESS">
    <ShortDescription>Finalizer does nothing but call superclass finalizer</ShortDescription>
    <LongDescription>{1} does nothing except call super.finalize(); delete it</LongDescription>
    <Details>
<![CDATA[
  <p> The only thing this <code>finalize()</code> method does is call
  the superclass's <code>finalize()</code> method, making it
  redundant.&nbsp; Delete it.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_MISSING_SUPER_CALL">
    <ShortDescription>Finalizer does not call superclass finalizer</ShortDescription>
    <LongDescription>{1} missing call to super.finalize(), so {2}.finalize() doesn't get called</LongDescription>
    <Details>
<![CDATA[
  <p> This <code>finalize()</code> method does not make a call to its
  superclass's <code>finalize()</code> method.&nbsp; So, any finalizer
  actions defined for the superclass will not be performed.&nbsp;
  Add a call to <code>super.finalize()</code>.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_EXPLICIT_INVOCATION">
    <ShortDescription>Explicit invocation of finalizer</ShortDescription>
    <LongDescription>{1} explicitly invokes {2}</LongDescription>
    <Details>
<![CDATA[
  <p> This method contains an explicit invocation of the <code>finalize()</code>
  method on an object.&nbsp; Because finalizer methods are supposed to be
  executed once, and only by the VM, this is a bad idea.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_SELF_USE_OBJECT">
    <ShortDescription>Covariant equals() method defined, Object.equals(Object) inherited</ShortDescription>
    <LongDescription>{0} defines equals({0}) method and uses Object.equals(Object)</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a covariant version of the <code>equals()</code>
  method, but calls the normal <code>equals(Object)</code> method
  defined in the base <code>java.lang.Object</code> class.&nbsp;
  The class should probably define a non-covariant version of <code>equals()</code>.&nbsp;
  (I.e., a method with the signature <code>boolean equals(java.lang.Object)</code>.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_SELF_NO_OBJECT">
    <ShortDescription>Covariant equals() method defined</ShortDescription>
    <LongDescription>{0} defines equals({0}) method but not equals(Object)</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a covariant version of <code>equals()</code>.&nbsp;
  To correctly override the <code>equals()</code> method in
  <code>java.lang.Object</code>, the parameter of <code>equals()</code>
  must have type <code>java.lang.Object</code>.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_SELF_NO_OBJECT">
    <ShortDescription>Covariant compareTo() method defined</ShortDescription>
    <LongDescription>{0} defines compareTo({0}) method but not compareTo(Object)</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a covariant version of <code>compareTo()</code>.&nbsp;
  To correctly override the <code>compareTo()</code> method in the
  <code>Comparable</code> interface, the parameter of <code>compareTo()</code>
  must have type <code>java.lang.Object</code>.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_HASHCODE_USE_OBJECT_EQUALS">
    <ShortDescription>Class defines hashCode() and uses Object.equals()</ShortDescription>
    <LongDescription>{0} defines hashCode and uses Object.equals()</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>hashCode()</code> method but inherits its
  <code>equals()</code> method from <code>java.lang.Object</code>
  (which defines equality by comparing object references).&nbsp; Although
  this will probably satisfy the contract that equal objects must have
  equal hashcodes, it is probably not what was intended by overriding
  the <code>hashCode()</code> method.&nbsp; (Overriding <code>hashCode()</code>
  implies that the object's identity is based on criteria more complicated
  than simple reference equality.)</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_HASHCODE_NO_EQUALS">
    <ShortDescription>Class defines hashCode() but not equals()</ShortDescription>
    <LongDescription>{0} defines hashCode but not equals</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>hashCode()</code> method but not an
  <code>equals()</code> method.&nbsp; Therefore, the class may
  violate the invariant that equal objects must have equal hashcodes.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="HE_EQUALS_USE_HASHCODE">
    <ShortDescription>Class defines equals() and uses Object.hashCode()</ShortDescription>
    <LongDescription>{0} defines equals and uses Object.hashCode()</LongDescription>
    <Details>
<![CDATA[
  <p> This class overrides <code>equals(Object)</code>, but does not
  override <code>hashCode()</code>, and inherits the implementation of
  <code>hashCode()</code> from <code>java.lang.Object</code> (which returns
  the identity hash code, an arbitrary value assigned to the object
  by the VM).&nbsp; Therefore, the class is very likely to violate the
  invariant that equal objects must have equal hashcodes.</p>

  <p>If you don't want to define a hashCode method, and/or don't
	believe the object will ever be put into a HashMap/Hashtable,
	define the <code>hashCode()</code> method
	to throw <code>UnsupportedOperationException</code>.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_INHERITS_EQUALS_USE_HASHCODE">
    <ShortDescription>Class inherits equals() and uses Object.hashCode()</ShortDescription>
    <LongDescription>{0} inherits equals and uses Object.hashCode()</LongDescription>
    <Details>
<![CDATA[
  <p> This class inherits <code>equals(Object)</code> from an abstract
  superclass, and <code>hashCode()</code> from 
from <code>java.lang.Object</code> (which returns
  the identity hash code, an arbitrary value assigned to the object
  by the VM).&nbsp; Therefore, the class is very likely to violate the
  invariant that equal objects must have equal hashcodes.</p>

  <p>If you don't want to define a hashCode method, and/or don't
	believe the object will ever be put into a HashMap/Hashtable,
	define the <code>hashCode()</code> method
	to throw <code>UnsupportedOperationException</code>.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_EQUALS_NO_HASHCODE">
    <ShortDescription>Class defines equals() but not hashCode()</ShortDescription>
    <LongDescription>{0} defines equals but not hashCode</LongDescription>
    <Details>
<![CDATA[
  <p> This class overrides <code>equals(Object)</code>, but does not
  override <code>hashCode()</code>.&nbsp; Therefore, the class may violate the
  invariant that equal objects must have equal hashcodes.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ABSTRACT_SELF">
    <ShortDescription>Abstract class defines covariant equals() method</ShortDescription>
    <LongDescription>Abstract {0} defines equals({0}) method</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a covariant version of <code>equals()</code>.&nbsp;
  To correctly override the <code>equals()</code> method in
  <code>java.lang.Object</code>, the parameter of <code>equals()</code>
  must have type <code>java.lang.Object</code>.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="ES_COMPARING_STRINGS_WITH_EQ">
    <ShortDescription>Comparison of String objects using == or !=</ShortDescription>
    <LongDescription>Comparison of String objects using == or != in {1} </LongDescription>
    <Details>
<![CDATA[
  <p>This code compares <code>java.lang.String</code> objects for reference
equality using the == or != operators.
Unless both strings are either constants in a source file, or have been
interned using the <code>String.intern()</code> method, the same string
value may be represented by two different String objects. Consider
using the <code>equals(Object)</code> method instead.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="CO_ABSTRACT_SELF">
    <ShortDescription>Abstract class defines covariant compareTo() method</ShortDescription>
    <LongDescription>Abstract {0} defines compareTo({0}) method</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a covariant version of <code>compareTo()</code>.&nbsp;
  To correctly override the <code>compareTo()</code> method in the
  <code>Comparable</code> interface, the parameter of <code>compareTo()</code>
  must have type <code>java.lang.Object</code>.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS2_INCONSISTENT_SYNC">
    <ShortDescription>Inconsistent synchronization</ShortDescription>
    <LongDescription>Inconsistent synchronization of {1}; locked {2}% of time</LongDescription>
    <Details>
<![CDATA[
  <p> The fields of this class appear to be accessed inconsistently with respect
  to synchronization.&nbsp; This bug report indicates that the bug pattern detector
  judged that
  <ol>
  <li> The class contains a mix of locked and unlocked accesses,<li>
  <li> At least one locked access was performed by one of the class's own methods, and</li>
  <li> The number of unsynchronized field accesses (reads and writes) was no more than
       one third of all accesses, with writes being weighed twice as high as reads</li>
  </ol>
  </p>

  <p> A typical bug matching this bug pattern is forgetting to synchronize
  one of the methods in a class that is intended to be thread-safe.</p>

  <p> You can select the nodes labeled "Unsynchronized access" to show the
  code locations where the detector believed that a field was accessed
  without synchronization.</p>

  <p> Note that there are various sources of inaccuracy in this detector;
  for example, the detector cannot statically detect all situations in which
  a lock is held.&nbsp; Also, even when the detector is accurate in
  distinguishing locked vs. unlocked accesses, the code in question may still
  be correct.</p>

  <p> This description refers to the "IS2" version of the pattern detector,
  which has more accurate ways of detecting locked vs. unlocked accesses
  than the older "IS" detector.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NN_NAKED_NOTIFY">
    <ShortDescription>Naked notify in method</ShortDescription>
    <LongDescription>Naked notify in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> A call to <code>notify()</code> or <code>notifyAll()</code>
  was made without any (apparent) accompanying
  modification to mutable object state.&nbsp; In general, calling a notify
  method on a monitor is done because some condition another thread is
  waiting for has become true.&nbsp; However, for the condition to be meaningful,
  it must involve a heap object that is visible to both threads.</p>

  <p> This bug does not necessarily indicate an error, since the change to
  mutable object state may have taken place in a method which then called
  the method containing the notification.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_EXPOSE_REP">
    <ShortDescription>Public static method may expose internal representation by returning array</ShortDescription>
    <LongDescription>public static {1} may expose internal representation by returning {2}</LongDescription>
    <Details>
<![CDATA[
  <p> A public static method returns a reference to
	an array that is part of the static state of the class. 
	Any code that calls this method can freely modify
	the underlying array.
	One fix is to return a copy of the array.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_REP">
    <ShortDescription>Method may expose internal representation by returning reference to mutable object</ShortDescription>
    <LongDescription>{1} may expose internal representation by returning {2}</LongDescription>
    <Details>
<![CDATA[
  <p> Returning a reference to a mutable object value stored in one of the object's fields
  exposes the internal representation of the object.&nbsp; 
	If instances
	are accessed by untrusted code, and unchecked changes to
	the mutable object would compromise security or other
	important properties, you will need to do something different.
  Returning a new copy of the object is better approach in many situations.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_REP2">
    <ShortDescription>Method may expose internal representation by incorporating reference to mutable object</ShortDescription>
    <LongDescription>{1} may expose internal representation by storing an externally mutable object into {2}</LongDescription>
    <Details>
<![CDATA[
  <p> This code stores a reference to an externally mutable object into the
  internal representation of the object.&nbsp; 
	If instances
	are accessed by untrusted code, and unchecked changes to
	the mutable object would compromise security or other
	important properties, you will need to do something different.
  Storing a copy of the object is better approach in many situations.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_STATIC_REP2">
    <ShortDescription>Method may expose internal static state by storing a mutable object into a static field</ShortDescription>
    <LongDescription>{1} may expose internal static state by storing a mutable object into a static field {2}</LongDescription>
    <Details>
<![CDATA[
  <p> This code stores a reference to an externally mutable object into a static
	field. 
	If unchecked changes to
	the mutable object would compromise security or other
	important properties, you will need to do something different.
  Storing a copy of the object is better approach in many situations.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RU_INVOKE_RUN">
    <ShortDescription>Invokes run on a thread (did you mean to start it instead?)</ShortDescription>
    <LongDescription>{1} explicitly invokes run on a thread (did you mean to start it instead?)</LongDescription>
    <Details>
<![CDATA[
  <p> This method explicitly invokes <code>run()</code> on an object.&nbsp;
  In general, classes implement the <code>Runnable</code> interface because
  they are going to have their <code>run()</code> method invoked in a new thread,
  in which case <code>Thread.start()</code> is the right method to call.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SP_SPIN_ON_FIELD">
    <ShortDescription>Method spins on field</ShortDescription>
    <LongDescription>Spinning on {2} in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This method spins in a loop which reads a field.&nbsp; The compiler
  may legally hoist the read out of the loop, turning the code into an
  infinite loop.&nbsp; The class should be changed so it uses proper
  synchronization (including wait and notify calls).</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NS_NON_SHORT_CIRCUIT">
    <ShortDescription>Questionable use of non-short-circuit logic</ShortDescription>
    <LongDescription>Questionable use of non-short-circuit logic in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This code seems to be using non-short-circuit logic (e.g., &amp;
or |) 
rather than short-circuit logic (&amp;&amp; or ||).
Non-short-circuit logic causes both sides of the expression
to be evaluated even when the result can be inferred from
knowing the left-hand side. This can be less efficient and
can result in errors if the left-hand side guards cases
when evaluating the right-hand side can generate an error.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="2LW_TWO_LOCK_WAIT">
    <ShortDescription>Wait with two locks held</ShortDescription>
    <LongDescription>wait() with two locks held in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> Waiting on a monitor while two locks are held may cause
  deadlock.
	&nbsp; 
	Performing a wait only releases the lock on the object
	being waited on, not any other locks.
	&nbsp; 
This not necessarily a bug, but is worth examining
  closely.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UW_UNCOND_WAIT">
    <ShortDescription>Unconditional wait in method</ShortDescription>
    <LongDescription>Unconditional wait in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This method contains a call to <code>java.lang.Object.wait()</code> which
  is not guarded by conditional control flow.&nbsp; If the condition that
  the method intends to wait for has already happened, the thread could
  wait indefinitely.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UR_UNINIT_READ">
    <ShortDescription>Uninitialized read of field in constructor</ShortDescription>
    <LongDescription>Uninitialized read of {2} in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This constructor reads a field which has not yet been assigned a value.&nbsp;
  This is often caused when the programmer mistakenly uses the field instead
  of one of the constructor's parameters.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UG_SYNC_SET_UNSYNC_GET">
    <ShortDescription>Unsynchronized get method, synchronized set method</ShortDescription>
    <LongDescription>{1} is unsynchronized, {2} is synchronized</LongDescription>
    <Details>
<![CDATA[
  <p> This class contains similarly-named get and set
  methods where the set method is synchronized and the get method is not.&nbsp;
  This may result in incorrect behavior at runtime, as callers of the get
  method will not necessarily see a consistent state for the object.&nbsp;
  The get method should be made synchronized.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IC_INIT_CIRCULARITY">
    <ShortDescription>Initialization circularity</ShortDescription>
    <LongDescription>Initialization circularity between {0} and {1}</LongDescription>
    <Details>
<![CDATA[
  <p> A circularity was detected in the static initializers of the two
  classes referenced by the bug instance.&nbsp; Many kinds of unexpected
  behavior may arise from such circularity.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IT_NO_SUCH_ELEMENT">
    <ShortDescription>Iterator next() method can't throw NoSuchElement exception</ShortDescription>
    <LongDescription>{1} can't throw NoSuchElement exception</LongDescription>
    <Details>
<![CDATA[
  <p> This class implements the <code>java.util.Iterator</code> interface.&nbsp;
  However, its <code>next()</code> method is not capable of throwing
  <code>java.util.NoSuchElementException</code>.&nbsp; The <code>next()</code>
  method should be changed so it throws <code>NoSuchElementException</code>
  if is called when there are no more elements to return.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS_INCONSISTENT_SYNC">
    <ShortDescription>Inconsistent synchronization</ShortDescription>
    <LongDescription>Inconsistent synchronization of {1}; locked {2}% of the time</LongDescription>
    <Details>
<![CDATA[
  <p> The fields of this class appear to be accessed inconsistently with respect
  to synchronization.&nbsp; This bug report indicates that the bug pattern detector
  judged that
  <ol>
  <li> The class contains a mix of locked and unlocked accesses,</li>
  <li> At least one locked access was performed by one of the class's own methods, and</li>
  <li> The number of unsynchronized field accesses (reads and writes) was no more than
       one third of all accesses, with writes being weighed twice as high as reads</li>
  </ol>
  </p>

  <p> A typical bug matching this bug pattern is forgetting to synchronize
  one of the methods in a class that is intended to be thread-safe.</p>

  <p> Note that there are various sources of inaccuracy in this detector;
  for example, the detector cannot statically detect all situations in which
  a lock is held.&nbsp; Also, even when the detector is accurate in
  distinguishing locked vs. unlocked accesses, the code in question may still
  be correct.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ML_SYNC_ON_UPDATED_FIELD">
    <ShortDescription>Method synchronizes on an updated field</ShortDescription>
    <LongDescription>{1} synchronizes on updated field {2}</LongDescription>
    <Details>
<![CDATA[
  <p> This method synchronizes on an object 
	references from a mutable field.
	This is unlikely to have useful semantics, since different
threads may be synchronizing on different objects.</p>
]]>  
    </Details>
  </BugPattern>
  <BugPattern type="MS_OOI_PKGPROTECT">
    <ShortDescription>Field should be moved out of an interface and made package protected</ShortDescription>
    <LongDescription>{1} should be moved out of an interface and made package protected</LongDescription>
    <Details>
<![CDATA[
<p>
 A final static field that is 
defined in an interface references a mutable
	object such as an array or hashtable.
	This mutable object could 
	be changed by malicious code or
        by accident from another package.
	So solve this, the field needs to be moved to a class
	and made package protected 
	to avoid
        this vulnerability.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_FINAL_PKGPROTECT">
    <ShortDescription>Field should be both final and package protected</ShortDescription>
    <LongDescription>{1} should be both final and package protected</LongDescription>
    <Details>
<![CDATA[
 <p>
	A mutable static field could be changed by malicious code or
        by accident from another package.
        The field could be made package protected and/or made final 
	to avoid
        this vulnerability.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_SHOULD_BE_FINAL">
    <ShortDescription>Field isn't final but should be</ShortDescription>
    <LongDescription>{1} isn't final but should be</LongDescription>
    <Details>
<![CDATA[
	<p>
 A mutable static field could be changed by malicious code or
        by accident from another package.
        The field could be made final to avoid
        this vulnerability.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_PKGPROTECT">
    <ShortDescription>Field should be package protected</ShortDescription>
    <LongDescription>{1} should be package protected</LongDescription>
    <Details>
<![CDATA[
  <p> A mutable static field could be changed by malicious code or
	by accident.
	The field could be made package protected to avoid
	this vulnerability.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_HASHTABLE">
    <ShortDescription>Field is a mutable Hashtable</ShortDescription>
    <LongDescription>{1} is a mutable Hashtable</LongDescription>
    <Details>
<![CDATA[
 <p>A final static field references a Hashtable
	and can be accessed by malicious code or
        by accident from another package.
	This code can freely modify the contents of the Hashtable.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_ARRAY">
    <ShortDescription>Field is a mutable array</ShortDescription>
    <LongDescription>{1} is a mutable array</LongDescription>
    <Details>
<![CDATA[
 A final static field references an array
	and can be accessed by malicious code or
        by accident from another package.
	This code can freely modify the contents of the array.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_CANNOT_BE_FINAL">
    <ShortDescription>Field isn't final and can't be protected from malicious code</ShortDescription>
    <LongDescription>{1} isn't final and can't be protected malicious code </LongDescription>
    <Details>
<![CDATA[
  <p> 
 A mutable static field could be changed by malicious code or
        by accident from another package.
	Unfortunately, the way the field is used doesn't allow
	any easy fix to this problem.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_VERY_CONFUSING">
    <ShortDescription>Very confusing method names</ShortDescription>
    <LongDescription>VERY confusing to have methods {1} and {3}</LongDescription>
    <Details>
<![CDATA[
  <p> The referenced methods have names that differ only by capitalization.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CONFUSING">
    <ShortDescription>Confusing method names</ShortDescription>
    <LongDescription>Confusing to have methods {1} and {3}</LongDescription>
    <Details>
<![CDATA[
  <p> The referenced methods have names that differ only by capitalization.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CONFUSING_METHOD_NAME">
    <ShortDescription>Confusing method name</ShortDescription>
    <LongDescription>Confusing method name: {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This method has the same name as the superclass of the class it
  is defined in.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_LCASE_HASHCODE">
    <ShortDescription>Class defines hashcode(); should it be hashCode()?</ShortDescription>
    <LongDescription>Class {0} defines hashcode(); should it be hashCode()?</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a method called <code>hashcode()</code>.&nbsp; This method
  does not override the <code>hashCode()</code> method in <code>java.lang.Object</code>,
  which is probably what was intended.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_LCASE_TOSTRING">
    <ShortDescription>Class defines tostring(); should it be toString()?</ShortDescription>
    <LongDescription>Class {0} defines tostring(); should it be toString()?</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a method called <code>tostring()</code>.&nbsp; This method
  does not override the <code>toString()</code> method in <code>java.lang.Object</code>,
  which is probably what was intended.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NM_BAD_EQUAL">
    <ShortDescription>Class defines equal(); should it be equals()?</ShortDescription>
    <LongDescription>Class {0} defines equal(); should it be equals()?</LongDescription>
    <Details>
<![CDATA[
<p> This class defines a method <code>equal(Object)</code>.&nbsp; This method does
not override the <code>equals(Object)</code> method in <code>java.lang.Object</code>,
which is probably what was intended.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RR_NOT_CHECKED">
    <ShortDescription>Method ignores results of InputStream.read()</ShortDescription>
    <LongDescription>{1} ignores result of {2}</LongDescription>
    <Details>
<![CDATA[
  <p> This method ignores the return value of one of the variants of
  <code>java.io.InputStream.read()</code> which can return multiple bytes.&nbsp;
  If the return value is not checked, the caller will not be able to correctly
  handle the case where fewer bytes were read than the caller requested.&nbsp;
  This is a particularly insidious kind of bug, because in many programs,
  reads from input streams usually do read the full amount of data requested,
  causing the program to fail only sporadically.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SR_NOT_CHECKED">
    <ShortDescription>Method ignores results of InputStream.skip()</ShortDescription>
    <LongDescription>{1} ignores result of {2}</LongDescription>
    <Details>
<![CDATA[
  <p> This method ignores the return value of
  <code>java.io.InputStream.skip()</code> which can skip multiple bytes.&nbsp;
  If the return value is not checked, the caller will not be able to correctly
  handle the case where fewer bytes were skipped than the caller requested.&nbsp;
  This is a particularly insidious kind of bug, because in many programs,
  skips from input streams usually do skip the full amount of data requested,
  causing the program to fail only sporadically. With Buffered streams, however,
  skip() will only skip data in the buffer, and will routinely fail to skip the
  requested number of bytes.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION">
    <ShortDescription>Class is Externalizable but doesn't define a void constructor</ShortDescription>
    <LongDescription>{0} is Externalizable but doesn't define a void constructor</LongDescription>
    <Details>
<![CDATA[
  <p> This class implements the <code>Externalizable</code> interface, but does
  not define a void constructor. When Externalizable objects are deserialized,
	they first need to be constructed by invoking the void
	constructor. Since this class does not have one,
	serialization and deserialization will fail at runtime.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SUITABLE_CONSTRUCTOR">
    <ShortDescription>Class is Serializable but its superclass doesn't define a void constructor</ShortDescription>
    <LongDescription>{0} is Serializable  but its superclass doesn't define an accessible void constructor</LongDescription>
    <Details>
<![CDATA[
  <p> This class implements the <code>Serializable</code> interface
	and its superclass does not. When such an object is deserialized,
	the fields of the superclass need to be initialized by
	invoking the void constructor of the superclass.
	Since the superclass does not have one,
	serialization and deserialization will fail at runtime.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SE_NO_SERIALVERSIONID">
    <ShortDescription>Class is Serializable, but doesn't define serialVersionUID</ShortDescription>
    <LongDescription>{0} is Serializable; consider declaring a serialVersionUID</LongDescription>
    <Details>
<![CDATA[
  <p> This class implements the <code>Serializable</code> interface, but does
  not define a <code>serialVersionUID</code> field.&nbsp; 
  A change as simple as adding a reference to a .class object 
	 will add synthetic fields to the class,
	which will unfortunately change the implicit
	serialVersionUID (e.g., adding a reference to <code>String.class</code>
	will generate a static field <code>class$java$lang$String</code>).
   Also, different source code to bytecode compilers may use different 
   naming conventions for synthetic variables generated for 
   references to class objects or inner classes.
   To ensure interoperability of Serializable across versions,
	consider adding an explicit serialVersionUID.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SF_SWITCH_FALLTHROUGH">
  	<ShortDescription>A switch statement found where one case falls thru to the next case</ShortDescription>
  	<LongDescription>A switch statement found where one case falls thru to the next case</LongDescription>
    <Details>
<![CDATA[
  <p> This method contains a switch statement where one case branch will fall thru to the next case.
  Usually you need to end this case with a break or return.</p>
]]>
    </Details>  
  </BugPattern>

  <BugPattern type="WS_WRITEOBJECT_SYNC">
    <ShortDescription>Class's writeObject() method is synchronized but nothing else is</ShortDescription>
    <LongDescription>{0}'s writeObject method is synchronized but nothing else is</LongDescription>
    <Details>
<![CDATA[
  <p> This class has a <code>writeObject()</code> method which is synchronized;
  however, no other method of the class is synchronized.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RS_READOBJECT_SYNC">
    <ShortDescription>Class's readObject() method is synchronized</ShortDescription>
    <LongDescription>{0}'s readObject method is synchronized</LongDescription>
    <Details>
<![CDATA[
  <p> This serializable class defines a <code>readObject()</code> which is
  synchronized.&nbsp; By definition, an object created by deserialization
  is only reachable by one thread, and thus there is no need for
  <code>readObject()</code> to be synchronized.&nbsp; If the <code>readObject()</code>
  method itself is causing the object to become visible to another thread,
  that is an example of very dubious coding style.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SE_NONSTATIC_SERIALVERSIONID">
    <ShortDescription>serialVersionUID isn't static</ShortDescription>
    <LongDescription>{1} isn't static</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>serialVersionUID</code> field that is not static.&nbsp;
  The field should be made static
	if it is intended to specify
	the version UID for purposes of serialization.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SE_NONFINAL_SERIALVERSIONID">
    <ShortDescription>serialVersionUID isn't final</ShortDescription>
    <LongDescription>{1} isn't final</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>serialVersionUID</code> field that is not final.&nbsp;
  The field should be made final 
	if it is intended to specify
	the version UID for purposes of serialization.</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="SE_NONLONG_SERIALVERSIONID">
    <ShortDescription>serialVersionUID isn't long</ShortDescription>
    <LongDescription>{1} isn't long</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>serialVersionUID</code> field that is not long.&nbsp;
  The field should be made long
	if it is intended to specify
	the version UID for purposes of serialization.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SE_BAD_FIELD">
    <ShortDescription>Non-transient non-serializable instance field in serializable class</ShortDescription>
    <LongDescription>Class {0} defines non-transient non-serializable instance field {1}</LongDescription>
    <Details>
<![CDATA[
<p> This Serializable class defines a non-primitive instance field which is neither transient,
Serializable, or <code>java.lang.Object</code>, and does not appear to implement
the <code>Externalizable</code> interface or the
<code>readObject()</code> and <code>writeObject()</code> methods.&nbsp;
Objects of this class will not be deserialized correctly if a non-Serializable
object is stored in this field.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SC_START_IN_CTOR">
    <ShortDescription>Constructor invokes Thread.start()</ShortDescription>
    <LongDescription>{1} invokes {2}</LongDescription>
    <Details>
<![CDATA[
  <p> The constructor starts a thread. This is likely to be wrong if
	the class is ever extended/subclassed, since the thread will be started
	before the subclass constructor is started.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SS_SHOULD_BE_STATIC">
    <ShortDescription>Unread field: should this field be static?</ShortDescription>
    <LongDescription>Unread field: {1}; should this field be static?</LongDescription>
    <Details>
<![CDATA[
  <p> This class contains an instance final field that
	is initialized to a compile-time static value.
	Consider making the field static.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UUF_UNUSED_FIELD">
    <ShortDescription>Unused field</ShortDescription>
    <LongDescription>Unused field: {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This field is never used.&nbsp; Consider removing it from the class.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="URF_UNREAD_FIELD">
    <ShortDescription>Unread field</ShortDescription>
    <LongDescription>Unread field: {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This field is never read.&nbsp; Consider removing it from the class.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_UNWRITTEN_FIELD">
    <ShortDescription>Unwritten field</ShortDescription>
    <LongDescription>Unwritten field: {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This field is never written.&nbsp; All reads of it will return the default
value. Check for errors (should it have been initialized?), or remove it if it is useless.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC">
    <ShortDescription>Should be a static inner class</ShortDescription>
    <LongDescription>Should {0} be a _static_ inner class?</LongDescription>
    <Details>
<![CDATA[
  <p> This class is an inner class, but does not use its embedded reference
  to the object which created it.&nbsp; This reference makes the instances
  of the class larger, and may keep the reference to the creator object
  alive longer than necessary.&nbsp; If possible, the class should be
  made into a <em>static</em> inner class.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC_ANON">
    <ShortDescription>Could be refactored into a named static inner class</ShortDescription>
    <LongDescription>The class {0} could be refactored into a named _static_ inner class</LongDescription>
    <Details>
<![CDATA[
  <p> This class is an inner class, but does not use its embedded reference
  to the object which created it.&nbsp; This reference makes the instances
  of the class larger, and may keep the reference to the creator object
  alive longer than necessary.&nbsp; If possible, the class should be
  made into a <em>static</em> inner class. Since anonymous inner
classes cannot be marked as static, doing this will requiring refactoring
the inner class so that it is a named inner class.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS">
    <ShortDescription>Could be refactored into a static inner class</ShortDescription>
    <LongDescription>The class {0} could be refactored into a _static_ inner class</LongDescription>
    <Details>
<![CDATA[
  <p> This class is an inner class, but does not use its embedded reference
  to the object which created it except during construction of the 
inner object.&nbsp; This reference makes the instances
  of the class larger, and may keep the reference to the creator object
  alive longer than necessary.&nbsp; If possible, the class should be
  made into a <em>static</em> inner class. Since the reference to the
	outer object is required during construction of the inner instance,
	the inner class will need to be refactored so as to 
	pass  a reference to the outer instance to the constructor
	for the inner class.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="WA_NOT_IN_LOOP">
    <ShortDescription>Wait not in loop in method</ShortDescription>
    <LongDescription>Wait not in loop in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This method contains a call to <code>java.lang.Object.wait()</code> 
  which is not in a loop.&nbsp; If the monitor is used for multiple conditions,
  the condition the caller intended to wait for might not be the one
  that actually occurred.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NO_NOTIFY_NOT_NOTIFYALL">
    <ShortDescription>Using notify() rather than notifyAll() in method</ShortDescription>
    <LongDescription>Using notify rather than notifyAll in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This method calls <code>notify()</code> rather than <code>notifyAll()</code>.&nbsp;
  Java monitors are often used for multiple conditions.&nbsp; Calling <code>notify()</code>
  only wakes up one thread, meaning that the thread woken up might not be the
  one waiting for the condition that the caller just satisfied.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="BCPDC_DOUBLECHECK">
    <ShortDescription>Possible double check of field</ShortDescription>
    <LongDescription>Possible doublecheck on {2} in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This is a double check found by the ByteCodePattern-based detector.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED">
    <ShortDescription>Method ignores return value</ShortDescription>
    <LongDescription>{1} ignores return value of {2}</LongDescription>
    <Details>
<![CDATA[
   <p> The return value of this method should be checked.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_ALWAYS_NULL">
    <ShortDescription>Null pointer dereference in method</ShortDescription>
    <LongDescription>Null pointer dereference in {1}</LongDescription>
    <Details>
<![CDATA[
<p> A null pointer is dereferenced here.&nbsp; This will lead to a 
<code>NullPointerException</code> when the code is executed.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_ALWAYS_NULL_EXCEPTION">
    <ShortDescription>Null pointer dereference in method on exception path</ShortDescription>
    <LongDescription>Null pointer dereference in {1} on exception path</LongDescription>
    <Details>
<![CDATA[
<p> A pointer which is null on an exception path is dereferenced here.&nbsp;
This will lead to a <code>NullPointerException</code> when the code is executed.&nbsp;
Note that because FindBugs currently does not prune infeasible exception paths,
this may be a false warning.</p>

<p> Also note that FindBugs considers the default case of a switch statement to
be an exception path, since the default case is often infeasible.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_NULL_ON_SOME_PATH">
    <ShortDescription>Possible null pointer dereference in method</ShortDescription>
    <LongDescription>Possible null pointer dereference in {1}</LongDescription>
    <Details>
<![CDATA[
<p> A reference value dereferenced here might be null at runtime.&nbsp;
This may lead to a <code>NullPointerException</code> when the code is executed.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_NULL_ON_SOME_PATH_EXCEPTION">
    <ShortDescription>Possible null pointer dereference in method on exception path</ShortDescription>
    <LongDescription>Possible null pointer dereference in {1} on exception path</LongDescription>
    <Details>
<![CDATA[
<p> A reference value which is null on some exception control path is
dereferenced here.&nbsp; This may lead to a <code>NullPointerException</code>
when the code is executed.&nbsp;
Note that because FindBugs currently does not prune infeasible exception paths,
this may be a false warning.</p>

<p> Also note that FindBugs considers the default case of a switch statement to
be an exception path, since the default case is often infeasible.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SI_INSTANCE_BEFORE_FINALS_ASSIGNED">
    <ShortDescription>Static initializer for class creates instance before all static final fields assigned</ShortDescription>
    <LongDescription>Static initializer for {0} creates instance before all static final fields assigned</LongDescription>
    <Details>
<![CDATA[
<p> The class's static initializer creates an instance of the class
before all of the static final fields are assigned.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="OS_OPEN_STREAM">
    <ShortDescription>Method may fail to close stream</ShortDescription>
    <LongDescription>{1} may fail to close stream</LongDescription>
    <Details>
<![CDATA[
<p> The method creates an IO stream object, does not assign it to any
fields, pass it to other methods, or return it, and does not appear to close
the stream on all paths out of the method.&nbsp; This may result in
a file descriptor leak.&nbsp; It is generally a good
idea to use a <code>finally</code> block to ensure that streams are
closed.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="OS_OPEN_STREAM_EXCEPTION_PATH">
    <ShortDescription>Method may fail to close stream on exception</ShortDescription>
    <LongDescription>{1} may fail to close stream on exception</LongDescription>
    <Details>
<![CDATA[
<p> The method creates an IO stream object, does not assign it to any
fields, pass it to other methods, or return it, and does not appear to close
it on all possible exception paths out of the method.&nbsp;
This may result in a file descriptor leak.&nbsp; It is generally a good
idea to use a <code>finally</code> block to ensure that streams are
closed.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="PZLA_PREFER_ZERO_LENGTH_ARRAYS">
    <ShortDescription>Consider returning a zero length array rather than null</ShortDescription>
    <LongDescription>Should {1} return a zero length array rather than null?</LongDescription>
    <Details>
<![CDATA[
<p> It is often a better design to
return a length zero array rather than a null reference to indicate that there
are no results (i.e., an empty list of results).
This way, no explicit check for null is needed by clients of the method.</p>

<p>On the otherhand, using null to indicate 
"there is no answer to this question", then it is probably appropriate. 
For example, <code>File.listFiles()</code> returns an empty list
if given a directory containing no files, and returns null if the file
is not a directory.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="UCF_USELESS_CONTROL_FLOW">
    <ShortDescription>Useless control flow in method</ShortDescription>
    <LongDescription>Useless control flow in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a useless control flow statement.&nbsp;
Often, this is caused by inadvertently using an empty statement as the
body of an <code>if</code> statement, e.g.:
<pre>
    if (argv.length == 1);
        System.out.println("Hello, " + argv[0]);
</pre>
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RCN_REDUNDANT_COMPARISON_TO_NULL">
    <ShortDescription>Redundant comparison to null</ShortDescription>
    <LongDescription>Redundant comparison to null in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a redundant comparison of a reference value
to null. Two types of redundant comparison are reported:
<ul>
<li> Both values compared are definitely null</li>
<li> One value is definitely null and the other is definitely not null</li>
</ul>
</p>

<p> This particular warning represents two specific kinds of
redundant comparisions:
<ol>
<li> A value was dereferenced, and later explicitly compared to null:
     this often indicates an error in the method</li>
<li> A literal null value was explicitly compared to null:
     this may indicate that the method was modified without
     complete understanding of the invariants of the method</li>
</ol>
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RCN_REDUNDANT_CHECKED_NULL_COMPARISION">
    <ShortDescription>Redundant comparision to null of previously checked value</ShortDescription>
    <LongDescription>Redundant comparision to null of previously checked value in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a redundant comparison of a reference value
to null. Two types of redundant comparison are reported:
<ul>
<li> Both values compared are definitely null</li>
<li> One value is definitely null and the other is definitely not null</li>
</ul>
</p>

<p> This particular warning generally indicates that a
value known not to be null was checked against null.
While the check is not necessary, it may simply be a case
of defensive programming.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="UL_UNRELEASED_LOCK">
    <ShortDescription>Method does not release lock on all paths</ShortDescription>
    <LongDescription>{1} does not release lock on all paths</LongDescription>
    <Details>
<![CDATA[
<p> This method acquires a JSR-166 (<code>java.util.concurrent</code>) lock,
but does not release it on all paths out of the method.  In general, the correct idiom
for using a JSR-166 lock is:
<pre>
    Lock l = ...;
    l.lock();
    try {
        // do something
    } finally {
        l.unlock();
    }
</pre>
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="UL_UNRELEASED_LOCK_EXCEPTION_PATH">
    <ShortDescription>Method does not release lock on all exception paths</ShortDescription>
    <LongDescription>{1} does not release lock on all exception paths</LongDescription>
    <Details>
<![CDATA[
<p> This method acquires a JSR-166 (<code>java.util.concurrent</code>) lock,
but does not release it on all exception paths out of the method.  In general, the correct idiom
for using a JSR-166 lock is:
<pre>
    Lock l = ...;
    l.lock();
    try {
        // do something
    } finally {
        l.unlock();
    }
</pre>
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RC_REF_COMPARISON">
    <ShortDescription>Suspicious reference comparison</ShortDescription>
    <LongDescription>Suspicious comparison of {3} references in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method compares two reference values using the == or != operator,
where the correct way to compare instances of this type is generally
with the equals() method.  Examples of classes which should generally
not be compared by reference are java.lang.Integer, java.lang.Float, etc.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="EC_UNRELATED_TYPES">
    <ShortDescription>Call to equals() comparing different types</ShortDescription>
    <LongDescription>Call to equals() comparing different types in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method calls equals(Object) on two references of different
types.  According to the contract of equals(), objects of different
classes should always compare as unequal; therefore, it is likely
that the result of this comparision will always be false at runtime.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="EC_UNRELATED_INTERFACES">
    <ShortDescription>Call to equals() comparing different interface types</ShortDescription>
    <LongDescription>Call to equals() comparing different interface types in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method calls equals(Object) on two references of unrelated
interface types (neither is a subtype of the other).  According to
the contract of equals(), objects of different classes should always
compare as unequal. Note that it is possible that
the program contains classes that implement both interfaces,
so the comparison may be valid.  However, it is worth
inspecting closely.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="EC_NULL_ARG">
    <ShortDescription>Call to equals() with null argument</ShortDescription>
    <LongDescription>Call to equals() with null argument in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method calls equals(Object), passing a null value as
the argument. According to the contract of the equals() method,
this call should always return <code>false</code>.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="MWN_MISMATCHED_WAIT">
    <ShortDescription>Mismatched wait()</ShortDescription>
    <LongDescription>Mismatched wait() in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method calls Object.wait() without obviously holding a lock
on the object.&nbsp;  Calling wait() without a lock held will result in
an <code>IllegalMonitorStateException</code> being thrown.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="MWN_MISMATCHED_NOTIFY">
    <ShortDescription>Mismatched notify()</ShortDescription>
    <LongDescription>Mismatched notify() in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method calls Object.notify() or Object.notifyAll() without obviously holding a lock
on the object.&nbsp;  Calling notify() or notifyAll() without a lock held will result in
an <code>IllegalMonitorStateException</code> being thrown.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SA_LOCAL_SELF_ASSIGNMENT">
    <ShortDescription>Self assignment of local variable</ShortDescription>
    <LongDescription>Self assignment of local variable in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a self assignment of a local variable; e.g.
<pre>
  public void foo() {
    int x = 3;
    x = x;
  }
</pre>
Such assignments are useless, and may indicate a logic error or typo.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SA_FIELD_SELF_ASSIGNMENT">
    <ShortDescription>Self assignment of field</ShortDescription>
    <LongDescription>Self assignment of field {2} in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a self assignment of a field; e.g.
<pre>
  int x;
  public void foo() {
    x = x;
  }
</pre>
Such assignments are useless, and may indicate a logic error or typo.
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="BIT_AND">
    <ShortDescription>Incompatible bit masks</ShortDescription>
    <LongDescription>Incompatible bit masks yield a constant result in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method compares an expression of the form (a &amp; C) to D,
which will always compare unequal
due to the specific values of constants C and D.
This may indicate a logic error or typo.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="BIT_AND_ZZ">
    <ShortDescription>Incompatible bit masks</ShortDescription>
    <LongDescription>Incompatible bit masks yield a constant result in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method compares an expression of the form (a &amp; 0) to 0,
which will always compare equal.
This may indicate a logic error or typo.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="BIT_IOR">
    <ShortDescription>Incompatible bit masks</ShortDescription>
    <LongDescription>Incompatible bit masks yield a constant result in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method compares an expression of the form (a | C) to D.
which will always compare unequal
due to the specific values of constants C and D.
This may indicate a logic error or typo.</p>

<p> Typically, this bug occurs because the code wants to perform
a membership test in a bit set, but uses the bitwise OR
operator ("|") instead of bitwise AND ("&amp;").</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="LI_LAZY_INIT_INSTANCE">
    <ShortDescription>Incorrect lazy initialization of instance field</ShortDescription>
    <LongDescription>Incorrect lazy initialization of instance field {2} in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains an unsynchronized lazy initialization of a non-volatile field.
Because the compiler or processor may reorder instructions,
threads are not guaranteed to see a completely initialized object,
<em>if the method can be called by multiple threads</em>.
You can make the field volatile to correct the problem.
For more information, see the
<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java Memory Model web site</a>.
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="LI_LAZY_INIT_STATIC">
    <ShortDescription>Incorrect lazy initialization of static field</ShortDescription>
    <LongDescription>Incorrect lazy initialization of static field {2} in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains an unsynchronized lazy initialization of a non-volatile static field.
Because the compiler or processor may reorder instructions,
threads are not guaranteed to see a completely initialized object,
<em>if the method can be called by multiple threads</em>.
You can make the field volatile to correct the problem.
For more information, see the
<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java Memory Model web site</a>.
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="JLM_JSR166_LOCK_MONITORENTER">
    <ShortDescription>Synchronization performed on JSR166 Lock in method</ShortDescription>
    <LongDescription>Synchronization performed on JSR166 Lock in method {1}</LongDescription>
<Details>
<![CDATA[
<p> This method performs synchronization on an implementation of
<code>java.util.concurrent.locks.Lock</code>.  You should use
the <code>lock()</code> and <code>unlock()</code> methods instead.
</p>
]]>
</Details>
  </BugPattern>

  <BugPattern type="UPM_UNCALLED_PRIVATE_METHOD">
    <ShortDescription>Private method is never called</ShortDescription>
    <LongDescription>Private method {1} is never called</LongDescription>
<Details>
<![CDATA[
<p> This private method is never called. Although it is
possible that the method will be invoked through reflection,
it is more likely that the method is never used, and should be
removed.
</p>
]]>
</Details>
  </BugPattern>

  <BugPattern type="ODR_OPEN_DATABASE_RESOURCE">
    <ShortDescription>Method may fail to close database resource</ShortDescription>
    <LongDescription>{1} may fail to close database resource</LongDescription>
    <Details>
<![CDATA[
<p> The method creates a database resource (such as a database connection
or row set), does not assign it to any
fields, pass it to other methods, or return it, and does not appear to close
the object on all paths out of the method.&nbsp; Failure to
close database resources on all paths out of a method may
result in poor performance, and could cause the application to
have problems communicating with the database.
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH">
    <ShortDescription>Method may fail to close database resource on exception</ShortDescription>
    <LongDescription>{1} may fail to close database resource on exception</LongDescription>
    <Details>
<![CDATA[
<p> The method creates a database resource (such as a database connection
or row set), does not assign it to any
fields, pass it to other methods, or return it, and does not appear to close
the object on all exception paths out of the method.&nbsp; Failure to
close database resources on all paths out of a method may
result in poor performance, and could cause the application to
have problems communicating with the database.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SBSC_USE_STRINGBUFFER_CONCATENATION">
    <ShortDescription>Method concatenates strings using + in a loop</ShortDescription>
    <LongDescription>Method {1} concatenates strings using + in a loop</LongDescription>
    <Details>
<![CDATA[
<p> The method seems to be building a String using concatenation in a loop.
In each iteration, the String is converted to a StringBuffer/StringBuilder, 
	appended to, and converted back to a String.
	This can lead to a cost quadractic in the number of iterations,
	as the growing string is recopied in each iteration. </p>
	
<p>Better performance can be obtained by using 
a StringBuffer (or StringBuilder in Java 1.5) explicitly.</p>

<p> For example:
<pre>
  // This is bad
  String s = "";
  for (int i = 0; i &lt; field.length; ++i) {
    s = s + field[i];
  }

  // This is better
  StringBuffer buf = new StringBuffer();
  for (int i = 0; i &lt; field.length; ++i) {
    buf.append(field[i]);
  }
  String s = buf.toString();
</pre>
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="ITA_INEFFICIENT_TO_ARRAY">
    <ShortDescription>Method uses toArray() with zero-length array argument</ShortDescription>
    <LongDescription>Method {1} uses Collection.toArray() with zero-length array argument</LongDescription>
    <Details>
<![CDATA[
<p> This method uses the toArray() method of a collection derived class, and passes
in a zero-length prototype array argument.  It is more efficient to use 
<pre>myCollection.toArray(new Foo[myCollection.size()])</pre>
If the array passed in is big enough to store all of the
elements of the collection, then it is populated and returned
directly. This avoids the need to create a second array
(by reflection) to return as the result.</p>
]]>
    </Details>
  </BugPattern>
  
  <BugPattern type="IJU_SETUP_NO_SUPER">
    <ShortDescription>TestCase implements setUp but doesn't call super.setUp()</ShortDescription>
    <LongDescription>TestCase implements setUp but doesn't call super.setUp()</LongDescription>
    <Details>
<![CDATA[
<p> Class is a JUnit TestCase and implements the setUp method. The setUp method should call
super.setUp(), but doesn't.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="IJU_TEARDOWN_NO_SUPER">
    <ShortDescription>TestCase implements tearDown but doesn't call super.tearDown()</ShortDescription>
    <LongDescription>TestCase implements tearDown but doesn't call super.tearDown()</LongDescription>
    <Details>
<![CDATA[
<p> Class is a JUnit TestCase and implements the tearDown method. The tearDown method should call
super.tearDown(), but doesn't.</p>
]]>
    </Details>
  </BugPattern>  
  
  <BugPattern type="IJU_SUITE_NOT_STATIC">
    <ShortDescription>TestCase implements a suite method, but this method is not static and should be</ShortDescription>
    <LongDescription>TestCase implements a suite method, but this method is not static and should be</LongDescription>
    <Details>
<![CDATA[
<p> Class is a JUnit TestCase and implements the suite() method.
 The suite method should be declared as being static, but isn't.</p>
]]>
    </Details>
  </BugPattern>  
  
  <BugPattern type="BOA_BADLY_OVERRIDDEN_ADAPTER">
    <ShortDescription>Method overrides a method implemented in super class Adapter wrongly</ShortDescription>
    <LongDescription>Method overrides a method implemented in super class Adapter wrongly</LongDescription>
    <Details>
<![CDATA[
<p> This method overrides a method found in a parent class, where that class is an Adapter that implements
a listener defined in the java.awt.event or javax.swing.event package. As a result, this method will not 
get called when the event occurs.</p>
]]>
    </Details>
  </BugPattern>
  
  <BugPattern type="BRSA_BAD_RESULTSET_ACCESS">
    <ShortDescription>Method attempts to access a result set field with index 0</ShortDescription>
    <LongDescription>Method attempts to access a result set field with index 0</LongDescription>
    <Details>
<![CDATA[
<p> A call to getXXX or updateXXX methods of a result set was made where the
field index is 0. As ResultSet fields start at index 1, this is always a mistake.</p>
]]>
    </Details>
  </BugPattern>
  
  <BugPattern type="SIO_SUPERFLUOUS_INSTANCEOF">
    <ShortDescription>Unnecessary type check done using instanceof operator</ShortDescription>
    <LongDescription>Unnecessary type check done using instanceof operator when it can be determined statically</LongDescription>
    <Details>
<![CDATA[
<p> Type check performed using the instanceof operator where it can be statically determined whether the object
is of the type requested. </p>
]]>
    </Details>
  </BugPattern>
  
   <!--
  **********************************************************************
   BugCodes
  **********************************************************************
   -->

  <BugCode abbrev="VO" >Use of volatile</BugCode>
  <BugCode abbrev="UI" >Unsafe inheritance</BugCode>
  <BugCode abbrev="FL" >Use of floating point precision</BugCode>
  <BugCode abbrev="TEST" >Testing prototype and incomplete bug pattern</BugCode>
  <BugCode abbrev="IMSE" >Dubious catching of IllegalMonitorStateException</BugCode>
  <BugCode abbrev="CN" >Bad implementation of cloneable idiom</BugCode>
  <BugCode abbrev="FI" >Incorrect use of finalizers</BugCode>
  <BugCode abbrev="ES" >Checking String equality using == or !=</BugCode>
  <BugCode abbrev="ML" >Synchronization on updated field (Mutable Lock)</BugCode>
  <BugCode abbrev="UG" >Unsynchronized get method, synchronized set method</BugCode>
  <BugCode abbrev="IC" >Initialization circularity</BugCode>
  <BugCode abbrev="SI" >Suspicious static initializer</BugCode>
  <BugCode abbrev="IS" >Inconsistent synchronization</BugCode>
  <BugCode abbrev="IS2" >Inconsistent synchronization</BugCode>
  <BugCode abbrev="Eq" >Covariant equals()</BugCode>
  <BugCode abbrev="Co" >Covariant compareTo()</BugCode>
  <BugCode abbrev="HE" >Equal objects must have equal hashcodes</BugCode>
  <BugCode abbrev="AM" >API misuse</BugCode>
  <BugCode abbrev="Dm" >Dubious method used</BugCode>
  <BugCode abbrev="UR" >Uninitialized read of field in constructor</BugCode>
  <BugCode abbrev="RR" >Method ignores results of InputStream.read()</BugCode>
  <BugCode abbrev="NN" >Naked notify in method</BugCode>
  <BugCode abbrev="UW" >Unconditional wait in method</BugCode>
  <BugCode abbrev="SP" >Method spins on field</BugCode>
  <BugCode abbrev="DC" >Possible double check of field</BugCode>
  <BugCode abbrev="Wa" >Wait not in loop in method</BugCode>
  <BugCode abbrev="No" >Using notify() rather than notifyAll() in method</BugCode>
  <BugCode abbrev="DE" >Dropped or ignored exception</BugCode>
  <BugCode abbrev="Ru" >Method invokes run()</BugCode>
  <BugCode abbrev="It" >Incorrect definition of Iterator</BugCode>
  <BugCode abbrev="SnVI" >Serializable class with no Version ID</BugCode>
  <BugCode abbrev="Se" >Incorrect definition of Serializable class</BugCode>
  <BugCode abbrev="WS" >Class's writeObject() method is synchronized but nothing else is</BugCode>
  <BugCode abbrev="RS" >Class's readObject() method is synchronized</BugCode>
  <BugCode abbrev="SC" >Constructor invokes Thread.start()</BugCode>
  <BugCode abbrev="MS" >Mutable static field</BugCode>
  <BugCode abbrev="EI" >Method returning array may expose internal representation</BugCode>
  <BugCode abbrev="Nm" >Confusing method name(s)</BugCode>
  <BugCode abbrev="SS" >Unread field should be static?</BugCode>
  <BugCode abbrev="UuF" >Unused field</BugCode>
  <BugCode abbrev="UrF" >Unread field</BugCode>
  <BugCode abbrev="UwF" >Unwritten field</BugCode>
  <BugCode abbrev="SIC" >Inner class could be made static</BugCode>
  <BugCode abbrev="2LW" >Wait with two locks held</BugCode>
  <BugCode abbrev="BcpDC">Possible double check of field</BugCode>
  <BugCode abbrev="RV" >Return value of method is ignored</BugCode>
  <BugCode abbrev="NP" >Null pointer dereference</BugCode>
  <BugCode abbrev="OS">Stream not closed on all paths</BugCode>
  <BugCode abbrev="PZLA" >Prefer zero length arrays to null to indicate no results</BugCode>
  <BugCode abbrev="UCF">Useless control flow</BugCode>
  <BugCode abbrev="RCN">Redundant comparison to null</BugCode>
  <BugCode abbrev="UL">Lock not released on all paths</BugCode>
  <BugCode abbrev="RC">Suspicious reference comparison</BugCode>
  <BugCode abbrev="EC">Suspicious equals() comparison</BugCode>
  <BugCode abbrev="MWN">Mismatched wait() or notify()</BugCode>
  <BugCode abbrev="SA">Useless self-assignment</BugCode>
  <BugCode abbrev="BIT">Suspicious bitwise logical expression</BugCode>
  <BugCode abbrev="LI">Unsynchronized Lazy Initialization</BugCode>
  <BugCode abbrev="JLM">Synchronization on JSR166 Lock</BugCode>
  <BugCode abbrev="UPM">Private method is never called</BugCode>
  <BugCode abbrev="EI2">Storing reference to mutable object</BugCode>
  <BugCode abbrev="NS">Suspicious use of non-short-circuit boolean operator</BugCode>
  <BugCode abbrev="ODR">Database resource not closed on all paths</BugCode>
  <BugCode abbrev="SBSC">String concatenation in loop using + operator</BugCode>
  <BugCode abbrev="ITA">Inefficient use of collection.toArray(new Foo[0])</BugCode>
  <BugCode abbrev="SW">Swing coding rules</BugCode>
  <BugCode abbrev="MF">Masked Field</BugCode>
  <BugCode abbrev="IJU">Improperly implemented JUnit TestCase</BugCode>
  <BugCode abbrev="BOA">Badly Overridden Adapter</BugCode>
  <BugCode abbrev="SF">Switch case falls thru</BugCode>
  <BugCode abbrev="BRSA">Bad ResultSet access</BugCode>
  <BugCode abbrev="SIO">Superfluous instanceof</BugCode>
  </MessageCollection>
