<?xml version="1.0" encoding="UTF-8"?> 
<MessageCollection>

<!--
  **********************************************************************
Detectors
  **********************************************************************
-->

  <Detector class="edu.umd.cs.findbugs.detect.DroppedException">
    <Details>
<![CDATA[
<p> This detector looks for code where an exception is caught,
but nothing is done to handle the exception.  It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.DumbMethods">
    <Details>
<![CDATA[
<p> This detector looks for calls to pointless methods,
such as the no-argument String constructor.
It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindDoubleCheck" >
    <Details>
<![CDATA[
<p> This detector looks for instances of double checked locking.
It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindFinalizeInvocations" >
    <Details>
<![CDATA[
<p> This detector looks for calls to finalize() and other finalizer-related
issues.  It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindHEmismatch" >
    <Details>
<![CDATA[
<p> This detector looks for problems in the definition of the hashCode() and equals()
methods.  It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindNakedNotify" >
    <Details>
<![CDATA[
<p> This detector looks for calls to notify() that don't seem
to modify mutable object state.  It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindReturnRef" >
    <Details>
<![CDATA[
<p> This detector looks for methods that return mutable static data.
It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindRunInvocations" >
    <Details>
<![CDATA[
<p> This detector looks for calls to Thread.run().  It is a fast
detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindSpinLoop" >
    <Details>
<![CDATA[
<p> This detector looks for loops that spin reading from a field.
It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindTwoLockWait" >
    <Details>
<![CDATA[
<p> This detector looks for calls to wait() with two (or more) locks held.
It is a slow detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUnconditionalWait" >
    <Details>
<![CDATA[
<p> This detector looks for calls to wait() not in a conditional or loop.
It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUninitializedGet" >
    <Details>
<![CDATA[
<p> This detector looks for reads of uninitialized fields in constructors.
It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUnsyncGet" >
    <Details>
<![CDATA[
<p> This detector looks for get and set methods where the get is unsynchronized
while the set is synchronized.  It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.InitializationChain" >
    <Details>
<![CDATA[
<p> This detector looks for potentially circular class initialization
dependencies.  It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.IteratorIdioms" >
    <Details>
<![CDATA[
<p> This iterator looks for problems in how Iterator classes are defined.
It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.LockedFields" disabled="true" >
    <Details>
<![CDATA[
<p> This detector looks for fields that are accessed in an inconsistent manner
with respect to locking.  It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.EqStringTest" >
    <Details>
<![CDATA[
<p> This detector looks for comparisons of String objects using the == or !=
operators.
 It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.MutableLock" >
    <Details>
<![CDATA[
<p> This detector looks for synchronization on objects read from
modified fields.  It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.MutableStaticFields" >
    <Details>
<![CDATA[
<p> This detector looks for static fields that may be modified by
malicious code.  It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.Naming" >
    <Details>
<![CDATA[
<p> This detector looks for suspiciously-named methods.  It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.ReadReturnShouldBeChecked" >
    <Details>
<![CDATA[
<p> This detector looks for calls to InputStream.read() where the
return value is ignored.  It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.SerializableIdiom" >
    <Details>
<![CDATA[
<p> This detector looks for potential problems in the implementation
of Serializable classes.  It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.StartInConstructor" >
    <Details>
<![CDATA[
<p> This detector looks for constructors that start threads.  It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.UnreadFields" >
    <Details>
<![CDATA[
<p> This detector looks for fields whose value is never read.  It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.WaitInLoop" >
    <Details>
<![CDATA[
<p> This detector looks for calls to wait() that are not in a loop.
It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.BCPDoubleCheck" disabled="true" >
    <Details>
<![CDATA[
<p> This detector looks for instances of double checked locking.
It is implemented using the ByteCodePattern class.  You might want to
take a look at its source code as an example of an easy way to implement a bug
pattern detector.  It is a fairly fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.BCPMethodReturnCheck" >
    <Details>
<![CDATA[
<p> This detector looks for calls to methods where the return value
is suspiciously ignored.  It is a fairly fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindNullDeref">
    <Details>
<![CDATA[
<p> This detector looks for places where a null pointer exception might
occur.  It also looks for redundant comparisons of reference values against
null.  It is a moderately fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindOpenStream">
    <Details>
<![CDATA[
<p> This detector looks for IO stream objects which do not escape the
method and do not appear to be closed on all paths out of the method.
It is a moderately fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.PreferZeroLengthArrays">
    <Details>
<![CDATA[
<p> This detector looks for methods that return either arrays or an explicit null reference.
Returning a zero length array is generally preferred in this context to returning a null reference.
It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUselessControlFlow">
    <Details>
<![CDATA[
<p> This detector looks for control flow statements which have no effect.
It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUnreleasedLock">
    <Details>
<![CDATA[
<p> This detector looks for JSR-166 (<code>java.util.concurrent</code>)
locks which are acquired, but not released on all paths out of the method.&nbsp;
It is a moderately fast detector.&nbsp; Note that in order to use this
detector, you need to have the <code>java.util.concurrent</code> package
in the auxiliary classpath (or be analyzing the package itself).
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindRefComparison">
    <Details>
<![CDATA[
<p> This detector looks for places where two reference values are compared
with the == or != operator, and the class is of a type (such as <code>java.lang.String</code>)
where comparing reference values is generally an error.  It is a moderately
fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindMismatchedWaitOrNotify">
    <Details>
<![CDATA[
<p> This detector looks for calls to wait(), notify(), or notifyAll()
which do not appear to be made on an object which is currently locked.&nbsp;
It is a moderately fast detector.&nbsp; <b>This detector is disabled because
it is still under development, and produces too many false positives.</b>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindInconsistentSync2" >
    <Details>
<![CDATA[
<p> This detector looks for fields that are accessed in an inconsistent manner
with respect to locking.  It is a slow detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindLocalSelfAssignment">
    <Details>
<![CDATA[
<p> This detector looks for self assignments of local variables.
It is a fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.LazyInit">
    <Details>
<![CDATA[
<p> This detector looks for lazy field initialization where the
field is not volatile.  It is a moderately fast detector.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindBugsSummaryStats">
    <Details>
<![CDATA[
<p> This dectector just collects summary statistics information about the analysis process. 
]]>
    </Details>
  </Detector>

<!--
  **********************************************************************
  BugPatterns
  **********************************************************************
-->

  <BugPattern type="DE_MIGHT_DROP">
    <ShortDescription>例外を見落としている疑い</ShortDescription>
    <LongDescription>{1} は {2} を見落としている疑い</LongDescription>
    <Details>
<![CDATA[
  <p> This method might drop an exception.&nbsp; In general, exceptions
  should be handled or reported in some way, or they should be thrown
  out of the method.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DE_MIGHT_IGNORE">
    <ShortDescription>例外を無視している疑い</ShortDescription>
    <LongDescription>{1} は {3} を無視している</LongDescription>
    <Details>
<![CDATA[
  <p> This method might ignore an exception.&nbsp; In general, exceptions
  should be handled or reported in some way, or they should be thrown
  out of the method.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_CTOR">
    <ShortDescription>コンストラクタnew String() を呼んでいる。文字列をそのまま使うべき</ShortDescription>
    <LongDescription>{1} コンストラクタnew String() を呼んでいる。文字列をそのまま使うべき</LongDescription>
    <Details>
<![CDATA[
  <p> Using the <code>java.lang.String(String)</code> constructor wastes memory
  because the object so constructed will be functionally indistinguishable
  from the <code>String</code> passed as a parameter.&nbsp; Just use the
  argument <code>String</code> directly.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_VOID_CTOR">
    <ShortDescription>コンストラクタnew String() を呼んでいる。そのまま "" を使うべき</ShortDescription>
    <LongDescription>{1} コンストラクタnew String() を呼んでいる。そのまま "" を使うべき</LongDescription>
    <Details>
<![CDATA[
  <p> Creating a new <code>java.lang.String</code> object using the
  no-argument constructor wastes memory because the object so created will
  be functionally indistinguishable from the empty string constant
  <code>""</code>.&nbsp; Java guarantees that identical string constants
  will be represented by the same <code>String</code> object.&nbsp; Therefore,
  you should just use the empty string constant directly.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_GC">
    <ShortDescription>強制的にGCを呼んでいる。ベンチマーク以外は利用の必要性がない</ShortDescription>
    <LongDescription>{1} 強制的にGCを呼んでいる。ベンチマーク以外は利用の必要性がない</LongDescription>
    <Details>
<![CDATA[
  <p> Code explicitly invokes garbage collection.
  Except for specific use in benchmarking, this is very dubious.
  <p>In the past, situations where people have explicitly invoked 
  the garbage collector in routines such as close or finalize methods
  has led to huge performance black holes. Garbage collection 
	can be expensive. Any situation that forces hundreds or thousands
	of garbage collections will bring the machine to a crawl.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_BOOLEAN_CTOR">
    <ShortDescription>Booleanのコンストラクタを呼んでいる。 Boolean.valueOf(...) を使うべき</ShortDescription>
    <LongDescription>{1} Booleanのコンストラクタを呼んでいる。 Boolean.valueOf(...) を使うべき</LongDescription>
    <Details>
<![CDATA[
  <p> Creating new instances of <code>java.lang.Boolean</code> wastes
  memory, since <code>Boolean</code> objects are immutable and there are
  only two useful values of this type.&nbsp; Use the <code>Boolean.valueOf()</code>
  method to create <code>Boolean</code> objects instead.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DC_DOUBLECHECK">
    <ShortDescription>ダブルチェックしている可能性がある。</ShortDescription>
    <LongDescription>{2} を {1} でダブルチェックしている可能性がある。</LongDescription>
    <Details>
<![CDATA[
  <p> This method may contain an instance of double-checked locking.&nbsp;
  This idiom is not correct according to the semantics of the Java memory
  model.&nbsp; For more information, see the web page
  <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html"
  >http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</a>.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="FI_PUBLIC_SHOULD_BE_PROTECTED">
    <ShortDescription>Finalizer はpublicだがprotectedであるべき</ShortDescription>
    <LongDescription>{1} はpublicだがprotectedであるべき</LongDescription>
    <Details>
<![CDATA[
  <p> A class's <code>finalize()</code> method should have protected access,
   not public.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_EMPTY">
    <ShortDescription>空なFinalizerなので削除すべき</ShortDescription>
    <LongDescription>{1} は空なので削除すべき</LongDescription>
    <Details>
<![CDATA[
  <p> Empty <code>finalize()</code> methods are useless, so they should
  be deleted.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_NULLIFY_SUPER">
    <ShortDescription>Finalizerはスーパークラスのfinalize(); を無視している。</ShortDescription>
    <LongDescription>{1} はスーパークラスの {2}.finalize(); を無視している。わざと？</LongDescription>
    <Details>
<![CDATA[
  <p> This empty <code>finalize()</code> method explicitly negates the
  effect of any finalizer defined by its superclass.&nbsp; Any finalizer
  actions defined for the superclass will not be performed.&nbsp;
  Unless this is intended, delete this method.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_USELESS">
    <ShortDescription>super.finalize(); 以外何もしていない。</ShortDescription>
    <LongDescription>{1} super.finalize(); 以外何もしていないので削除すべき</LongDescription>
    <Details>
<![CDATA[
  <p> The only thing this <code>finalize()</code> method does is call
  the superclass's <code>finalize()</code> method, making it
  redundant.&nbsp; Delete it.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_MISSING_SUPER_CALL">
    <ShortDescription>Finalizer にsuper.finalize()への呼び出しがない</ShortDescription>
    <LongDescription>{1} super.finalize()への呼び出しがないので {2}.finalize() が呼び出されない</LongDescription>
    <Details>
<![CDATA[
  <p> This <code>finalize()</code> method does not make a call to its
  superclass's <code>finalize()</code> method.&nbsp; So, any finalizer
  actions defined for the superclass will not be performed.&nbsp;
  Add a call to <code>super.finalize()</code>.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_EXPLICIT_INVOCATION">
    <ShortDescription>Finalizerを明示的に読んでいる</ShortDescription>
    <LongDescription>{1} 明示的に {2}を呼んでいる</LongDescription>
    <Details>
<![CDATA[
  <p> This method contains an explicit invocation of the <code>finalize()</code>
  method on an object.&nbsp; Because finalizer methods are supposed to be
  executed once, and only by the VM, this is a bad idea.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_SELF_USE_OBJECT">
    <ShortDescription>covariantメソッドequals()を定義しているが, Object.equals(Object) は継承のまま</ShortDescription>
    <LongDescription>{0} はequals({0})メソッドを定義しているがObject.equals(Object)を利用している</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a covariant version of the <code>equals()</code>
  method, but calls the normal <code>equals(Object)</code> method
  defined in the base <code>java.lang.Object</code> class.&nbsp;
  The class should probably define a non-covariant version of <code>equals()</code>.&nbsp;
  (I.e., a method with the signature <code>boolean equals(java.lang.Object)</code>.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_SELF_NO_OBJECT">
    <ShortDescription>covariantメソッドequals()を定義している</ShortDescription>
    <LongDescription>{0} はequals({0})メソッドを定義しているがequals(Object)を定義していない</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a covariant version of <code>equals()</code>.&nbsp;
  To correctly override the <code>equals()</code> method in
  <code>java.lang.Object</code>, the parameter of <code>equals()</code>
  must have type <code>java.lang.Object</code>.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_SELF_NO_OBJECT">
    <ShortDescription>covariantメソッドcompareTo()を定義している</ShortDescription>
    <LongDescription>{0} はcomparesTo({0})メソッドを定義しているがcomparesTo(Object)を定義していない</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a covariant version of <code>compareTo()</code>.&nbsp;
  To correctly override the <code>compareTo()</code> method in the
  <code>Comparable</code> interface, the parameter of <code>compareTo()</code>
  must have type <code>java.lang.Object</code>.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_HASHCODE_USE_OBJECT_EQUALS">
    <ShortDescription>hashCode()を定義しているがObject.equals()を使っている</ShortDescription>
    <LongDescription>{0} はhashCodeメソッドを定義しているがObject.equals()を利用している</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>hashCode()</code> method but inherits its
  <code>equals()</code> method from <code>java.lang.Object</code>
  (which defines equality by comparing object references).&nbsp; Although
  this will probably satisfy the contract that equal objects must have
  equal hashcodes, it is probably not what was intended by overriding
  the <code>hashCode()</code> method.&nbsp; (Overriding <code>hashCode()</code>
  implies that the object's identity is based on criteria more complicated
  than simple reference equality.)
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_HASHCODE_NO_EQUALS">
    <ShortDescription>hashCode()を定義しているがequals()を定義していない</ShortDescription>
    <LongDescription>{0} はhashCodeメソッドを定義しているがequalsを定義していない</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>hashCode()</code> method but not an
  <code>equals()</code> method.&nbsp; Therefore, the class may
  violate the invariant that equal objects must have equal hashcodes.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_EQUALS_USE_HASHCODE">
    <ShortDescription>equalsメソッドを定義しているがObject.hashCode()を利用している</ShortDescription>
    <LongDescription>{0} はequalsメソッドを定義しているがObject.hashCode()を利用している</LongDescription>
    <Details>
<![CDATA[
  <p> This class overrides <code>equals(Object)</code>, but does not
  override <code>hashCode()</code>, and inherits the implementation of
  <code>hashCode()</code> from <code>java.lang.Object</code> (which returns
  the identity hash code, an arbitrary value assigned to the object
  by the VM).&nbsp; Therefore, the class is very likely to violate the
  invariant that equal objects must have equal hashcodes.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_EQUALS_NO_HASHCODE">
    <ShortDescription>equalsメソッドを定義しているがhashCodeを定義してない</ShortDescription>
    <LongDescription>{0} はequalsメソッドを定義しているがhashCodeを定義してない</LongDescription>
    <Details>
<![CDATA[
  <p> This class overrides <code>equals(Object)</code>, but does not
  override <code>hashCode()</code>.&nbsp; Therefore, the class may violate the
  invariant that equal objects must have equal hashcodes.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ABSTRACT_SELF">
    <ShortDescription>抽象クラス はcovariantメソッドequals()を定義している</ShortDescription>
    <LongDescription>Abstract {0} はequals({0})メソッドを定義している</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a covariant version of <code>equals()</code>.&nbsp;
  To correctly override the <code>equals()</code> method in
  <code>java.lang.Object</code>, the parameter of <code>equals()</code>
  must have type <code>java.lang.Object</code>.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="ES_COMPARING_STRINGS_WITH_EQ">
    <ShortDescription>Comparison of String objects using == or !=</ShortDescription>
    <LongDescription>Comparison of String objects using == or != in {1} </LongDescription>
    <Details>
<![CDATA[
  <p>This code compares <code>java.lang.String</code> objects for reference
equality using the == or != operators.
Unless both strings are either constants in a source file, or have been
interned using the <code>String.intern()</code> method, the same string
value may be represented by two different String objects. Considering
using the <code>equals</code> method instead.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="CO_ABSTRACT_SELF">
    <ShortDescription>抽象クラス はcovariantメソッドcompareTo()を定義している</ShortDescription>
    <LongDescription>Abstract {0} はcompareTo({0})メソッドを定義している</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a covariant version of <code>compareTo()</code>.&nbsp;
  To correctly override the <code>compareTo()</code> method in the
  <code>Comparable</code> interface, the parameter of <code>compareTo()</code>
  must have type <code>java.lang.Object</code>.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS2_INCONSISTENT_SYNC">
    <ShortDescription>同期の仕方が不統一</ShortDescription>
    <LongDescription>{1}の同期の仕方が不統一。{2}% のアクセスでsynchronizedしている。</LongDescription>
    <Details>
<![CDATA[
  <p> The fields of this class appear to be accessed inconsistently with respect
  to synchronization.&nbsp; This bug report indicates that the bug pattern detector
  judged that
  <ol>
  <li> The class contains a mix of locked and unlocked accesses,
  <li> At least one locked access was performed by one of the class's own methods, and
  <li> The number of unsynchronized field accesses (reads and writes) was no more than
       one third of all accesses, with writes being weighed twice as high as reads
  </ol>

  <p> A typical bug matching this bug pattern is forgetting to synchronize
  one of the methods in a class that is intended to be thread-safe.

  <p> You can select the nodes labeled "Unsynchronized access" to show the
  code locations where the detector believed that a field was accessed
  without synchronization.

  <p> Note that there are various sources of inaccuracy in this detector;
  for example, the detector cannot statically detect all situations in which
  a lock is held.&nbsp; Also, even when the detector is accurate in
  distinguishing locked vs. unlocked accesses, the code in question may still
  be correct.

  <p> This description refers to the "IS2" version of the pattern detector,
  which has more accurate ways of detecting locked vs. unlocked accesses
  than the older "IS" detector.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NN_NAKED_NOTIFY">
    <ShortDescription>notifyは裸のまま。</ShortDescription>
    <LongDescription>{1} のnotifyは裸のまま。</LongDescription>
    <Details>
<![CDATA[
  <p> A call to <code>notify()</code> or <code>notifyAll()</code>
  was made without any (apparent) accompanying
  modification to mutable object state.&nbsp; In general, calling a notify
  method on a monitor is done because some condition another thread is
  waiting for has become true.&nbsp; However, for the condition to be meaningful,
  it must involve a heap object that is visible to both threads.

  <p> This bug does not necessarily indicate an error, since the change to
  mutable object state may have taken place in a method which then called
  the method containing the notification.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_EXPOSE_REP">
    <ShortDescription>Public static メソッドが配列を返すことで内部表現をさらしている可能性がある</ShortDescription>
    <LongDescription>public static {1} が {2} を返すことで内部表現をさらしている可能性がある</LongDescription>
    <Details>
<![CDATA[
  <p> A public static method returns a reference to
	an array that is part of the static state of the class. 
	Any code that calls this method can freely modify
	the underlying array.
	One fix is to return a copy of the array.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_REP">
    <ShortDescription>メソッドが配列を返すことで内部表現をさらしている可能性がある</ShortDescription>
    <LongDescription>{1} が {2} を返すことで内部表現をさらしている可能性がある</LongDescription>
    <Details>
<![CDATA[
  <p> Returning an array value stored in one of the object's fields
  exposes the internal representation of the object.&nbsp; For classes shared
  by other untrusted classes, this could potentially be a security issue.&nbsp;
  Returning a new copy of the array is better approach in many situations.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RU_INVOKE_RUN">
    <ShortDescription>スレッドのrunを直接呼んでいる。（startではないか）</ShortDescription>
    <LongDescription>{1} スレッドのrunを直接呼んでいる。（startではないか）</LongDescription>
    <Details>
<![CDATA[
  <p> This method explicitly invokes <code>run()</code> on an object.&nbsp;
  In general, classes implement the <code>Runnable</code> interface because
  they are going to have their <code>run()</code> method invoked in a new thread,
  in which case <code>Thread.start()</code> is the right method to call.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SP_SPIN_ON_FIELD">
    <ShortDescription>スピンロックを使っている。</ShortDescription>
    <LongDescription>{2} を使って {1} でスピンロックを使っている。</LongDescription>
    <Details>
<![CDATA[
  <p> This method spins in a loop which reads a field.&nbsp; The compiler
  may legally hoist the read out of the loop, turning the code into an
  infinite loop.&nbsp; The class should be changed so it uses proper
  synchronization (including wait and notify calls).
]]>
    </Details>
  </BugPattern>
  <BugPattern type="2LW_TWO_LOCK_WAIT">
    <ShortDescription>二つのロックを持ったままwait()している。 </ShortDescription>
    <LongDescription>{1}で二つのロックを持ったままwait()している。 </LongDescription>
    <Details>
<![CDATA[
  <p> Waiting on a monitor while two locks are held may cause
  deadlock.&nbsp; This not necessarily a bug, but is worth examining
  closely.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UW_UNCOND_WAIT">
    <ShortDescription>waitに条件文がない</ShortDescription>
    <LongDescription>{1} のwaitに条件文がない</LongDescription>
    <Details>
<![CDATA[
  <p> This method contains a call to <code>java.lang.Object.wait()</code> which
  is not guarded by conditional control flow.&nbsp; If the condition that
  the method intends to wait for has already happened, the thread could
  wait indefinitely.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UR_UNINIT_READ">
    <ShortDescription>コンストラクタで初期化前のフィールドを読んでいる</ShortDescription>
    <LongDescription>{2} を {1} で初期化前に値を読んでいる。</LongDescription>
    <Details>
<![CDATA[
  <p> This constructor reads a field which has not yet been assigned a value.&nbsp;
  This is often caused when the programmer mistakenly uses the field instead
  of one of the constructor's parameters.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UG_SYNC_SET_UNSYNC_GET">
    <ShortDescription>getメソッドは同期していないが、setメソッドは同期している。</ShortDescription>
    <LongDescription>{1} はsynchronizedがないが、 {2} はsynchronizedがある</LongDescription>
    <Details>
<![CDATA[
  <p> This class contains similarly-named get and set
  methods where the set method is synchronized and the get method is not.&nbsp;
  This may result in incorrect behavior at runtime, as callers of the get
  method will not necessarily see a consistent state for the object.&nbsp;
  The get method should be made synchronized.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IC_INIT_CIRCULARITY">
    <ShortDescription>初期化がループしている</ShortDescription>
    <LongDescription>{0} と {1} の間でループする初期化となっている</LongDescription>
    <Details>
<![CDATA[
  <p> A circularity was detected in the static initializers of the two
  classes referenced by the bug instance.&nbsp; Many kinds of unexpected
  behavior may arise from such circularity.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IT_NO_SUCH_ELEMENT">
    <ShortDescription>Iterator next() は NoSuchElement 例外を投げることはない</ShortDescription>
    <LongDescription>{1} は NoSuchElement 例外を投げることはない</LongDescription>
    <Details>
<![CDATA[
  <p> This class implements the <code>java.util.Iterator</code> interface.&nbsp;
  However, its <code>next()</code> method is not capable of throwing
  <code>java.util.NoSuchElementException</code>.&nbsp; The <code>next()</code>
  method should be changed so it throws <code>NoSuchElementException</code>
  if is called when there are no more elements to return.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS_INCONSISTENT_SYNC">
    <ShortDescription>同期の仕方が不統一</ShortDescription>
    <LongDescription>{1} のアクセスが不統一; {2}% の場合同期アクセスしている</LongDescription>
    <Details>
<![CDATA[
  <p> The fields of this class appear to be accessed inconsistently with respect
  to synchronization.&nbsp; This bug report indicates that the bug pattern detector
  judged that
  <ol>
  <li> The class contains a mix of locked and unlocked accesses,
  <li> At least one locked access was performed by one of the class's own methods, and
  <li> The number of unsynchronized field accesses (reads and writes) was no more than
       one third of all accesses, with writes being weighed twice as high as reads
  </ol>

  <p> A typical bug matching this bug pattern is forgetting to synchronize
  one of the methods in a class that is intended to be thread-safe.

  <p> Note that there are various sources of inaccuracy in this detector;
  for example, the detector cannot statically detect all situations in which
  a lock is held.&nbsp; Also, even when the detector is accurate in
  distinguishing locked vs. unlocked accesses, the code in question may still
  be correct.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ML_SYNC_ON_UPDATED_FIELD">
    <ShortDescription>更新されるフィールドで同期している</ShortDescription>
    <LongDescription>{1} 更新されるフィールド {2} で同期している</LongDescription>
    <Details>
<![CDATA[
  <p> This method synchronizes on an object 
	references from a mutable field.
	This is unlikely to have useful semantics, since different
threads may be synchronizing on different objects.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_OOI_PKGPROTECT">
    <ShortDescription>Field はinterfaceから取り出してパッケージプロテクトにすべき。</ShortDescription>
    <LongDescription>{1} はinterfaceから取り出してパッケージプロテクトにすべき。</LongDescription>
    <Details>
<![CDATA[
<p>
 A final static field that is 
defined in an interface references a mutable
	object such as an array or hashtable.
	This mutable object could 
	be changed by malicious code or
        by accident from another package.
	So solve this, the field needs to be moved to a class
	and made package protected 
	to avoid
        this vulnerability.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_FINAL_PKGPROTECT">
    <ShortDescription>Fieldはfinalでパッケージプロテクトにすべき。</ShortDescription>
    <LongDescription>{1} はfinalでパッケージプロテクトにすべき。</LongDescription>
    <Details>
<![CDATA[
 <p>
	A mutable static field could be changed by malicious code or
        by accident from another package.
        The field could be made package protected and/or made final 
	to avoid
        this vulnerability.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_SHOULD_BE_FINAL">
    <ShortDescription>Fieldはfinalではないがfinalにすべき。</ShortDescription>
    <LongDescription>{1} はfinalではないがfinalにすべき。</LongDescription>
    <Details>
<![CDATA[
	<p>
 A mutable static field could be changed by malicious code or
        by accident from another package.
        The field could be made final to avoid
        this vulnerability.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_PKGPROTECT">
    <ShortDescription>Fieldはパッケージプロテクトにすべき</ShortDescription>
    <LongDescription>{1} はパッケージプロテクトにすべき</LongDescription>
    <Details>
<![CDATA[
  <p> A mutable static field could be changed by malicious code or
	by accident.
	The field could be made package protected to avoid
	this vulnerability.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_HASHTABLE">
    <ShortDescription>Fieldはmutableな Hashtable</ShortDescription>
    <LongDescription>{1}はmutableな Hashtable</LongDescription>
    <Details>
<![CDATA[
 <p>A final static field references an Hashtable
	and can be accessed by malicious code or
        by accident from another package.
	This code can freely modify the contents of the array.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_ARRAY">
    <ShortDescription>Fieldはmutableな array</ShortDescription>
    <LongDescription>{1} はmutableな array</LongDescription>
    <Details>
<![CDATA[
 A final static field references an array
	and can be accessed by malicious code or
        by accident from another package.
	This code can freely modify the contents of the array.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_CANNOT_BE_FINAL">
    <ShortDescription>Field はfinalでないしfinalになれない</ShortDescription>
    <LongDescription>{1} はfinalでないしfinalになれない</LongDescription>
    <Details>
<![CDATA[
  <p> 
 A mutable static field could be changed by malicious code or
        by accident from another package.
	Unfortunately, the way the field is used doesn't allow
	any easy fix to this problem.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_VERY_CONFUSING">
    <ShortDescription>メソッド名がとても紛らわしい</ShortDescription>
    <LongDescription>メソッド {1} とメソッド {3} を持つのはとてもわかりにくい</LongDescription>
    <Details>
<![CDATA[
  <p> The referenced methods have names that differ only by capitalization.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CONFUSING">
    <ShortDescription>メソッド名が紛らわしい</ShortDescription>
    <LongDescription>メソッド {1} とメソッド {3} を持つのはわかりにくい</LongDescription>
    <Details>
<![CDATA[
  <p> The referenced methods have names that differ only by capitalization.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CONFUSING_METHOD_NAME">
    <ShortDescription>メソッド名が紛らわしい</ShortDescription>
    <LongDescription>{1} のメソッド名が紛らわしい</LongDescription>
    <Details>
<![CDATA[
  <p> This method has the same name as the superclass of the class it
  is defined in.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_LCASE_HASHCODE">
    <ShortDescription>Class は hashcode()を定義している。 hashCode()の間違いではないか？</ShortDescription>
    <LongDescription>クラス {0} は hashcode()を定義している。 hashCode()の間違いではないか？</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a method called <code>hashcode()</code>.&nbsp; This method
  does not override the <code>hashCode()</code> method in <code>java.lang.Object</code>,
  which is probably what was intended.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_LCASE_TOSTRING">
    <ShortDescription>Class  は tostring()を定義している。 toString()の間違いではないか？</ShortDescription>
    <LongDescription>クラス {0} は tostring()を定義している。 toString()の間違いではないか？</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a method called <code>tostring()</code>.&nbsp; This method
  does not override the <code>toString()</code> method in <code>java.lang.Object</code>,
  which is probably what was intended.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RR_NOT_CHECKED">
    <ShortDescription>InputStream.read()の戻り値を無視している。</ShortDescription>
    <LongDescription>{1} は {2} の戻り値を無視している。</LongDescription>
    <Details>
<![CDATA[
  <p> This method ignores the return value of one of the variants of
  <code>java.io.InputStream.read()</code> which can return multiple bytes.&nbsp;
  If the return value is not checked, the caller will not be able to correctly
  handle the case where fewer bytes were read than the caller requested.&nbsp;
  This is a particularly insidious kind of bug, because in many programs,
  reads from input streams usually do read the full amount of data requested,
  causing the program to fail only sporadically.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SERIALVERSIONID">
    <ShortDescription>Class is Serializable, but doesn't define serialVersionUID</ShortDescription>
    <LongDescription>{0} is Serializable; consider declaring a serialVersionUID</LongDescription>
    <Details>
<![CDATA[
  <p> This class implements the <code>Serializable</code> interface, but does
  not define a <code>serialVersionUID</code> field.&nbsp; 
  A change as simple as adding a reference to a .class object 
	 will add synthetic fields to the class,
	which will unfortunately change the implicit
	serialVersionUID (e.g., adding a reference to <code>String.class</code>
	will generate a static field <code>class$java$lang$String</code>).
   Also, different source code to bytecode compilers may use different 
   naming conventions for synthetic variables generated for 
   references to class objects or inner classes.
   To ensure interoperability of Serializable across versions,
	consider adding an explicit serialVersionUID.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="WS_WRITEOBJECT_SYNC">
    <ShortDescription>Class's writeObject() method is synchronized but nothing else is</ShortDescription>
    <LongDescription>{0}'s writeObject method is synchronized but nothing else is</LongDescription>
    <Details>
<![CDATA[
  <p> This class has a <code>writeObject()</code> method which is synchronized;
  however, no other method of the class is synchronized.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RS_READOBJECT_SYNC">
    <ShortDescription>Class's readObject() method is synchronized</ShortDescription>
    <LongDescription>{0}'s readObject method is synchronized</LongDescription>
    <Details>
<![CDATA[
  <p> This serializable class defines a <code>readObject()</code> which is
  synchronized.&nbsp; By definition, an object created by deserialization
  is only reachable by one thread, and thus there is no need for
  <code>readObject()</code> to be synchronized.&nbsp; If the <code>readObject()</code>
  method itself is causing the object to become visible to another thread,
  that is an example of very dubious coding style.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NONSTATIC_SERIALVERSIONID">
    <ShortDescription>serialVersionUID isn't static</ShortDescription>
    <LongDescription>{1} はstaticではない</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>serialVersionUID</code> field that is not static.&nbsp;
  The field should be made static
	if it is intended to specify
	the version UID for purposes of serialization.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SE_NONFINAL_SERIALVERSIONID">
    <ShortDescription>serialVersionUID isn't final</ShortDescription>
    <LongDescription>{1} isn't final</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>serialVersionUID</code> field that is not final.&nbsp;
  The field should be made final 
	if it is intended to specify
	the version UID for purposes of serialization.
]]>
    </Details>
  </BugPattern>


  <BugPattern type="SE_NONLONG_SERIALVERSIONID">
    <ShortDescription>serialVersionUID が long ではない</ShortDescription>
    <LongDescription>{1} が long ではない</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>serialVersionUID</code> field that is not long.&nbsp;
  The field should be made long
	if it is intended to specify
	the version UID for purposes of serialization.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SE_BAD_FIELD">
    <ShortDescription>Non-transient non-serializable instance field in serializable class</ShortDescription>
    <LongDescription>Class {0} defines non-transient non-serializable instance field {1}</LongDescription>
    <Details>
<![CDATA[
<p> This Serializable class defines a non-primitive instance field which is neither transient,
Serializable, or <code>java.lang.Object</code>, and does not appear to implement
the <code>Externalizable</code> interface or the
<code>readObject()</code> and <code>writeObject()</code> methods.&nbsp;
Objects of this class will not be deserialized correctly if a non-Serializable
object is stored in this field.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SC_START_IN_CTOR">
    <ShortDescription>コンストラクタが Thread.start()を読んでいる。</ShortDescription>
    <LongDescription>{1} は {2} を呼び出している</LongDescription>
    <Details>
<![CDATA[
  <p> The constructor starts a thread. This is likely to be wrong if
	the class is ever extended/subclassed, since the thread will be started
	before the subclass constructor is started.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SS_SHOULD_BE_STATIC">
    <ShortDescription>フィールド を読んでいない。スタティックにすべき</ShortDescription>
    <LongDescription>フィールド {1}; を読んでいない。スタティックにすべき</LongDescription>
    <Details>
<![CDATA[
  <p> This class contains an instance final field which is never read.&nbsp;
  The fact that it is not read may indicate that the Java source to bytecode
  compiler has propagated its constant value.&nbsp; Consider making it
  static.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UUF_UNUSED_FIELD">
    <ShortDescription>フィールド  を使っていない</ShortDescription>
    <LongDescription>フィールド {1} を使っていない</LongDescription>
    <Details>
<![CDATA[
  <p> This field is never used.&nbsp; Consider removing it from the class.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="URF_UNREAD_FIELD">
    <ShortDescription>フィールド  を読んでいない</ShortDescription>
    <LongDescription>フィールド {1} を読んでいない</LongDescription>
    <Details>
<![CDATA[
  <p> This field is never read.&nbsp; Consider removing it from the class.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_UNWRITTEN_FIELD">
    <ShortDescription>書かれていないフィールド</ShortDescription>
    <LongDescription>書かれていないフィールド: {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This field is never written.&nbsp; All reads of it will return the default
value. Check for errors (should it have been initialized?), or remove it if it is useless.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC">
    <ShortDescription>static 内部クラスにすべき?</ShortDescription>
    <LongDescription>クラス {0} は _static_ 内部クラスにすべき?</LongDescription>
    <Details>
<![CDATA[
  <p> This class is an inner class, but does not use its embedded reference
  to the object which created it.&nbsp; This reference makes the instances
  of the class larger, and may keep the reference to the creator object
  alive longer than necessary.&nbsp; If possible, the class should be
  made into a <em>static</EM> inner class.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="WA_NOT_IN_LOOP">
    <ShortDescription>waitがループに入っていない</ShortDescription>
    <LongDescription >{1}でのwaitがループに入っていない</LongDescription>
    <Details>
<![CDATA[
  <p> This method contains a call to <code>java.lang.Object.wait()</code> 
  which is not in a loop.&nbsp; If the monitor is used for multiple conditions,
  the condition the caller intended to wait for might not be the one
  that actually occurred.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NO_NOTIFY_NOT_NOTIFYALL">
    <ShortDescription>notifyAllではなくnotifyを使っている</ShortDescription>
    <LongDescription>{1} でnotifyAllではなくnotifyを使っている</LongDescription>
    <Details>
<![CDATA[
  <p> This method calls <code>notify()</code> rather than <code>notifyAll()</code>.&nbsp;
  Java monitors are often used for multiple conditions.&nbsp; Calling <code>notify()</code>
  only wakes up one thread, meaning that the thread woken up might not be the
  one waiting for the condition that the caller just satisfied.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="BCPDC_DOUBLECHECK">
    <ShortDescription>Possible double check of field</ShortDescription>
    <LongDescription>Possible doublecheck on {2} in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This is a double check found by the ByteCodePattern-based detector.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED">
    <ShortDescription>メソッドが戻り地を無視している</ShortDescription>
    <LongDescription>{1} は、戻り値 {2} を無視している</LongDescription>
    <Details>
<![CDATA[
   <p> The return value of this method should be checked.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_ALWAYS_NULL">
    <ShortDescription>Null pointer dereference in method</ShortDescription>
    <LongDescription>Null pointer dereference in {1}</LongDescription>
    <Details>
<![CDATA[
<p> A null pointer is dereferenced here.&nbsp; This will lead to a 
<code>NullPointerException</code> when the code is executed.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_ALWAYS_NULL_EXCEPTION">
    <ShortDescription>Null pointer dereference in method on exception path</ShortDescription>
    <LongDescription>Null pointer dereference in {1} on exception path</LongDescription>
    <Details>
<![CDATA[
<p> A pointer which is null on an exception path is dereferenced here.&nbsp;
This will lead to a <code>NullPointerException</code> when the code is executed.&nbsp;
Note that because FindBugs currently does not prune infeasible exception paths,
this may be a false warning.
<p> Also note that FindBugs considers the default case of a switch statement to
be an exception path, since the default case is often infeasible.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_NULL_ON_SOME_PATH">
    <ShortDescription>Possible null pointer dereference in method</ShortDescription>
    <LongDescription>Possible null pointer dereference in {1}</LongDescription>
    <Details>
<![CDATA[
<p> A reference value dereferenced here might be null at runtime.&nbsp;
This may lead to a <code>NullPointerException</code> when the code is executed.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_NULL_ON_SOME_PATH_EXCEPTION">
    <ShortDescription>Possible null pointer dereference in method on exception path</ShortDescription>
    <LongDescription>Possible null pointer dereference in {1} on exception path</LongDescription>
    <Details>
<![CDATA[
<p> A reference value which is null on some exception control path is
dereferenced here.&nbsp; This may lead to a <code>NullPointerException</code>
when the code is executed.&nbsp;
Note that because FindBugs currently does not prune infeasible exception paths,
this may be a false warning.
<p> Also note that FindBugs considers the default case of a switch statement to
be an exception path, since the default case is often infeasible.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SI_INSTANCE_BEFORE_FINALS_ASSIGNED">
    <ShortDescription>Static initializer for class creates instance before all static final fields assigned</ShortDescription>
    <LongDescription>Static initializer for {0} creates instance before all static final fields assigned</LongDescription>
    <Details>
<![CDATA[
<p> The class's static initializer creates an instance of the class
before all of the static final fields are assigned.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="OS_OPEN_STREAM">
    <ShortDescription>メソッドがストリームのクローズに失敗する疑い</ShortDescription>
    <LongDescription>{1} may fail to close stream</LongDescription>
    <Details>
<![CDATA[
<p> The method creates an IO stream object, does not assign it to any
fields, pass it to other methods, or return it, and does not appear to close
the stream on all paths out of the method.&nbsp; This may result in
a file descriptor leak.&nbsp; It is generally a good
idea to use a <code>finally</code> block to ensure that streams are
closed.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="OS_OPEN_STREAM_EXCEPTION_PATH">
    <ShortDescription>メソッドが例外によってストリームのクローズに失敗する疑い</ShortDescription>
    <LongDescription>{1} may fail to close stream on exception</LongDescription>
    <Details>
<![CDATA[
<p> The method creates an IO stream object, does not assign it to any
fields, pass it to other methods, or return it, and does not appear to close
it on all possible exception paths out of the method.&nbsp;
This may result in a file descriptor leak.&nbsp; It is generally a good
idea to use a <code>finally</code> block to ensure that streams are
closed.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="PZLA_PREFER_ZERO_LENGTH_ARRAYS">
    <ShortDescription>Consider returning a zero length array rather than null</ShortDescription>
    <LongDescription>Should {1} return a zero length array rather than null?</LongDescription>
    <Details>
<![CDATA[
<p> It is generally a better design to
return a length zero array rather than a null reference to indicate that there
are no results. This way, no explicit check for null is needed by clients of the method.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="UCF_USELESS_CONTROL_FLOW">
    <ShortDescription>Useless control flow in method</ShortDescription>
    <LongDescription>Useless control flow in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a useless control flow statement.&nbsp;
Often, this is caused by inadvertently using an empty statement as the
body of an <code>if</code> statement, e.g.:
<pre>
    if (argv.length == 1);
        System.out.println("Hello, " + argv[0]);
</pre>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RCN_REDUNDANT_COMPARISON_TO_NULL">
    <ShortDescription>Redundant comparison to null</ShortDescription>
    <LongDescription>Redundant comparison to null in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a redundant comparison of a reference value
to null. Two types of redundant comparison are reported:
<ul>
<li> Both values compared are definitely null
<li> One value is definitely null and the other is definitely not null
</ul>
In either case, the result of the comparison will always be the same at
runtime.  This is likely to inidicate a logic error in the method.
Often, it means that the reference was dereferenced first, and then
tested for null; this can happen because a method was changed without
the programmer realizing that the dereferenced value could be null.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="UL_UNRELEASED_LOCK">
    <ShortDescription>Method does not release lock on all paths</ShortDescription>
    <LongDescription>{1} does not release lock on all paths</LongDescription>
    <Details>
<![CDATA[
<p> This method acquires a JSR-166 (<code>java.util.concurrent</code>) lock,
but does not release it on all paths out of the method.  In general, the correct idiom
for using a JSR-166 lock is:
<pre>
    Lock l = ...;
    l.lock();
    try {
        // do something
    } finally {
        l.unlock();
    }
</pre>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="UL_UNRELEASED_LOCK_EXCEPTION_PATH">
    <ShortDescription>Method does not release lock on all exception paths</ShortDescription>
    <LongDescription>{1} does not release lock on all exception paths</LongDescription>
    <Details>
<![CDATA[
<p> This method acquires a JSR-166 (<code>java.util.concurrent</code>) lock,
but does not release it on all exception paths out of the method.  In general, the correct idiom
for using a JSR-166 lock is:
<pre>
    Lock l = ...;
    l.lock();
    try {
        // do something
    } finally {
        l.unlock();
    }
</pre>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RC_REF_COMPARISON">
    <ShortDescription>Suspicious reference comparison</ShortDescription>
    <LongDescription>Suspicious comparison of {3} references in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method compares two reference values using the == or != operator,
where the correct way to compare instances of this type is generally
with the equals() method.  Examples of classes which should generally
not be compared by reference are java.lang.Integer, java.lang.Float, etc.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="MWN_MISMATCHED_WAIT">
    <ShortDescription>Mismatched wait()</ShortDescription>
    <LongDescription>Mismatched wait() in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method calls Object.wait() without obviously holding a lock
on the object.&nbsp;  Calling wait() without a lock held will result in
an <code>IllegalMonitorStateException</code> being thrown.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="MWN_MISMATCHED_NOTIFY">
    <ShortDescription>Mismatched notify()</ShortDescription>
    <LongDescription>Mismatched notify() in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method calls Object.notify() or Object.notifyAll() without obviously holding a lock
on the object.&nbsp;  Calling notify() or notifyAll() without a lock held will result in
an <code>IllegalMonitorStateException</code> being thrown.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SA_LOCAL_SELF_ASSIGNMENT">
    <ShortDescription>Self assignment of local variable</ShortDescription>
    <LongDescription>Self assignment of local variable in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a self assignment of a local variable; e.g.
<pre>
  public void foo() {
    int x = 3;
    x = x;
  }
</pre>
Such assignments are useless, and may indicate a logic error or typo.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SA_FIELD_SELF_ASSIGNMENT">
    <ShortDescription>Self assignment of field</ShortDescription>
    <LongDescription>Self assignment of field {2} in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a self assignment of a field; e.g.
<pre>
  int x;
  public void foo() {
    x = x;
  }
</pre>
Such assignments are useless, and may indicate a logic error or typo.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="LI_LAZY_INIT_INSTANCE">
    <ShortDescription>Incorrect lazy initalization of instance field</ShortDescription>
    <LongDescription>Incorrect lazy initialization of instance field {2} in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains an unsynchronized lazy initialization of a non-volatile field.
Because the compiler or processor may reorder instructions,
threads are not guaranteed to see a completely initialized object,
<em>if the method can be called by multiple threads</em>.
You can make the field volatile to correct the problem.
For more information, see the
<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java Memory Model web site</a>.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="LI_LAZY_INIT_STATIC">
    <ShortDescription>Incorrect lazy initalization of static field</ShortDescription>
    <LongDescription>Incorrect lazy initialization of static field {2} in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains an unsynchronized lazy initialization of a non-volatile static field.
Because the compiler or processor may reorder instructions,
threads are not guaranteed to see a completely initialized object,
<em>if the method can be called by multiple threads</em>.
You can make the field volatile to correct the problem.
For more information, see the
<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java Memory Model web site</a>.
]]>
    </Details>
  </BugPattern>

<!--
  **********************************************************************
   BugCodes
  **********************************************************************
-->

  <BugCode abbrev="FI" >finalizerの使い方が間違っている</BugCode>
  <BugCode abbrev="ES" >Checking String equality using == or !=</BugCode>
  <BugCode abbrev="ML" >更新されるフィールドでロックしている（ロックオブジェクトが不変でない）</BugCode>
  <BugCode abbrev="UG" >getはsynchroしていないがsetはsynchroしている</BugCode>
  <BugCode abbrev="IC" >初期化がループしている</BugCode>
  <BugCode abbrev="SI" >Suspicious static initializer</BugCode>
  <BugCode abbrev="IS" >synchroの仕方が不統一</BugCode>
  <BugCode abbrev="IS2" >synchroの仕方が不統一</BugCode>
  <BugCode abbrev="Eq" >Covariant equals()</BugCode>
  <BugCode abbrev="Co" >Covariant compareTo()</BugCode>
  <BugCode abbrev="HE" >equal（同じ）オブジェクトが同じhashCodeを持つべき</BugCode>
  <BugCode abbrev="Dm" >疑わしいメソッドを使っている</BugCode>
  <BugCode abbrev="UR" >コンストラクタで初期化前にフィールドを読んでいる</BugCode>
  <BugCode abbrev="RR" >InputStream.read()の戻り値を無視している</BugCode>
  <BugCode abbrev="NN" >メソッド内の裸なnotify</BugCode>
  <BugCode abbrev="UW" >メソッド内の無条件なwait</BugCode>
  <BugCode abbrev="SP" >フィールドでスピンロックしている</BugCode>
  <BugCode abbrev="DC" >フィールドを二重にチェックしている疑い</BugCode>
  <BugCode abbrev="Wa" >メソッド内のwaitはループで待っていない</BugCode>
  <BugCode abbrev="No" >メソッド内でnotifyAllの代わりにnotifyを使っている</BugCode>
  <BugCode abbrev="DE" >例外を無視しているか見落としているか</BugCode>
  <BugCode abbrev="Ru" >メソッド内でrun()を直接読んでいる</BugCode>
  <BugCode abbrev="It" >Iteratorの定義がおかしい</BugCode>
  <BugCode abbrev="Se" >Serializableクラスの定義がおかしい</BugCode>
  <BugCode abbrev="WS" >Class's writeObject() method is synchronized but nothing else is</BugCode>
  <BugCode abbrev="RS" >Class's readObject() method is synchronized</BugCode>
  <BugCode abbrev="SC" >コンストラクタでThread.start()を読んでいる</BugCode>
  <BugCode abbrev="MS" >スタティックフィールドがmutable</BugCode>
  <BugCode abbrev="EI" >配列を返すメソッドは内部表現をさらす可能性がある</BugCode>
  <BugCode abbrev="Nm" >メソッド名が紛らわしい</BugCode>
  <BugCode abbrev="SS" >フィールドを読んでいない。staticにすべき</BugCode>
  <BugCode abbrev="UuF" >フィールドを使っていない</BugCode>
  <BugCode abbrev="UrF" >フィールドを（クラス側で）読んでいない</BugCode>
  <BugCode abbrev="UwF" >書き込みされないフィールド</BugCode>
  <BugCode abbrev="SIC" >staticな内部クラスではないか</BugCode>
  <BugCode abbrev="2LW" >二つのロックを持ったままwaitしている</BugCode>
  <BugCode abbrev="BcpDC">フィールドを二重にチェックしている疑い</BugCode>
  <BugCode abbrev="RV" >メソッドの戻り値が無視されている</BugCode>
  <BugCode abbrev="NP" >Null pointer dereference</BugCode>
  <BugCode abbrev="OS">ストリームが閉じられないパスがある</BugCode>
  <BugCode abbrev="PZLA" >Prefer zero length arrays to null to indicate no results</BugCode>
  <BugCode abbrev="UCF">Useless control flow</BugCode>
  <BugCode abbrev="RCN">Redundant comparison to null</BugCode>
  <BugCode abbrev="UL">Lock not released on all paths</BugCode>
  <BugCode abbrev="RC">Suspicious reference comparison</BugCode>
  <BugCode abbrev="MWN">Mismatched wait() or notify()</BugCode>
  <BugCode abbrev="SA">Useless self-assignment</BugCode>
  <BugCode abbrev="LI">Unsynchronized Lazy Initialization</BugCode>

</MessageCollection>
