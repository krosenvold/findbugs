<?xml version="1.0" encoding="Shift_JIS"?>
<!-- Using Shift_JIS encoding, because Eclipse 2.x doesn't display Japanese 
character correctly if it is using UTF-8 encoding. -->

<!--
  Note: as of FindBugs 0.7.4, translations of messages.xml
  do not need to duplicate untranslated messages.
  In other words, any messages that are omitted from this
  file will be taken from the default messages.xml file.
-->

<MessageCollection>

  <!--
  **********************************************************************
  Detectors
  **********************************************************************
   -->

  <!-- None of the detector descriptions are translated -->

  <!--
  **********************************************************************
  BugPatterns
  **********************************************************************
   -->

  <BugPattern type="DE_MIGHT_DROP">
    <ShortDescription>メソッドで例外を落としている可能性があります。</ShortDescription>
    <LongDescription>{1} は {3} を落としている可能性があります。</LongDescription>
    <Details>
<![CDATA[
  <p> This method might drop an exception.&nbsp; In general, exceptions
  should be handled or reported in some way, or they should be thrown
  out of the method.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DE_MIGHT_IGNORE">
    <ShortDescription>メソッドで例外を無視している可能性があります。</ShortDescription>
    <LongDescription>{1} は {3} を無視している可能性があります。</LongDescription>
    <Details>
<![CDATA[
  <p> This method might ignore an exception.&nbsp; In general, exceptions
  should be handled or reported in some way, or they should be thrown
  out of the method.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_CTOR">
    <ShortDescription>メソッドで いかがわしい new String(String) コンストラクタを呼び出しています。これは引数の文字列をそのまま使うべきです。</ShortDescription>
    <LongDescription>{1} new String(String) コンストラクタを呼び出しています。これは引数の文字列をそのまま使うべきです。</LongDescription>
    <Details>
<![CDATA[
  <p> Using the <code>java.lang.String(String)</code> constructor wastes memory
  because the object so constructed will be functionally indistinguishable
  from the <code>String</code> passed as a parameter.&nbsp; Just use the
  argument <code>String</code> directly.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_VOID_CTOR">
    <ShortDescription>メソッドで いかがわしい new String() コンストラクタを呼び出しています。これは  "" をそのまま使うべきです。</ShortDescription>
    <LongDescription>{1} new String() コンストラクタを呼び出しています。これは  "" をそのまま使うべきです。</LongDescription>
    <Details>
<![CDATA[
  <p> Creating a new <code>java.lang.String</code> object using the
  no-argument constructor wastes memory because the object so created will
  be functionally indistinguishable from the empty string constant
  <code>""</code>.&nbsp; Java guarantees that identical string constants
  will be represented by the same <code>String</code> object.&nbsp; Therefore,
  you should just use the empty string constant directly.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_GC">
    <ShortDescription>強制的にガベージコレクションを呼び出しています。ベンチマークのコード以外で記述されるのはきわめて疑わしいです。</ShortDescription>
    <LongDescription>{1} 強制的にガベージコレクションを呼び出しています。ベンチマークのコード以外で記述されるのはきわめて疑わしいです。</LongDescription>
    <Details>
<![CDATA[
  <p> Code explicitly invokes garbage collection.
  Except for specific use in benchmarking, this is very dubious.
  <p>In the past, situations where people have explicitly invoked 
  the garbage collector in routines such as close or finalize methods
  has led to huge performance black holes. Garbage collection 
	can be expensive. Any situation that forces hundreds or thousands
	of garbage collections will bring the machine to a crawl.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_BOOLEAN_CTOR">
    <ShortDescription>メソッドでBooleanのコンストラクタを呼んでいます。その代わりにBoolean.valueOf(...) を使うべきです。</ShortDescription>
    <LongDescription>{1} Booleanのコンストラクタを呼んでいます。その代わりにBoolean.valueOf(...) を使うべきです。</LongDescription>
    <Details>
<![CDATA[
  <p> Creating new instances of <code>java.lang.Boolean</code> wastes
  memory, since <code>Boolean</code> objects are immutable and there are
  only two useful values of this type.&nbsp; Use the <code>Boolean.valueOf()</code>
  method to create <code>Boolean</code> objects instead.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DC_DOUBLECHECK">
    <ShortDescription>フィールドのダブルチェックをおこなっている可能性があります。</ShortDescription>
    <LongDescription>{1} において {2} のダブルチェックをおこなっている可能性があります。</LongDescription>
    <Details>
<![CDATA[
  <p> This method may contain an instance of double-checked locking.&nbsp;
  This idiom is not correct according to the semantics of the Java memory
  model.&nbsp; For more information, see the web page
  <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html"
  >http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</a>.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="FI_PUBLIC_SHOULD_BE_PROTECTED">
    <ShortDescription>finalizerはprotectedであるべきです。publicであるべきではありません。</ShortDescription>
    <LongDescription>{1} は public ですが、これは protected であるべきです。</LongDescription>
    <Details>
<![CDATA[
  <p> A class's <code>finalize()</code> method should have protected access,
   not public.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_EMPTY">
    <ShortDescription>空の finalizer は削除されるべきです。</ShortDescription>
    <LongDescription>{1} は空ですので、削除されるべきです。</LongDescription>
    <Details>
<![CDATA[
  <p> Empty <code>finalize()</code> methods are useless, so they should
  be deleted.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_NULLIFY_SUPER">
    <ShortDescription>finalizerはスーパークラスの finalizer を無視しています。</ShortDescription>
    <LongDescription>{1} は {2}.finalize() を無視しています。これはわざとですか？</LongDescription>
    <Details>
<![CDATA[
  <p> This empty <code>finalize()</code> method explicitly negates the
  effect of any finalizer defined by its superclass.&nbsp; Any finalizer
  actions defined for the superclass will not be performed.&nbsp;
  Unless this is intended, delete this method.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_USELESS">
    <ShortDescription>finalizerは単にスーパークラスのfinalizerを呼び出しているに過ぎません。</ShortDescription>
    <LongDescription>{1} は単に super.finalize() を呼び出しているだけで、それ以外のことはなにもしていません。これは削除されるべきです。</LongDescription>
    <Details>
<![CDATA[
  <p> The only thing this <code>finalize()</code> method does is call
  the superclass's <code>finalize()</code> method, making it
  redundant.&nbsp; Delete it.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_MISSING_SUPER_CALL">
    <ShortDescription>finalizerにスーパークラスのfinalizerの呼び出しの記述がありません。</ShortDescription>
    <LongDescription>{1} は super.finalize() の呼び出しを忘れています。そのため {2}.finalize() は呼び出されることがありません。</LongDescription>
    <Details>
<![CDATA[
  <p> This <code>finalize()</code> method does not make a call to its
  superclass's <code>finalize()</code> method.&nbsp; So, any finalizer
  actions defined for the superclass will not be performed.&nbsp;
  Add a call to <code>super.finalize()</code>.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_EXPLICIT_INVOCATION">
    <ShortDescription>finalizer を強制的に呼び出しています。</ShortDescription>
    <LongDescription>{1} は強制的に {2} を呼び出しています。</LongDescription>
    <Details>
<![CDATA[
  <p> This method contains an explicit invocation of the <code>finalize()</code>
  method on an object.&nbsp; Because finalizer methods are supposed to be
  executed once, and only by the VM, this is a bad idea.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_SELF_USE_OBJECT">
    <ShortDescription>共変な equals() メソッドが宣言されていますが、Object.equals(Object) は継承のままです。</ShortDescription>
    <LongDescription>{0} は equals({0}) メソッドを宣言していますが、Object.equals(Object) をそのまま利用しています。</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a covariant version of the <code>equals()</code>
  method, but calls the normal <code>equals(Object)</code> method
  defined in the base <code>java.lang.Object</code> class.&nbsp;
  The class should probably define a non-covariant version of <code>equals()</code>.&nbsp;
  (I.e., a method with the signature <code>boolean equals(java.lang.Object)</code>.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_SELF_NO_OBJECT">
    <ShortDescription>共変な equals() メソッドを宣言しています。</ShortDescription>
    <LongDescription>{0} は equals({0}) メソッドを宣言していますが、 equals(Object) は宣言されていません。</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a covariant version of <code>equals()</code>.&nbsp;
  To correctly override the <code>equals()</code> method in
  <code>java.lang.Object</code>, the parameter of <code>equals()</code>
  must have type <code>java.lang.Object</code>.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_SELF_NO_OBJECT">
    <ShortDescription>共変な compareTo() メソッドが宣言されています。</ShortDescription>
    <LongDescription>{0} は comparesTo({0}) メソッドを宣言していますが、 comparesTo(Object) は宣言されていません。</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a covariant version of <code>compareTo()</code>.&nbsp;
  To correctly override the <code>compareTo()</code> method in the
  <code>Comparable</code> interface, the parameter of <code>compareTo()</code>
  must have type <code>java.lang.Object</code>.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_HASHCODE_USE_OBJECT_EQUALS">
    <ShortDescription>クラスで hashCode() を宣言していますが、 Object.equals() はそのまま使っています。</ShortDescription>
    <LongDescription>{0} は hashCode を宣言していますが、 Object.equals() はそのまま使っています。</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>hashCode()</code> method but inherits its
  <code>equals()</code> method from <code>java.lang.Object</code>
  (which defines equality by comparing object references).&nbsp; Although
  this will probably satisfy the contract that equal objects must have
  equal hashcodes, it is probably not what was intended by overriding
  the <code>hashCode()</code> method.&nbsp; (Overriding <code>hashCode()</code>
  implies that the object's identity is based on criteria more complicated
  than simple reference equality.)
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_HASHCODE_NO_EQUALS">
    <ShortDescription>クラスで hashCode() を宣言していますが、equals() は宣言されていません。</ShortDescription>
    <LongDescription>{0} は hashCode を宣言していますが、equals は宣言されていません。</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>hashCode()</code> method but not an
  <code>equals()</code> method.&nbsp; Therefore, the class may
  violate the invariant that equal objects must have equal hashcodes.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_EQUALS_USE_HASHCODE">
    <ShortDescription>クラスで equals() を宣言していますが、Object.hashCode() はそのまま使っています。</ShortDescription>
    <LongDescription>{0} で equals を宣言していますが、Object.hashCode() はそのまま使っています。</LongDescription>
    <Details>
<![CDATA[
  <p> This class overrides <code>equals(Object)</code>, but does not
  override <code>hashCode()</code>, and inherits the implementation of
  <code>hashCode()</code> from <code>java.lang.Object</code> (which returns
  the identity hash code, an arbitrary value assigned to the object
  by the VM).&nbsp; Therefore, the class is very likely to violate the
  invariant that equal objects must have equal hashcodes.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_EQUALS_NO_HASHCODE">
    <ShortDescription>クラスで equals() を宣言していますが hashCode() は宣言されていません。</ShortDescription>
    <LongDescription>{0} は equals を宣言していますが hashCode は宣言されていません。</LongDescription>
    <Details>
<![CDATA[
  <p> This class overrides <code>equals(Object)</code>, but does not
  override <code>hashCode()</code>.&nbsp; Therefore, the class may violate the
  invariant that equal objects must have equal hashcodes.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ABSTRACT_SELF">
    <ShortDescription>抽象クラスで共変な equals() メソッドを宣言しています。</ShortDescription>
    <LongDescription>抽象クラス {0} で equals({0}) メソッドを宣言しています。</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a covariant version of <code>equals()</code>.&nbsp;
  To correctly override the <code>equals()</code> method in
  <code>java.lang.Object</code>, the parameter of <code>equals()</code>
  must have type <code>java.lang.Object</code>.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="ES_COMPARING_STRINGS_WITH_EQ">
    <ShortDescription>文字列を == や != を用いて比較しています。</ShortDescription>
    <LongDescription>{1}の中で、文字列オブジェクトを == や != を使って比較しようとしています。</LongDescription>
    <Details>
<![CDATA[
  <p>This code compares <code>java.lang.String</code> objects for reference
equality using the == or != operators.
Unless both strings are either constants in a source file, or have been
interned using the <code>String.intern()</code> method, the same string
value may be represented by two different String objects. Considering
using the <code>equals</code> method instead.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="CO_ABSTRACT_SELF">
    <ShortDescription>抽象クラスで共変な compareTo() メソッドを宣言しています。</ShortDescription>
    <LongDescription>抽象クラス {0} で compareTo({0}) メソッドを宣言しています。</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a covariant version of <code>compareTo()</code>.&nbsp;
  To correctly override the <code>compareTo()</code> method in the
  <code>Comparable</code> interface, the parameter of <code>compareTo()</code>
  must have type <code>java.lang.Object</code>.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS2_INCONSISTENT_SYNC">
    <ShortDescription>同期化が考慮されていません。</ShortDescription>
    <LongDescription>{1} の同期化が考慮されていません。{2}% がロックされている時に。</LongDescription>
    <Details>
<![CDATA[
  <p> The fields of this class appear to be accessed inconsistently with respect
  to synchronization.&nbsp; This bug report indicates that the bug pattern detector
  judged that
  <ol>
  <li> The class contains a mix of locked and unlocked accesses,
  <li> At least one locked access was performed by one of the class's own methods, and
  <li> The number of unsynchronized field accesses (reads and writes) was no more than
       one third of all accesses, with writes being weighed twice as high as reads
  </ol>

  <p> A typical bug matching this bug pattern is forgetting to synchronize
  one of the methods in a class that is intended to be thread-safe.

  <p> You can select the nodes labeled "Unsynchronized access" to show the
  code locations where the detector believed that a field was accessed
  without synchronization.

  <p> Note that there are various sources of inaccuracy in this detector;
  for example, the detector cannot statically detect all situations in which
  a lock is held.&nbsp; Also, even when the detector is accurate in
  distinguishing locked vs. unlocked accesses, the code in question may still
  be correct.

  <p> This description refers to the "IS2" version of the pattern detector,
  which has more accurate ways of detecting locked vs. unlocked accesses
  than the older "IS" detector.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NN_NAKED_NOTIFY">
    <ShortDescription>メソッドの中に裸の notify があります。</ShortDescription>
    <LongDescription>{1} の中に裸の notify があります。</LongDescription>
    <Details>
<![CDATA[
  <p> A call to <code>notify()</code> or <code>notifyAll()</code>
  was made without any (apparent) accompanying
  modification to mutable object state.&nbsp; In general, calling a notify
  method on a monitor is done because some condition another thread is
  waiting for has become true.&nbsp; However, for the condition to be meaningful,
  it must involve a heap object that is visible to both threads.

  <p> This bug does not necessarily indicate an error, since the change to
  mutable object state may have taken place in a method which then called
  the method containing the notification.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_EXPOSE_REP">
    <ShortDescription>public static なメソッドで配列を戻り値として返すと、内部表現を暴露してしまう可能性があります。</ShortDescription>
    <LongDescription>public static な {1} メソッドで {2} を戻すことにより、内部表現を暴露してしまう可能性があります。</LongDescription>
    <Details>
<![CDATA[
  <p> A public static method returns a reference to
	an array that is part of the static state of the class. 
	Any code that calls this method can freely modify
	the underlying array.
	One fix is to return a copy of the array.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_REP">
    <ShortDescription>メソッドは配列の戻り値を返すことにより内部表現を暴露してしまう可能性があります。</ShortDescription>
    <LongDescription>{1} は {2} を戻すことにより内部表現を暴露してしまう可能性があります。</LongDescription>
    <Details>
<![CDATA[
  <p> Returning an array value stored in one of the object's fields
  exposes the internal representation of the object.&nbsp; For classes shared
  by other untrusted classes, this could potentially be a security issue.&nbsp;
  Returning a new copy of the array is better approach in many situations.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RU_INVOKE_RUN">
    <ShortDescription>スレッドの中で run を実行しています。(ほんとうは startを代わりに呼び出すべきではないのですか？)</ShortDescription>
    <LongDescription>{1} は明示的にスレッドの run を呼び出しています。(ほんとうは start を呼び出したいと思ったのではないですか？)</LongDescription>
    <Details>
<![CDATA[
  <p> This method explicitly invokes <code>run()</code> on an object.&nbsp;
  In general, classes implement the <code>Runnable</code> interface because
  they are going to have their <code>run()</code> method invoked in a new thread,
  in which case <code>Thread.start()</code> is the right method to call.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SP_SPIN_ON_FIELD">
    <ShortDescription>メソッドはフィールドのスピンロックを利用しています。</ShortDescription>
    <LongDescription>{2} を使って {1} でスピンロックを使っています。</LongDescription>
    <Details>
<![CDATA[
  <p> This method spins in a loop which reads a field.&nbsp; The compiler
  may legally hoist the read out of the loop, turning the code into an
  infinite loop.&nbsp; The class should be changed so it uses proper
  synchronization (including wait and notify calls).
]]>
    </Details>
  </BugPattern>
  <BugPattern type="2LW_TWO_LOCK_WAIT">
    <ShortDescription>２つのロックを持ったままwaitしています。</ShortDescription>
    <LongDescription>{1} で２つのロックを持ったままwait()しています。</LongDescription>
    <Details>
<![CDATA[
  <p> Waiting on a monitor while two locks are held may cause
  deadlock.&nbsp; This not necessarily a bug, but is worth examining
  closely.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UW_UNCOND_WAIT">
    <ShortDescription>メソッドのwaitに条件文がありません。</ShortDescription>
    <LongDescription>{1} のwaitに条件文がありません。</LongDescription>
    <Details>
<![CDATA[
  <p> This method contains a call to <code>java.lang.Object.wait()</code> which
  is not guarded by conditional control flow.&nbsp; If the condition that
  the method intends to wait for has already happened, the thread could
  wait indefinitely.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UR_UNINIT_READ">
    <ShortDescription>コンストラクタで初期化前のフィールドを読んでいます。</ShortDescription>
    <LongDescription>{2} を {1} で初期化前に値を読み込んでいます。</LongDescription>
    <Details>
<![CDATA[
  <p> This constructor reads a field which has not yet been assigned a value.&nbsp;
  This is often caused when the programmer mistakenly uses the field instead
  of one of the constructor's parameters.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UG_SYNC_SET_UNSYNC_GET">
    <ShortDescription>getメソッドは同期化(synchronized)されていませんが、setメソッド同期化されています。</ShortDescription>
    <LongDescription>{1} は同期化(synchronized)されていませんが、{2} は同期化されています。</LongDescription>
    <Details>
<![CDATA[
  <p> This class contains similarly-named get and set
  methods where the set method is synchronized and the get method is not.&nbsp;
  This may result in incorrect behavior at runtime, as callers of the get
  method will not necessarily see a consistent state for the object.&nbsp;
  The get method should be made synchronized.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IC_INIT_CIRCULARITY">
    <ShortDescription>初期化がループしています。</ShortDescription>
    <LongDescription>{0} と {1} の間で初期化がループしています。</LongDescription>
    <Details>
<![CDATA[
  <p> A circularity was detected in the static initializers of the two
  classes referenced by the bug instance.&nbsp; Many kinds of unexpected
  behavior may arise from such circularity.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IT_NO_SUCH_ELEMENT">
    <ShortDescription>iterator の next() メソッドが NoSuchElement 例外をthrowすることができません。</ShortDescription>
    <LongDescription>{1} は NoSuchElement 例外をthrowすることができません。</LongDescription>
    <Details>
<![CDATA[
  <p> This class implements the <code>java.util.Iterator</code> interface.&nbsp;
  However, its <code>next()</code> method is not capable of throwing
  <code>java.util.NoSuchElementException</code>.&nbsp; The <code>next()</code>
  method should be changed so it throws <code>NoSuchElementException</code>
  if is called when there are no more elements to return.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS_INCONSISTENT_SYNC">
    <ShortDescription>同期の取り方に統一感がありません。</ShortDescription>
    <LongDescription>{1} の同期の取り方に統一感がありません。{2}% の場合同期アクセスされています。</LongDescription>
    <Details>
<![CDATA[
  <p> The fields of this class appear to be accessed inconsistently with respect
  to synchronization.&nbsp; This bug report indicates that the bug pattern detector
  judged that
  <ol>
  <li> The class contains a mix of locked and unlocked accesses,
  <li> At least one locked access was performed by one of the class's own methods, and
  <li> The number of unsynchronized field accesses (reads and writes) was no more than
       one third of all accesses, with writes being weighed twice as high as reads
  </ol>

  <p> A typical bug matching this bug pattern is forgetting to synchronize
  one of the methods in a class that is intended to be thread-safe.

  <p> Note that there are various sources of inaccuracy in this detector;
  for example, the detector cannot statically detect all situations in which
  a lock is held.&nbsp; Also, even when the detector is accurate in
  distinguishing locked vs. unlocked accesses, the code in question may still
  be correct.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ML_SYNC_ON_UPDATED_FIELD">
    <ShortDescription>メソッドは更新されるフィールドを使って同期しています。</ShortDescription>
    <LongDescription>{1} は更新されるフィールド {2} を使って同期しています。</LongDescription>
    <Details>
<![CDATA[
  <p> This method synchronizes on an object 
	references from a mutable field.
	This is unlikely to have useful semantics, since different
threads may be synchronizing on different objects.
]]>  
    </Details>
  </BugPattern>
  <BugPattern type="MS_OOI_PKGPROTECT">
    <ShortDescription>フィールドはinterfaceから取り出してパッケージprotectedにすべきです。</ShortDescription>
    <LongDescription>{1} はinterfaceから取り出してパッケージprotectedにすべきです。</LongDescription>
    <Details>
<![CDATA[
<p>
 A final static field that is 
defined in an interface references a mutable
	object such as an array or hashtable.
	This mutable object could 
	be changed by malicious code or
        by accident from another package.
	So solve this, the field needs to be moved to a class
	and made package protected 
	to avoid
        this vulnerability.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_FINAL_PKGPROTECT">
    <ShortDescription>フィールドはfinal 且つ パッケージprotectedにすべきです。</ShortDescription>
    <LongDescription>{1} フィールドはfinal 且つ パッケージprotectedにすべきです。</LongDescription>
    <Details>
<![CDATA[
 <p>
	A mutable static field could be changed by malicious code or
        by accident from another package.
        The field could be made package protected and/or made final 
	to avoid
        this vulnerability.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_SHOULD_BE_FINAL">
    <ShortDescription>フィールドは final ではありませんが、finalに変更すべきです。</ShortDescription>
    <LongDescription>{1} はfinalではありませんがfinalに変更すべきです。</LongDescription>
    <Details>
<![CDATA[
	<p>
 A mutable static field could be changed by malicious code or
        by accident from another package.
        The field could be made final to avoid
        this vulnerability.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_PKGPROTECT">
    <ShortDescription>フィールドはパッケージ protected にすべきです。</ShortDescription>
    <LongDescription>{1} はパッケージ protected にすべきです。</LongDescription>
    <Details>
<![CDATA[
  <p> A mutable static field could be changed by malicious code or
	by accident.
	The field could be made package protected to avoid
	this vulnerability.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_HASHTABLE">
    <ShortDescription>フィールドは mutable なハッシュテーブルです。</ShortDescription>
    <LongDescription>{1} は mutable な Hashtable です。</LongDescription>
    <Details>
<![CDATA[
 <p>A final static field references an Hashtable
	and can be accessed by malicious code or
        by accident from another package.
	This code can freely modify the contents of the array.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_ARRAY">
    <ShortDescription>フィールドは mutable な配列です。</ShortDescription>
    <LongDescription>{1} は mutable な配列です。</LongDescription>
    <Details>
<![CDATA[
 A final static field references an array
	and can be accessed by malicious code or
        by accident from another package.
	This code can freely modify the contents of the array.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_CANNOT_BE_FINAL">
    <ShortDescription>フィールドは final ではないし、finalになることはできません。</ShortDescription>
    <LongDescription>{1} は finalではないし、また final になることはできません。</LongDescription>
    <Details>
<![CDATA[
  <p> 
 A mutable static field could be changed by malicious code or
        by accident from another package.
	Unfortunately, the way the field is used doesn't allow
	any easy fix to this problem.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_VERY_CONFUSING">
    <ShortDescription>メソッドの命名が大変まぎらわしいです。</ShortDescription>
    <LongDescription>{1} と {3} のメソッドは、とても混乱しがちです。</LongDescription>
    <Details>
<![CDATA[
  <p> The referenced methods have names that differ only by capitalization.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CONFUSING">
    <ShortDescription>メソッド名がまぎらわしいです。</ShortDescription>
    <LongDescription>{1} と {3} のメソッドは、混乱しがちです。</LongDescription>
    <Details>
<![CDATA[
  <p> The referenced methods have names that differ only by capitalization.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CONFUSING_METHOD_NAME">
    <ShortDescription>メソッド名がまぎらわしいです。</ShortDescription>
    <LongDescription>{1} のメソッド名はまぎらわしいです。</LongDescription>
    <Details>
<![CDATA[
  <p> This method has the same name as the superclass of the class it
  is defined in.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_LCASE_HASHCODE">
    <ShortDescription>クラスで hashcode() を宣言しています。これは hashCode() であるべきではありませんか？</ShortDescription>
    <LongDescription>クラス {0} で hashcode() を宣言しています。しかしこれは、 hashCode() であるべきではありませんか？</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a method called <code>hashcode()</code>.&nbsp; This method
  does not override the <code>hashCode()</code> method in <code>java.lang.Object</code>,
  which is probably what was intended.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_LCASE_TOSTRING">
    <ShortDescription>クラスで tostring() を宣言しています。これは toString() であるべきではありませんか？</ShortDescription>
    <LongDescription>クラス {0} で tostring() を宣言しています。これは toString() であるべきではありませんか？</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a method called <code>tostring()</code>.&nbsp; This method
  does not override the <code>toString()</code> method in <code>java.lang.Object</code>,
  which is probably what was intended.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RR_NOT_CHECKED">
    <ShortDescription>メソッドは InputStream.read() の戻り値を無視しています。</ShortDescription>
    <LongDescription>{1} は {2} の戻り値を無視しています。</LongDescription>
    <Details>
<![CDATA[
  <p> This method ignores the return value of one of the variants of
  <code>java.io.InputStream.read()</code> which can return multiple bytes.&nbsp;
  If the return value is not checked, the caller will not be able to correctly
  handle the case where fewer bytes were read than the caller requested.&nbsp;
  This is a particularly insidious kind of bug, because in many programs,
  reads from input streams usually do read the full amount of data requested,
  causing the program to fail only sporadically.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SERIALVERSIONID">
    <ShortDescription>クラスは 直列化可能(Serializable) です。しかし serialVersionUID を宣言していません。</ShortDescription>
    <LongDescription>{0} は 直列化可能(Serializable)です。serialVersionUID を宣言することを考慮してください。</LongDescription>
    <Details>
<![CDATA[
  <p> This class implements the <code>Serializable</code> interface, but does
  not define a <code>serialVersionUID</code> field.&nbsp; 
  A change as simple as adding a reference to a .class object 
	 will add synthetic fields to the class,
	which will unfortunately change the implicit
	serialVersionUID (e.g., adding a reference to <code>String.class</code>
	will generate a static field <code>class$java$lang$String</code>).
   Also, different source code to bytecode compilers may use different 
   naming conventions for synthetic variables generated for 
   references to class objects or inner classes.
   To ensure interoperability of Serializable across versions,
	consider adding an explicit serialVersionUID.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="WS_WRITEOBJECT_SYNC">
    <ShortDescription>クラスの writeObject() メソッドは同期化(synchronized)されています。しかし それ以外のメソッドは同期化されていません。</ShortDescription>
    <LongDescription>{0} の writeObject メソッドは同期化(synchronized)されています。しかし、それ以外のメソッドは同期化されていません。</LongDescription>
    <Details>
<![CDATA[
  <p> This class has a <code>writeObject()</code> method which is synchronized;
  however, no other method of the class is synchronized.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RS_READOBJECT_SYNC">
    <ShortDescription>クラスの readObject() メソッドは同期化(synchronized)されています。</ShortDescription>
    <LongDescription>{0} の readObject メソッドは同期化(synchronized)されています。</LongDescription>
    <Details>
<![CDATA[
  <p> This serializable class defines a <code>readObject()</code> which is
  synchronized.&nbsp; By definition, an object created by deserialization
  is only reachable by one thread, and thus there is no need for
  <code>readObject()</code> to be synchronized.&nbsp; If the <code>readObject()</code>
  method itself is causing the object to become visible to another thread,
  that is an example of very dubious coding style.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SE_NONSTATIC_SERIALVERSIONID">
    <ShortDescription>serialVersionUID が static ではありません。</ShortDescription>
    <LongDescription>{1} が static ではありません。</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>serialVersionUID</code> field that is not static.&nbsp;
  The field should be made static
	if it is intended to specify
	the version UID for purposes of serialization.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SE_NONFINAL_SERIALVERSIONID">
    <ShortDescription>serialVersionUID が final ではありません。</ShortDescription>
    <LongDescription>{1} が final ではありません。</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>serialVersionUID</code> field that is not final.&nbsp;
  The field should be made final 
	if it is intended to specify
	the version UID for purposes of serialization.
]]>
    </Details>
  </BugPattern>


  <BugPattern type="SE_NONLONG_SERIALVERSIONID">
    <ShortDescription>serialVersionUID が long ではありません。</ShortDescription>
    <LongDescription>{1} が long ではありません。</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>serialVersionUID</code> field that is not long.&nbsp;
  The field should be made long
	if it is intended to specify
	the version UID for purposes of serialization.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SE_BAD_FIELD">
    <ShortDescription>直列化可能(serializable)なクラスのインスタンスフィールドが、非transientで、非直列化可能(non-serializable)です。</ShortDescription>
    <LongDescription>クラス {0} が 非transientで非直列化可能(non-serializable)なインスタンスフィールド {1} を宣言しています。</LongDescription>
    <Details>
<![CDATA[
<p> This Serializable class defines a non-primitive instance field which is neither transient,
Serializable, or <code>java.lang.Object</code>, and does not appear to implement
the <code>Externalizable</code> interface or the
<code>readObject()</code> and <code>writeObject()</code> methods.&nbsp;
Objects of this class will not be deserialized correctly if a non-Serializable
object is stored in this field.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SC_START_IN_CTOR">
    <ShortDescription>コンストラクタが Thread.start() を実行しています。</ShortDescription>
    <LongDescription>{1} が {2} を実行しています。</LongDescription>
    <Details>
<![CDATA[
  <p> The constructor starts a thread. This is likely to be wrong if
	the class is ever extended/subclassed, since the thread will be started
	before the subclass constructor is started.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SS_SHOULD_BE_STATIC">
    <ShortDescription>読まれないフィールドがあります。このフィールドは static になるべきではないのですか？</ShortDescription>
    <LongDescription>読まれないフィールド {1} があります。このフィールドは static になるべきではないのですか？</LongDescription>
    <Details>
<![CDATA[
  <p> This class contains an instance final field which is never read.&nbsp;
  The fact that it is not read may indicate that the Java source to bytecode
  compiler has propagated its constant value.&nbsp; Consider making it
  static.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UUF_UNUSED_FIELD">
    <ShortDescription>利用されないフィールドがあります。</ShortDescription>
    <LongDescription>利用されないフィールド {1} があります。</LongDescription>
    <Details>
<![CDATA[
  <p> This field is never used.&nbsp; Consider removing it from the class.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="URF_UNREAD_FIELD">
    <ShortDescription>読まれないフィールドがあります。</ShortDescription>
    <LongDescription>読まれないフィールド {1} があります。</LongDescription>
    <Details>
<![CDATA[
  <p> This field is never read.&nbsp; Consider removing it from the class.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_UNWRITTEN_FIELD">
    <ShortDescription>書かれないフィールドがあります。</ShortDescription>
    <LongDescription>書かれないフィールド {1} があります。</LongDescription>
    <Details>
<![CDATA[
  <p> This field is never written.&nbsp; All reads of it will return the default
value. Check for errors (should it have been initialized?), or remove it if it is useless.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC">
    <ShortDescription>staticな内部クラスになるべきではないのですか？</ShortDescription>
    <LongDescription>{0} は staticな内部クラスになるべきではないのですか？</LongDescription>
    <Details>
<![CDATA[
  <p> This class is an inner class, but does not use its embedded reference
  to the object which created it.&nbsp; This reference makes the instances
  of the class larger, and may keep the reference to the creator object
  alive longer than necessary.&nbsp; If possible, the class should be
  made into a <em>static</EM> inner class.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="WA_NOT_IN_LOOP">
    <ShortDescription>メソッドで、waitがループの中にありません。</ShortDescription>
    <LongDescription>{1} の中でwaitがループの中にありません。</LongDescription>
    <Details>
<![CDATA[
  <p> This method contains a call to <code>java.lang.Object.wait()</code> 
  which is not in a loop.&nbsp; If the monitor is used for multiple conditions,
  the condition the caller intended to wait for might not be the one
  that actually occurred.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NO_NOTIFY_NOT_NOTIFYALL">
    <ShortDescription>メソッドで、notifyAll() ではなく notify() を使っています。</ShortDescription>
    <LongDescription>{1} において、notifyAll ではなく notify を使っています。</LongDescription>
    <Details>
<![CDATA[
  <p> This method calls <code>notify()</code> rather than <code>notifyAll()</code>.&nbsp;
  Java monitors are often used for multiple conditions.&nbsp; Calling <code>notify()</code>
  only wakes up one thread, meaning that the thread woken up might not be the
  one waiting for the condition that the caller just satisfied.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="BCPDC_DOUBLECHECK">
    <ShortDescription>フィールドのダブルチェックを行っている可能性があります。</ShortDescription>
    <LongDescription>{1} の {2} において フィールドのダブルチェックを行っている可能性があります。</LongDescription>
    <Details>
<![CDATA[
  <p> This is a double check found by the ByteCodePattern-based detector.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED">
    <ShortDescription>メソッドにおいて戻り値を無視しています。</ShortDescription>
    <LongDescription>{1} は {2} の戻り値を無視しています。</LongDescription>
    <Details>
<![CDATA[
   <p> The return value of this method should be checked.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_ALWAYS_NULL">
    <ShortDescription>メソッド内でnullポインタを参照外しをしています。</ShortDescription>
    <LongDescription>{1} の中でnullポインタを参照外しをしています。</LongDescription>
    <Details>
<![CDATA[
<p> A null pointer is dereferenced here.&nbsp; This will lead to a 
<code>NullPointerException</code> when the code is executed.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_ALWAYS_NULL_EXCEPTION">
    <ShortDescription>メソッドの例外経路において、nullポインタの参照外しをしています。</ShortDescription>
    <LongDescription>Null pointer dereference in {1} で例外経路の際にnullポインタの参照外しをしています。</LongDescription>
    <Details>
<![CDATA[
<p> A pointer which is null on an exception path is dereferenced here.&nbsp;
This will lead to a <code>NullPointerException</code> when the code is executed.&nbsp;
Note that because FindBugs currently does not prune infeasible exception paths,
this may be a false warning.
<p> Also note that FindBugs considers the default case of a switch statement to
be an exception path, since the default case is often infeasible.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_NULL_ON_SOME_PATH">
    <ShortDescription>メソッド内でnullポインタの参照外しをしている可能性があります。</ShortDescription>
    <LongDescription>{1} の中でnullポインタの参照外しをしている可能性があります。</LongDescription>
    <Details>
<![CDATA[
<p> A reference value dereferenced here might be null at runtime.&nbsp;
This may lead to a <code>NullPointerException</code> when the code is executed.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_NULL_ON_SOME_PATH_EXCEPTION">
    <ShortDescription>メソッド内の例外経路においてnullポインタの参照外しをしている可能性があります。</ShortDescription>
    <LongDescription>{1} の中でnullポインタの参照外しをしている可能性があります。</LongDescription>
    <Details>
<![CDATA[
<p> A reference value which is null on some exception control path is
dereferenced here.&nbsp; This may lead to a <code>NullPointerException</code>
when the code is executed.&nbsp;
Note that because FindBugs currently does not prune infeasible exception paths,
this may be a false warning.
<p> Also note that FindBugs considers the default case of a switch statement to
be an exception path, since the default case is often infeasible.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SI_INSTANCE_BEFORE_FINALS_ASSIGNED">
    <ShortDescription>クラスのstatic初期化子が全てのstatic finalフィールドが割り当てられる前にインスタンス生成をおこなっています。</ShortDescription>
    <LongDescription>{0} のstatic初期化子が全てのstatic fieldが割り当てられる前にインスタンス生成をおこなっています。</LongDescription>
    <Details>
<![CDATA[
<p> The class's static initializer creates an instance of the class
before all of the static final fields are assigned.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="OS_OPEN_STREAM">
    <ShortDescription>メソッドでストリームのクローズに失敗する可能性があります。</ShortDescription>
    <LongDescription>{1} でストリームのクローズに失敗する可能性があります。</LongDescription>
    <Details>
<![CDATA[
<p> The method creates an IO stream object, does not assign it to any
fields, pass it to other methods, or return it, and does not appear to close
the stream on all paths out of the method.&nbsp; This may result in
a file descriptor leak.&nbsp; It is generally a good
idea to use a <code>finally</code> block to ensure that streams are
closed.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="OS_OPEN_STREAM_EXCEPTION_PATH">
    <ShortDescription>メソッドで、例外が発生した際にストリームのクローズに失敗する可能性があります。</ShortDescription>
    <LongDescription>{1} で、例外が発生した際にストリームのクローズに失敗する可能性があります。</LongDescription>
    <Details>
<![CDATA[
<p> The method creates an IO stream object, does not assign it to any
fields, pass it to other methods, or return it, and does not appear to close
it on all possible exception paths out of the method.&nbsp;
This may result in a file descriptor leak.&nbsp; It is generally a good
idea to use a <code>finally</code> block to ensure that streams are
closed.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="PZLA_PREFER_ZERO_LENGTH_ARRAYS">
    <ShortDescription>戻り値としてnullよりむしろ長さ0の配列を返すことを検討すべきです。</ShortDescription>
    <LongDescription>{1} では戻り値としてnullよりもむしろ長さ0の配列を返すことを検討すべきではありませんか？</LongDescription>
    <Details>
<![CDATA[
<p> It is generally a better design to
return a length zero array rather than a null reference to indicate that there
are no results. This way, no explicit check for null is needed by clients of the method.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="UCF_USELESS_CONTROL_FLOW">
    <ShortDescription>メソッドで利用されない制御の流れがあります。</ShortDescription>
    <LongDescription>{1} に、利用されない制御の流れがあります。</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a useless control flow statement.&nbsp;
Often, this is caused by inadvertently using an empty statement as the
body of an <code>if</code> statement, e.g.:
<pre>
    if (argv.length == 1);
        System.out.println("Hello, " + argv[0]);
</pre>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RCN_REDUNDANT_COMPARISON_TO_NULL">
    <ShortDescription>nullに対する無駄な比較があります。</ShortDescription>
    <LongDescription>{1} に、nullに対する無駄な比較があります。</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a redundant comparison of a reference value
to null. Two types of redundant comparison are reported:
<ul>
<li> Both values compared are definitely null
<li> One value is definitely null and the other is definitely not null
</ul>
In either case, the result of the comparison will always be the same at
runtime.  This is likely to inidicate a logic error in the method.
Often, it means that the reference was dereferenced first, and then
tested for null; this can happen because a method was changed without
the programmer realizing that the dereferenced value could be null.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="UL_UNRELEASED_LOCK">
    <ShortDescription>メソッドで全ての経路においてロックが解放されません。</ShortDescription>
    <LongDescription>{1} で、全ての経路においてロックが解放されません。</LongDescription>
    <Details>
<![CDATA[
<p> This method acquires a JSR-166 (<code>java.util.concurrent</code>) lock,
but does not release it on all paths out of the method.  In general, the correct idiom
for using a JSR-166 lock is:
<pre>
    Lock l = ...;
    l.lock();
    try {
        // do something
    } finally {
        l.unlock();
    }
</pre>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="UL_UNRELEASED_LOCK_EXCEPTION_PATH">
    <ShortDescription>メソッドで全ての例外経路においてロックが解放されません。</ShortDescription>
    <LongDescription>{1} で、全ての例外経路においてロックが解放されません。</LongDescription>
    <Details>
<![CDATA[
<p> This method acquires a JSR-166 (<code>java.util.concurrent</code>) lock,
but does not release it on all exception paths out of the method.  In general, the correct idiom
for using a JSR-166 lock is:
<pre>
    Lock l = ...;
    l.lock();
    try {
        // do something
    } finally {
        l.unlock();
    }
</pre>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RC_REF_COMPARISON">
    <ShortDescription>疑わしい参照の比較です。</ShortDescription>
    <LongDescription>{1} で参照されている {3} の比較は疑わしいです。</LongDescription>
    <Details>
<![CDATA[
<p> This method compares two reference values using the == or != operator,
where the correct way to compare instances of this type is generally
with the equals() method.  Examples of classes which should generally
not be compared by reference are java.lang.Integer, java.lang.Float, etc.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="MWN_MISMATCHED_WAIT">
    <ShortDescription>組合せが間違った wait() があります。</ShortDescription>
    <LongDescription>{1} で、wait()の組合せが間違っています。</LongDescription>
    <Details>
<![CDATA[
<p> This method calls Object.wait() without obviously holding a lock
on the object.&nbsp;  Calling wait() without a lock held will result in
an <code>IllegalMonitorStateException</code> being thrown.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="MWN_MISMATCHED_NOTIFY">
    <ShortDescription>組合せが間違った notify() があります。</ShortDescription>
    <LongDescription>{1} で、組合せが間違った notify() があります。</LongDescription>
    <Details>
<![CDATA[
<p> This method calls Object.notify() or Object.notifyAll() without obviously holding a lock
on the object.&nbsp;  Calling notify() or notifyAll() without a lock held will result in
an <code>IllegalMonitorStateException</code> being thrown.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SA_LOCAL_SELF_ASSIGNMENT">
    <ShortDescription>ローカル変数の自己代入があります。</ShortDescription>
    <LongDescription>{1} で、ローカル変数の自己代入があります。</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a self assignment of a local variable; e.g.
<pre>
  public void foo() {
    int x = 3;
    x = x;
  }
</pre>
Such assignments are useless, and may indicate a logic error or typo.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SA_FIELD_SELF_ASSIGNMENT">
    <ShortDescription>フィールドの自己代入があります。</ShortDescription>
    <LongDescription>{1} で、{2} の自己代入をおこなっています。</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a self assignment of a field; e.g.
<pre>
  int x;
  public void foo() {
    x = x;
  }
</pre>
Such assignments are useless, and may indicate a logic error or typo.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="LI_LAZY_INIT_INSTANCE">
    <ShortDescription>インスタンスフィールドの不正な遅延初期化がおこなわれています。</ShortDescription>
    <LongDescription>{1} で {2} フィールドの不正な遅延初期化がおこなわれています。</LongDescription>
    <Details>
<![CDATA[
<p> This method contains an unsynchronized lazy initialization of a non-volatile field.
Because the compiler or processor may reorder instructions,
threads are not guaranteed to see a completely initialized object,
<em>if the method can be called by multiple threads</em>.
You can make the field volatile to correct the problem.
For more information, see the
<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java Memory Model web site</a>.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="LI_LAZY_INIT_STATIC">
    <ShortDescription>staticフィールドの不正な遅延初期化がおこなわれています。</ShortDescription>
    <LongDescription>{1} で {2} staticフィールドの不正な遅延初期化がおこなわれています。</LongDescription>
    <Details>
<![CDATA[
<p> This method contains an unsynchronized lazy initialization of a non-volatile static field.
Because the compiler or processor may reorder instructions,
threads are not guaranteed to see a completely initialized object,
<em>if the method can be called by multiple threads</em>.
You can make the field volatile to correct the problem.
For more information, see the
<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java Memory Model web site</a>.
]]>
    </Details>
  </BugPattern>

  <!--
  **********************************************************************
   BugCodes
  **********************************************************************
   -->

  <BugCode abbrev="FI" >ファイナライザの使用方法が間違っています。</BugCode>
  <BugCode abbrev="ES" >文字列の一致を == や != を使って比較しています</BugCode>
  <BugCode abbrev="ML" >更新されるフィールドで同期を取ろうとしています。(ミュータブルロック)</BugCode>
  <BugCode abbrev="UG" >同期化(synchronized)されていないgetメソッドで、同期化されているsetメソッドです。</BugCode>
  <BugCode abbrev="IC" >初期化がループしています。</BugCode>
  <BugCode abbrev="SI" >スタティック初期化処理が疑わしいです。</BugCode>
  <BugCode abbrev="IS" >同期の仕方に一貫性がありません。</BugCode>
  <BugCode abbrev="IS2" >同期の仕方に一貫性がありません。</BugCode>
  <BugCode abbrev="Eq" >共変なequals()です。</BugCode>
  <BugCode abbrev="Co" >共変なcompareTo()です。</BugCode>
  <BugCode abbrev="HE" >同じ(equal)オブジェクトは同じハッシュ値を持つべきです。</BugCode>
  <BugCode abbrev="Dm" >疑わしいメソッドを使っています。</BugCode>
  <BugCode abbrev="UR" >コンストラクタで初期化の前にフィールドの値を読んでいます。</BugCode>
  <BugCode abbrev="RR" >メソッドでInputStream.read()の戻り値を無視しています。</BugCode>
  <BugCode abbrev="NN" >メソッド内に裸のnotifyがあります。</BugCode>
  <BugCode abbrev="UW" >メソッド内に無条件のwaitがあります。</BugCode>
  <BugCode abbrev="SP" >メソッドでフィールドのスピンロックをしています。</BugCode>
  <BugCode abbrev="DC" >フィールドをダブルチェックしている可能性があります。</BugCode>
  <BugCode abbrev="Wa" >メソッド内のwaitがループ内にありません。</BugCode>
  <BugCode abbrev="No" >メソッド内で notifyAll() ではなく notify() を使っています。</BugCode>
  <BugCode abbrev="DE" >例外を見落としている、または無視しています。</BugCode>
  <BugCode abbrev="Ru" >メソッドで run() を直接実行しています。</BugCode>
  <BugCode abbrev="It" >iteratorの宣言が不正です。</BugCode>
  <BugCode abbrev="Se" >直列化(Serializable)クラスの宣言が不正です。</BugCode>
  <BugCode abbrev="WS" >クラスのwriteObject()メソッドは同期化(sunchronized)されていますが、それ以外のメソッドは適切に宣言されていません。</BugCode>
  <BugCode abbrev="RS" >クラスの readObject()メソッドが同期化(synchronized)されています。</BugCode>
  <BugCode abbrev="SC" >コンストラクタが Thread.start() を呼んでいます。</BugCode>
  <BugCode abbrev="MS" >スタティックフィールドがミュータブル(mutable)です。</BugCode>
  <BugCode abbrev="EI" >配列を返すメソッドは 内部表現を暴露してしまう可能性があります。</BugCode>
  <BugCode abbrev="Nm" >メソッド名がまぎらわしいです。</BugCode>
  <BugCode abbrev="SS" >読まれないフィールドがあります。これはスタティックになるべきではないのですか？</BugCode>
  <BugCode abbrev="UuF" >利用されていないフィールドがあります。</BugCode>
  <BugCode abbrev="UrF" >読まれないフィールドがあります。</BugCode>
  <BugCode abbrev="UwF" >書かれないフィールドがあります。</BugCode>
  <BugCode abbrev="SIC" >スタティックな内部クラスになるべきでは無いのですか？</BugCode>
  <BugCode abbrev="2LW" >２つのロックを持ったままwaitしています。</BugCode>
  <BugCode abbrev="BcpDC">フィールドのダブルチェックをしている可能性があります。</BugCode>
  <BugCode abbrev="RV" >メソッドのreturn値が無視されています。</BugCode>
  <BugCode abbrev="NP" >nullポインタを参照外ししています。</BugCode>
  <BugCode abbrev="OS">全てのパスにおいて、ストリームがクローズされていません。</BugCode>
  <BugCode abbrev="PZLA" >結果無しを指し示すためには、nullよりもむしろ0の長さの配列を利用した方が良いです。</BugCode>
  <BugCode abbrev="UCF">無駄な制御の流れがあります。</BugCode>
  <BugCode abbrev="RCN">nullに対する冗長な比較があります。</BugCode>
  <BugCode abbrev="UL">全ての経路においてロックが解放されていません。</BugCode>
  <BugCode abbrev="RC">疑わしい比較演算子の参照があります。</BugCode>
  <BugCode abbrev="MWN">wait() か notify()の組み合せが間違っています。</BugCode>
  <BugCode abbrev="SA">無駄な自己代入です。</BugCode>
  <BugCode abbrev="LI">同期化(synchronized)されていない遅延初期化です。</BugCode>

</MessageCollection>
