<html>
<head>
<title>FindBugs&trade; - Find Bugs in Java Programs</title>
<link rel="stylesheet" type="text/css" href="findbugs.css" />
@GOOGLE_ANALYTICS@
</head>

<body>

<table width="100%"><tr>

@HTML_SIDEBAR@

<td align="left" valign="top">

<p>
	<a href="@WEBSITE@/"><img src="buggy-sm.png" alt="FindBugs logo" border="0" /></a>
	<a href="http://www.umd.edu/"><img src="informal.png" alt="UMD logo" border="0" /></a>
</p>

<h1>FindBugs&trade; - Find Bugs in Java Programs</h1>

<p> This is the web page for FindBugs, a program which looks for bugs
in Java code.&nbsp; It is free software, distributed under the terms
of the <a href="http://www.gnu.org/licenses/lgpl.html">Lesser GNU Public License</a>.
The name FindBugs&trade; and the <a href="buggy-sm.png">Findbugs logo</a>
are trademarked by <a href="http://www.umd.edu">The University of Maryland</a>.</p>


<p><a href="http://www.fortifysoftware.com/#findbugs"><img src="Fortify.png" alt="Fortify logo" border="0"  align="right"/></a>FindBugs is sponsored by <a href="http://www.fortifysoftware.com/#findbugs">Fortify Software</a>, which 
sells security tools, including Fortify Source Code Analysis, 
which scans for security vulnerabilities (<a href="pressRelease.pdf">press release</a>).

</p><p> FindBugs requires JRE (or JDK) 1.4.0 or later to run.&nbsp; However, it
can analyze programs compiled for any version of Java. The current version of FindBugs is @VERSION@,
released on @RELEASE_DATE@.</p>

<p>  We are very interested in getting feedback on how to improve FindBugs.&nbsp;
Send your comments to <a href="mailto:findbugs@cs.umd.edu">findbugs@cs.umd.edu</a>.</p>

<h1>Sample output</h1>

<p>
	As an example of the kind of issues FindBugs can identify,
	<a href="demo.html">we provide our results</a> on the Sun's JDK 1.6.0-b51, Eclipse, Netbeans,
	Glassfish and JBoss. We present these results as a table showing the number of warnings
	we generate, an html report generated by FindBugs, and using a Java Webstart demo of FindBugs
	that loads the results of our analysis and the relevant source, so that you can view the source
	corresponding to each of our warnings and judge for yourself the accuracy of Findbugs.
	
</p>

<h1>Try FindBugs now on your project!</h1>
<p>
	Using Java Web Start you can try The GUI version of FindBugs now on your project.
	As long as you have a 1.4 or better JRE installed, you can run FindBugs now by clicking 
	<a href="http://findbugs.sourceforge.net/jnlp/findbugs.jnlp">here.</a>
</p>

<h1>News</h1>
	
<p>Changes since version 1.0.0:</p>

<ul>
						<li>
							Overall, the change from FindBugs 1.0.0 to FindBugs 1.1.0 has
							been a big change. We've done a lot of work in a lot of areas,
							and aren't even going to try to enumerate all the changes.
						</li>
						<li>
							We spent a lot of time reviewing the results generated by
							FindBugs for open source and commercial code bases, and made a
							number of changes, small and large, to minimize the number of
							false positives. Our primary focus for this was warnings reported
							as high and medium priority correctness warnings. Our internal
							evaluation is that we produce very few high/medium priority
							correctness warnings where the analysis is actually wrong, and
							that more than 75% of the high/medium priority correctness
							warnings correspond to real coding defects that need addressing
							in the source code. The remaining 25% are largely cases such as a
							branch or statement that if taken would lead to an error, but in
							fact is a dead branch or statement that can never be taken. Such
							coding is confusing and hard to maintain, so it should arguably
							be fixed, but it is unlikely to actually result in an error
							during execution. Thus, some might classify those warnings
							as false positives.

						</li>
						<li>
							We've substantially improved the analysis for errors that could
							result in null pointer dereferences. Overall, our experience has
							been that these changes have roughly doubled the number of null
							pointer errors we detect, without increasing the number of false
							positives (in fact, our false positive rate has gone down). The
							improvements are due to four factors:
							<ul>
								<li>
									By default, we now do some interprocedural   analysis to determine
									methods that unconditionally dereference their parameters.
								</li>
								<li>
									FindBugs also comes with a model of which JDK methods
									unconditionally dereference their parameters.
								</li>
								<li>
									We do limited tracking of fields, so that we can detect null
									values stored in fields that lead to exceptions.
								</li>
								<li>
									We implemented a new analysis technique to find guaranteed
									dereferences. Consider the following example:

									<code>
										<pre>public int f(Object x, boolean b) {
  int result = 0;
  if (x == null) result++;
  else result--;
  // at this point, we know x is null on a simple path
  if (b) {
    // at this point, x is only null on a complex path
    // we don't know if the path in which x is null and b is true is feasible
    return result + x.hashCode();
    }
  else {
    // at this point, x is only null on a complex path
    // we don't know if the path in which x is null and b is false is feasible
    return result - x.hashCode();
    }
</pre>
									</code>

									<p>
										FindBugs 1.0 used forward dataflow analysis to determine
										whether each value is definitely null, null on a simple path,
										possible null on a complex path, or definitely nonnull. Thus,
										at the statement where
										<code>
											result
										</code>
										is decremented, we know that
										<code>
											x
										</code>
										is definitely null, and at the point before
										<code>
											if (b)
										</code>
										, we know that
										<code>
											x
										</code>
										is null on a simple path. If
										<code>
											x
										</code>
										were to be dereferenced here, we would generate a warning,
										because if the else branch of the
										<code>
											if (x == null)
										</code>
										were ever taken, a null pointer exception would result.
									</p>

									<p>
										However, in both the then and else branches of the
										<code>
											if (b)
										</code>
										statement,
										<code>
											x
										</code>
										is only null on a complex path that may be infeasible. It
										might be that the program logic is such that if
										<code>
											x
										</code>
										is null, then
										<code>
											b
										</code>
										is never true, so generating a warning about the dereference
										in the then clause might be a false positive. We could try to
										analyze the program to determine whether it is possible for
										<code>
											x
										</code>
										to be null and
										<code>
											b
										</code>
										to be true, but that can be a hard analysis problem.
									</p>

									<p>
										However,
										<code>
											x
										</code>
										is dereferenced in both the then
										<em>and</em> else branches of the
										<code>
											if (b)
										</code>
										statement. So at the point immediately before
										<code>
											if (b)
										</code>
										, we know that
										<code>
											x
										</code>
										is null on a simple path
										<em>and</em> that
										<code>
											x
										</code>
										is guaranteed to be dereferenced on all paths from this point
										forward. FindBugs 1.1 performs a backwards data flow analysis
										to determine the values that are guaranteed to be
										dereferenced, and will generate a warning in this case.
									</p>
								</li>
							</ul>

						</li>
						<li>
							Preliminary support for detectors using the frameworks other than
							BCEL, such as the
							<a href="http://asm.objectweb.org/">ASM</a> bytecode framework.
							You may experiment with writing ASM-based detectors, but beware
							the API may still change (which could possibly also affect
							BCEL-based detectors). In general, we've started trying to move
							away from a deep dependence on BCEL, but that change is only
							partially complete. Probably best to just avoid this until we
							complete more work on this. This change is only visible to
							FindBugs plugin developers, and shouldn't be visible to FindBugs
							users.
						</li>
						<li>
							<p>
								Bug categories (CORRECTNESS, MT_CORRECTNESS, etc.) are no longer
								hard-coded, but rather defined in xml files associated with
								plugins, including the core plugin which defines the standard
								categories. Third-party plugins can define their own categories.
							</p>
						</li>
						<li>
							<p>
								Several bug patterns have been moved from CORRECTNESS and STYLE
								into a new category, BAD_PRACTICE.
								The English localization of STYLE has changed from "Style" to "Dodgy."
							</p>
							<p>
								In generally, we've worked very hard to limit CORRECTNESS bugs
								to be real programming errors and sins of commission. A number
								of bad design practices that result in overly fragile code, such
								as defining an equals method that doesn't accept null or
								defining class with a equals method that inherits hashCode from
								class Object.
							</p>
							<p>
								In general, our guidelines for deciding whether a bug should be
								classified as CORRECTNESS, BAD_PRACTICE or STYLE are:
							</p>
							<dl>
								<dt>
									CORRECTNESS
								</dt>
								<dd>
									A problem that we can recognize with high confidence and is an
									issue that we believe almost all developers would want to
									examine and address. We recommend that software teams review
									all high and medium priority warnings in their entire code
									base.
								</dd>
								<dt>
									BAD_PRACTICE
								</dt>
								<dd>
									A problem that we can recognize with high confidence and
									represents a clear violation of recommended and standard coding
									practice. We believe each software team should decide which bad
									practices identified by FindBugs it wants to prohibit in the
									team's coding standard, and take action to remedy violations of
									those coding standards.
								</dd>
								<dt>
									STYLE
								</dt>
								<dd>
									These are places where something strange or dodgy is going on,
									such as a dead store to a local variable. Typically, less than
									half of these represent actionable programming defects.
									Reviewing these warnings in any code under active development
									is probably a good idea, but reviewing all such warnings in
									your entire code base might be appropriate only in some
									situations. Individual or team programming styles can
									substantially influence the effectiveness of each of these
									warnings (e.g., you might have a coding practice or style in
									your group that confuses one of the detectors into generating a
									lot of STYLE warnings); you will likely want to selectively
									suppress or report the STYLE warnings that are effective for
									your group.
								</dd>
							</dl>
						</li>
						<li>
							Released a preliminary version of a new GUI (known internally as
							GUI2 -- not very creative, huh?)
						</li>
						<li>
							Provided standard ways to mark user designations of bug warnings
							(e.g., as NOT_A_BUG or SHOULD_FIX). The internal logic now
							records this, it is represented in the XML file, and GUI2 allows
							the designations to be applied (along with free-form user
							annotations about each warning). The user designations and
							annotations are not yet supported by the Eclipse plugin, but we
							clearly want to support it in Eclipse shortly.
						</li>
						<li>
							Added a check for a bad comparison with a signed byte with a
							value not in the range -128..127. For example:
							<code>
								<pre>boolean find200(byte b[]) {
  for(int i = 0; i < b.length; i++) if (b[i] == 200) return i;
  return -1;
}
</pre>
							</code>
						</li>
						<li>
							Added a checking for testing if a value is equal to Double.NaN
							(no value is equal to NaN, not even NaN).
						</li>
						<li>
							Added a check for using a class with an equals method but no
							hashCode method in a hashed data structure.
						</li>
						<li>
							Added check for uncallable method of an anonymous inner class.
							For example, in the following code, it is impossible to invoke
							the initalValue method (because the name is misspelled and as a
							result is doesn't override a method in ThreadLocal).
							<code>
								<pre>private static ThreadLocal serialNum = new ThreadLocal() {
         protected synchronized Object initalValue() {
             return new Integer(nextSerialNum++);
         }
     };
</pre>
							</code>
						</li>
						<li>
							Added check for a dead local store caused by a switch statement
							fallthrough
						</li>
						<li>
							Added check for computing the absolute value of a random 32 bit
							integer or of a hashcode. This is broken because
							<code>
								Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE
							</code>
							, and thus result of calling Math.abs, which is expected to be
							nonnegative, will in fact be negative one time out of 2
							<sup>
								32
							</sup>
							, which will invariably be the time your boss is demoing the
							software to your customers.

						</li>
						<li>More careful resolution of inherited methods and fields. 
						Some of the shortcuts we were taking in FindBugs 1.0.0 were leading
						to inaccurate results, and it was fairly easy to address this
						by making the analysis more accurate.
						</li>
						<li>Overall, analysis times are about 1.6 times longer in 
						FindBugs 1.1.0 than in FindBugs 1.0.0. This is because 
						we have enabled substantial additional analysis at the default
						effort level (the actual analysis engine is significantly faster
						than in FindBugs 1.0). On a recent AMD Athlon processor,
						analyzing JDK1.6.0 (about 1 million lines of code) requires
						about 15 minutes of wall clock time. 
						</li>
						<li>Provided class and script (printClass) to print classfile in the
						human readable format produced by BCEL</li>
						<li>Provided -findSource option to setBugDatabaseInfo</li>
					</ul>


<p> <a href="Changes.html">Older versions...</a></p>

<h1>Support</h1>

<p> This work has been supported by 
<a href="http://www.fortifysoftware.com/#findbugs">Fortify Software</a>, <a href="http://www.google.com">Google</a>,
<a href="http://www.sun.com">Sun Microsystems</a>, 
 <a href="http://www.nsf.gov">National Science Foundation</a> grants
ASC9720199 and CCR-0098162, and by a 2004 <a href="http://www-306.ibm.com/software/info/university/products/eclipse/eig-2004.html">IBM Eclipse Innovation award</a>.</p>
<p>Any opinions, findings and conclusions or recommendations expressed 
in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation (NSF).
@HTML_FOOTER@

</p></td></tr></table>

</body>
</html>
