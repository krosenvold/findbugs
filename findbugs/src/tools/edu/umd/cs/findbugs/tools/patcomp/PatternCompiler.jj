options {
    STATIC = false;
	LOOKAHEAD = 2;
	FORCE_LA_CHECK = true;
}

PARSER_BEGIN(PatternCompiler)

package edu.umd.cs.findbugs.tools.patcomp;

public class PatternCompiler {
	public static void main(String[] argv) throws Exception {
		PatternCompiler pc = new PatternCompiler(System.in);
		pc.unit();
	}
}

PARSER_END(PatternCompiler)

SKIP :
{
	" "
|	"\t"
|	"\n"
|	"\r"
}

MORE :
{
	"//" : IN_SINGLE_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
	<SINGLE_LINE_COMMENT: "\n"|"\r"|"\r\n"> : DEFAULT
}

<IN_SINGLE_LINE_COMMENT>
MORE :
{
	< ~[] >
}

TOKEN :
{
	// Section keywords
	<PRESCREEN: "prescreen">
|	<MATCH: "match">
|	<CHECK: "check">
|	<REPORT: "report">

	// Expression keywords
|	<WHERE: "where">

	// Identifiers
|	<ID: <IDSTART>(<IDCHAR>)*>

	// Syntax bits
|	<LBRACE: "{">
|	<RBRACE: "}">
|	<LPAREN: "(">
|	<RPAREN: ")">
|	<COMMA: ",">
|	<SEMICOLON: ";">
|	<COLON: ":">

	// Character classes
|	<#IDSTART: (["A"-"Z"]|["a"-"z"]|"_")>
|	<#IDCHAR: (["A"-"Z"]|["a"-"z"]|<DIGIT>|"_")>
|	<#DIGIT: ["0"-"9"]>
}

void unit() :
{ }
{
	opt_prescreen() match() opt_check() report()
}

void opt_prescreen() :
{ }
{
	<PRESCREEN> <LBRACE> <RBRACE>
	{ }
|	/* epsilon */
	{ }
}

void match() :
{ }
{
	<MATCH> <LBRACE> instruction_list() <RBRACE>
	{ }
}

void instruction_list() :
{ }
{
	instruction() instruction_list()
	{ }
|	/* epsilon */
	{ }
}

void instruction() :
{ }
{
	opt_label() <ID> arg_list() <SEMICOLON>
	{ }
}

void opt_label() :
{ }
{
	<ID> <COLON>
	{ }
|	/* epsilon */
	{ }
}

void arg_list() :
{ }
{
	<ID> [ arg_list_rest() ]
	{ }
|	/* epsilon */
	{ }
}

void arg_list_rest() :
{ }
{
	<COMMA> <ID> [ arg_list_rest() ]
	{ }
}

/*
void expression1() :
{ }
{
	expression2() [ expression1_rest() ]
	{ }
}

void expression2() :
{ }
{
	expression3() [ expression2_rest() ]
	{ }
}
*/

void opt_check() :
{ }
{
	<CHECK> <LBRACE> <RBRACE>
	{ }
|	/* epsilon */
	{ }
}

void report() :
{ }
{
	<REPORT> <LBRACE> <RBRACE>
	{ }
}

// vim:ts=4
