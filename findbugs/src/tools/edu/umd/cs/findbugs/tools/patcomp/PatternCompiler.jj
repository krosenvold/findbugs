/*
 * FindBugs - Find bugs in Java programs
 * Copyright (C) 2004 University of Maryland
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/*
 * This file should be processed with JavaCC (https://javacc.dev.java.net/).
 */

options {
    STATIC = false;
	LOOKAHEAD = 2;
	FORCE_LA_CHECK = true;
}

PARSER_BEGIN(PatternCompiler)

package edu.umd.cs.findbugs.tools.patcomp;

/**
 * A compiler to translate FindBugs Pattern (.fbp) files
 * into Java source files.  This provides a high level mechanism
 * for implementing new bug pattern detectors.
 *
 * @author David Hovemeyer
 */
public class PatternCompiler {
	public static void main(String[] argv) throws Exception {
		PatternCompiler pc = new PatternCompiler(System.in);
		pc.unit();
	}
}

PARSER_END(PatternCompiler)

SKIP :
{
	" "
|	"\t"
|	"\n"
|	"\r"
}

MORE :
{
	"//" : IN_SINGLE_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
	<SINGLE_LINE_COMMENT: "\n"|"\r"|"\r\n"> : DEFAULT
}

<IN_SINGLE_LINE_COMMENT>
MORE :
{
	< ~[] >
}

TOKEN :
{
	// Section keywords
	<PRESCREEN: "prescreen">
|	<MATCH: "match">
|	<CHECK: "check">
|	<REPORT: "report">

	// Expression keywords
|	<WHERE: "where">

	// Java keywords - needed to understand Java expressions
|	<VOID: "void">
|	<BOOLEAN: "boolean">
|	<BYTE: "byte">
|	<CHAR: "char">
|	<SHORT: "short">
|	<INT: "int">
|	<FLOAT: "float">
|	<LONG: "long">
|	<DOUBLE: "double">
|	<THIS: "this">
|	<SUPER: "super">
|	<CLASS: "class">
|	<INSTANCEOF: "instanceof">
|	<TRUE: "true">
|	<FALSE: "false">
|	<NULL: "null">
|	<NEW: "new">

	// Identifiers
|	<ID: <IDSTART>(<IDCHAR>)*>

	// Syntax bits
|	<LBRACE: "{">
|	<RBRACE: "}">
|	<LPAREN: "(">
|	<RPAREN: ")">
|	<LBRACKET: "[">
|	<RBRACKET: "]">
|	<DOT: ".">
|	<COMMA: ",">
|	<SEMICOLON: ";">
|	<COLON: ":">
|	<QUES: "?">
|	<OR: "||">
|	<AND: "&&">
|	<BITOR: "|">
|	<BITXOR: "^">
|	<BITAND: "&">
|	<EQ: "==">
|	<NEQ: "!=">
|	<LE: "<=">
|	<GE: ">=">
|	<LSHIFT: "<<">
|	<BRSHIFT: ">>>">
|	<RSHIFT: ">>">
|	<LT: "<">
|	<GT: ">">
|	<INC: "++">
|	<DEC: "--">
|	<PLUS: "+">
|	<MINUS: "-">
|	<TIMES: "*">
|	<DIV: "/">
|	<MOD: "%">
|	<COMPL: "~">
|	<NOT: "!">

	// Character classes
|	<#IDSTART: (["A"-"Z"]|["a"-"z"]|"_")>
|	<#IDCHAR: (["A"-"Z"]|["a"-"z"]|<DIGIT>|"_")>
|	<#DIGIT: ["0"-"9"]>
}

// Top level production.
void unit() :
{ }
{
	opt_prescreen() match() opt_check() report()
}

// The optional "prescreen" section specifies simple/fast checks
// done on the method to determine whether or not the method
// might contain an instance of the pattern.
void opt_prescreen() :
{ }
{
	[ <PRESCREEN> <LBRACE> <RBRACE> ]
}

// The required "match" section specifies a bytecode pattern
// to search for.
void match() :
{ }
{
	<MATCH> <LBRACE> instruction_list() <RBRACE>
}

// The optional "check" section performs tests on the code matched
// by the pattern in the "match" section to determine whether
// it is really an instance of the pattern.  These checks may make
// use of more extensive analysis such as computing lock sets.
void opt_check() :
{ }
{
	[ <CHECK> <LBRACE> <RBRACE> ]
}

// The required "report" section emits a bug warning based on the
// matched code.
void report() :
{ }
{
	<REPORT> <LBRACE> <RBRACE>
}

void instruction_list() :
{ }
{
	[ instruction() instruction_list() ]
}

void instruction() :
{ }
{
	opt_label() <ID> [ instruction_arg_list() ] [ <WHERE> <LPAREN> expression() <RPAREN> ] <SEMICOLON>
}

void opt_label() :
{ }
{
	[ <ID> <COLON> ]
}

void instruction_arg_list() :
{ }
{
	<ID> [ instruction_arg_list_rest() ]
}

void instruction_arg_list_rest() :
{ }
{
	<COMMA> <ID> [ instruction_arg_list_rest() ]
}

/*
 * Expression grammar.
 * This was adapted from the ANTLR grammar for Java 1.5
 * at http://www.thecortex.net/clover/generics/javaG.g,
 * which is in the public domain.
 *
 * Limitations:
 * - Generics are not allowed.
 * - Casts are not allowed.
 * - "new" expressions are not allowed.
 */

void expression() :
{ }
{
	logical_or_expression() [ <QUES> expression() <COLON> expression() ]
}

void logical_or_expression() :
{ }
{
	logical_and_expression() ( <OR> logical_and_expression() )*
}

void logical_and_expression() :
{ }
{
	inclusive_or_expression() ( <AND> inclusive_or_expression() )*
}

void inclusive_or_expression() :
{ }
{
	exclusive_or_expression() ( <BITOR> exclusive_or_expression() )*
}

void exclusive_or_expression() :
{ }
{
	and_expression() ( <BITXOR> and_expression() )*
}

void and_expression() :
{ }
{
	equality_expression() ( <BITAND> equality_expression() )*
}

void equality_expression() :
{ }
{
	relational_expression() ( (<NEQ>|<EQ>) relational_expression() )*
}

void relational_expression() :
{ }
{
	shift_expression() relational_expression_rest()
}

void relational_expression_rest() :
{ }
{
	<INSTANCEOF> type_spec()
|	( (<LT> | <GT> | <LE> | <GE>) shift_expression() )*
}

void shift_expression() :
{ }
{
	additive_expression() ( (<LSHIFT> | <RSHIFT> | <BRSHIFT>) additive_expression() )*
}

void additive_expression() :
{ }
{
	multiplicative_expression() ( (<PLUS> | <MINUS>) multiplicative_expression() )*
}

void multiplicative_expression() :
{ }
{
	unary_expression() ( (<TIMES>|<DIV>|<MOD>) unary_expression() )*
}

void unary_expression() :
{ }
{
	<INC> unary_expression()
|	<DEC> unary_expression()
|	<MINUS> unary_expression()
|	<PLUS> unary_expression()
|	<COMPL> unary_expression()
|	<NOT> unary_expression()
|	postfix_expression()
}

void postfix_expression() :
{ }
{
	primary_expression() ( postfix_expression_rest() )* ( (<INC>|<DEC>) )*
}

void postfix_expression_rest() :
{ }
{
	<DOT> <ID> [ <LPAREN> [ arg_list() ] <RPAREN> ]
|	<DOT> <THIS>
|	<DOT> <SUPER> [ postfix_super_rest() ]
|	<LBRACKET> expression() <RBRACKET>
}

void postfix_super_rest() :
{ }
{
	<LPAREN> [ arg_list() ] <RPAREN>
|	<DOT> <ID> [ <LPAREN> [ arg_list() ] <RPAREN> ]
}

void primary_expression() :
{ }
{
	ident_primary() [ <DOT> <CLASS> ]
|	<TRUE>
|	<FALSE>
|	<NULL>
|	<THIS>
|	<SUPER>
|	<LPAREN> expression() <RPAREN>
|	builtin_type() opt_array_spec() <DOT> <CLASS>
}

void ident_primary() :
{ }
{
	<ID> ( <DOT> <ID> )* [ <LPAREN> [ arg_list() ] <RPAREN> ] 
}

void type_spec() :
{ }
{
	class_type_spec()
|	builtin_type_spec()
}

void class_type_spec() :
{ }
{
	class_or_interface_type_name() opt_array_spec()
}

void class_or_interface_type_name() :
{ }
{
	<ID> ( <DOT> <ID> )*
}

void builtin_type_spec() :
{ }
{
	builtin_type() opt_array_spec()
}

void builtin_type() :
{ }
{
	<VOID> | <BOOLEAN> | <BYTE> | <CHAR> | <SHORT> | <INT> | <FLOAT> | <LONG> | <DOUBLE>
}

void opt_array_spec() :
{ }
{
	( <LBRACKET> <RBRACKET> )*
}

void arg_list() :
{ }
{
	expression() [ arg_list_rest() ]
}

void arg_list_rest() :
{ }
{
	<COMMA> expression() [ arg_list_rest() ]
}

// vim:ts=4
