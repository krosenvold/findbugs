M Se: BadSerial$NotFinal.serialVersionUID isn't final
L Se: BadSerial$NotLong.serialVersionUID isn't long
M Se: BadSerial$NotStatic.serialVersionUID isn't static
M IC: Initialization circularity between Bar and Foo
L DE: Blat.gimme(java.io.InputStream) might ignore java.io.IOException  At Blat.java:[line 79]
M Dm: Blat.other(Blat) invokes dubious Boolean constructor; use Boolean.valueOf(...) instead  At Blat.java:[line 40]
M Dm: Blat.getYoom() invokes dubious new String(String) constructor; just use the argument  At Blat.java:[line 69]
M Dm: Blat.badlock() invokes dubious new String() constructor; just use ""  At Blat.java:[line 54]
M FI: Blat.other(Blat) explicitly invokes Blat.finalize()  At Blat.java:[line 39]
M FI: Blat.finalize() is public; should be protected  At Blat.java:[lines 35-36]
L IS2: Inconsistent synchronization of Blat.yoom; locked 50% of time  Unsynchronized access at Blat.java:[line 70]
M It: Blat.next() can't throw NoSuchElement exception  At Blat.java:[line 89]
M ML: Blat.badlock() synchronizes on updated field Blat.lock  At Blat.java:[line 50]
M MS: public static Blat.getFoobar() may expose internal representation by returning Blat.foobar  At Blat.java:[line 96]
M NN: Naked notify in Blat.getYoom()  At Blat.java:[line 62]
M No: Using notify rather than notifyAll in Blat.getYoom()  At Blat.java:[line 62]
M RR: Blat.gimme(java.io.InputStream) ignores result of java.io.InputStream.read(byte[])  At Blat.java:[line 77]
M Ru: Blat.xxx() explicitly invokes run on a thread (did you mean to start it instead?)  At Blat.java:[line 22]
M SC: Blat.<init>() invokes Blat$Y.start()  At Blat.java:[line 17]
M Se: Blat.serialVersionUID isn't static
M SS: Unread field: Blat.yarg; should this field be static?
M UG: Blat.getYoom() is unsynchronized, Blat.setYoom(int) is synchronized
M UrF: Unread field: Blat.yarm
M UR: Uninitialized read of Blat.lock in Blat.<init>()  At Blat.java:[line 16]
M UW: Unconditional wait in Blat.getYoom()  At Blat.java:[line 66]
M Wa: Wait not in loop in Blat.getYoom()  At Blat.java:[line 66]
M FI: Blat$Bleem.finalize() is empty and should be deleted  At Blat.java:[line 29]
M SIC: Should Blat$Bleem be a _static_ inner class?
M DC: Possible doublecheck on Doublecheck.o in Doublecheck.t()  At Doublecheck.java:[lines 5-7]
M UCF: Useless control flow in EmptyIfStatement.main(String[])  At EmptyIfStatement.java:[line 3]
H Eq: Eq defines equals(Eq) method and uses Object.equals(Object)
H HE: Eq defines equals and uses Object.hashCode()
M SS: Unread field: F.FOOBAR; should this field be static?
M UrF: Unread field: F.thud
M UuF: Unused field: F.blat
L SIC: Should F$1 be a _static_ inner class?
L IS2: Inconsistent synchronization of Getter.x; locked 75% of time  Unsynchronized access at Getter.java:[line 4]
M UG: Getter.getX() is unsynchronized, Getter.setX(int) is synchronized
M HE: Hashcode defines hashCode and uses Object.equals()
L NP: Possible null pointer dereference in Infeasible.foo() on exception path  At Infeasible.java:[line 24]
M UrF: Unread field: IntHolder.value
H Dm: InvokeGC.bad() forces garbage collection; extremely dubious except in benchmarking code  At InvokeGC.java:[line 12]
H Dm: InvokeGC.finalize() forces garbage collection; extremely dubious except in benchmarking code  At InvokeGC.java:[line 8]
H Dm: InvokeGC.tricky() forces garbage collection; extremely dubious except in benchmarking code  At InvokeGC.java:[line 30]
M Nm: Confusing method name: MethodCapitalization.MethodCapitalization()  At MethodCapitalization.java:[line 4]
H Nm: Class MethodCapitalization defines hashcode(); should it be hashCode()?  At MethodCapitalization.java:[line 10]
H Nm: VERY confusing to have methods MethodCapitalization.hashcode() and java.lang.Object.hashCode()
L Nm: Confusing to have methods MethodCapitalization$Bar.getx() and ThreadSafe.getX()
H Nm: VERY confusing to have methods MethodCapitalization$Foo.getx() and MethodCapitalization.getX()
M MWN: Mismatched notify() in MismatchedWait.bar(Object,Object)  At MismatchedWait.java:[line 11]
M MWN: Mismatched notify() in MismatchedWait.bar(Object,Object)  At MismatchedWait.java:[line 12]
M MWN: Mismatched wait() in MismatchedWait.foo(Object,Object)  At MismatchedWait.java:[line 5]
M No: Using notify rather than notifyAll in MismatchedWait.bar(Object,Object)  At MismatchedWait.java:[line 11]
M UW: Unconditional wait in MismatchedWait.foo(Object,Object)  At MismatchedWait.java:[line 5]
M Wa: Wait not in loop in MismatchedWait.foo(Object,Object)  At MismatchedWait.java:[line 5]
H Nm: Class N2 defines hashcode(); should it be hashCode()?  At N2.java:[line 5]
H Nm: Class N2 defines tostring(); should it be toString()?  At N2.java:[line 4]
H Nm: VERY confusing to have methods N2.mincemeaT() and N1.mincemeat()
H NP: Null pointer dereference in NP.main(String[])  At NP.java:[line 11]
M UCF: Redundant comparison of reference values in NP.main(String[])  At NP.java:[line 14]
M UCF: Redundant comparison of reference values in NP.main(String[])  At NP.java:[line 19]
H NP: Null pointer dereference in NullDeref.main(String[])  At NullDeref.java:[line 15]
M UCF: Redundant comparison of reference values in NullDeref.main(String[])  At NullDeref.java:[line 10]
M UCF: Redundant comparison of reference values in NullDeref.main(String[])  At NullDeref.java:[line 13]
L DE: NullDeref2.possibleNullPointerInExceptionPath() might ignore java.lang.Exception  At NullDeref2.java:[line 21]
L NP: Null pointer dereference in NullDeref2.detectedNullPointerInExceptionPath() on exception path  At NullDeref2.java:[line 10]
M NP: Possible null pointer dereference in NullDeref2.possibleNullPointerInNormalPath()  At NullDeref2.java:[line 37]
L NP: Possible null pointer dereference in NullDeref2.possibleNullPointerInExceptionPath() on exception path  At NullDeref2.java:[line 24]
M UCF: Redundant comparison of reference values in NullDeref2.detectedNullPointerInExceptionPath()  At NullDeref2.java:[line 4]
M UCF: Redundant comparison of reference values in NullDeref2.possibleNullPointerInExceptionPath()  At NullDeref2.java:[line 17]
M UCF: Redundant comparison of reference values in NullDeref2.possibleNullPointerInNormalPath()  At NullDeref2.java:[line 30]
M NP: Possible null pointer dereference in NullDeref3.same1(int[],int[])  At NullDeref3.java:[line 14]
M NP: Possible null pointer dereference in NullDeref3.same2(Object,Object)  At NullDeref3.java:[line 20]
M NP: Possible null pointer dereference in NullDeref3.same3(Object,Object)  At NullDeref3.java:[line 28]
M UCF: Redundant comparison of reference values in NullDeref4.foo()  At NullDeref4.java:[line 7]
M No: Using notify rather than notifyAll in NullDeref5.foo()  At NullDeref5.java:[line 14]
H NP: Null pointer dereference in NullDeref6.bar(Object)  At NullDeref6.java:[line 29]
M UCF: Redundant comparison of reference values in NullDeref6.bar(Object)  At NullDeref6.java:[line 25]
M UCF: Redundant comparison of reference values in NullDeref6.bar(Object)  At NullDeref6.java:[line 31]
M UCF: Redundant comparison of reference values in NullDeref6.foo(Object)  At NullDeref6.java:[line 16]
M NP: Possible null pointer dereference in NullDeref7.bar(Object)  At NullDeref7.java:[line 19]
M NP: Possible null pointer dereference in NullDeref7.foo(Object)  At NullDeref7.java:[line 14]
L NP: Null pointer dereference in OpenStream.main(String[]) on exception path  At OpenStream.java:[line 12]
M Dm: Overloaded.foo(int) invokes dubious Boolean constructor; use Boolean.valueOf(...) instead  At Overloaded.java:[line 3]
M Dm: Overloaded.foo(String) invokes dubious Boolean constructor; use Boolean.valueOf(...) instead  At Overloaded.java:[line 7]
M Dm: Overloaded.foo(String,boolean) invokes dubious Boolean constructor; use Boolean.valueOf(...) instead  At Overloaded.java:[line 11]
L PZLA: Should PreferZeroLengthArrays.foo(int) return a zero length array rather than null?  At PreferZeroLengthArrays.java:[line 5]
M Dm: RV.main(String[]) invokes dubious new String(String) constructor; just use the argument  At RV.java:[line 3]
M RV: RV.f(java.security.MessageDigest,byte[]) ignores return value of java.security.MessageDigest.digest(byte[])  At RV.java:[line 10]
M RV: RV.main(String[]) ignores return value of RV.<init>()  At RV.java:[line 5]
M RV: RV.main(String[]) ignores return value of java.lang.String.trim()  At RV.java:[line 4]
L RV: RV.g(java.io.File) ignores return value of java.io.File.createNewFile()  At RV.java:[line 14]
M SA: Self assignment of local variable in SelfAssignment.foo()  At SelfAssignment.java:[line 4]
H Se: Class Ser defines non-transient non-serializable instance field IntHolder.holder  At unknown source line
H ES: Comparison of String objects using == or != in StringComparision.isOrigin()   At StringComparision.java:[line 9]
M ES: Comparison of String objects using == or != in StringComparision.searchFields(java.lang.reflect.Field[],String)   At StringComparision.java:[line 21]
M RC: Suspicious comparison of java.lang.Boolean references in StringComparision.compareBool(Boolean,Boolean)  At StringComparision.java:[line 15]
M IS2: Inconsistent synchronization of SynchronizationTest2.x; locked 85% of time  Unsynchronized access at SynchronizationTest2.java:[line 23]
L IS2: Inconsistent synchronization of SynchronizationTest3.x; locked 92% of time  Unsynchronized access at SynchronizationTest3.java:[line 23]
L IS2: Inconsistent synchronization of SynchronizationTest4.x; locked 92% of time  Unsynchronized access at SynchronizationTest4.java:[line 23]
M 2LW: wait() with two locks held in TwoLockWait.myMethod(Object,Object)  At TwoLockWait.java:[line 8]
M UW: Unconditional wait in TwoLockWait.myMethod(Object,Object)  At TwoLockWait.java:[line 8]
M Wa: Wait not in loop in TwoLockWait.myMethod(Object,Object)  At TwoLockWait.java:[line 8]
L Nm: Confusing to have methods java.lang.Object.hashCode() and N2.hashcode()
L Nm: Confusing to have methods java.lang.Thread.toString() and N2.tostring()
