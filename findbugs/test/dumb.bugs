M C HE: AbstractMissingHashCode$StillMissingHashCode inherits equals and uses Object.hashCode()
L C HE: AbstractMissingHashCode defines equals and uses Object.hashCode()
L S BC: Questionable cast from java.util.List to concrete class java.util.Vector in BadCast.swap(java.util.List)  At BadCast.java:[line 9]
M S BC: Questionable cast from Collection to abstract class java.util.Set in BadCast.d()  At BadCast.java:[line 30]
L S BC: Questionable cast from java.util.Map to concrete class java.util.Hashtable in BadCast.h()  At BadCast.java:[line 41]
M C BC: instanceof will always return false in BadCast.hx(), since a java.util.Hashtable can't be a java.util.Stack  At BadCast.java:[line 59]
M S BC: instanceof will always return true in BadCast.hx(), since all java.util.Hashtable are instances of java.util.Map  At BadCast.java:[line 61]
H C BC: Impossible cast from java.util.Hashtable to class java.util.Vector in BadCast.hx()  At BadCast.java:[line 63]
M S Nm: The method name BadConstructor.BadConstructor() doesn't start with an lower case letter  At BadConstructor.java:[lines 5-6]
H C Nm: Method BadConstructor.BadConstructor() was probably intended to be a constructor  At BadConstructor.java:[lines 5-6]
M C EC: BadEquals.main(String[]) invokes equals() on an array, which is equivalent to ==  At BadEquals.java:[line 8]
M C EC: BadEquals.main(String[]) invokes equals() on an array, which is equivalent to ==  At BadEquals.java:[line 10]
M C EC: BadEquals.main(String[]) invokes equals() on an array, which is equivalent to ==  At BadEquals.java:[line 12]
M C EC: BadEquals.main(String[]) invokes equals() on an array, which is equivalent to ==  At BadEquals.java:[line 14]
M C EC: BadEquals.main(String[]) invokes equals() on an array, which is equivalent to ==  At BadEquals.java:[line 16]
M C RE: Invalid syntax for regular expression in BadRegEx.f(String)  At BadRegEx.java:[line 7]
M C RE: Invalid syntax for regular expression in BadRegEx.g(String)  At BadRegEx.java:[line 10]
M C RE: Invalid syntax for regular expression in BadRegEx.h(String)  At BadRegEx.java:[line 13]
M C RE: Invalid syntax for regular expression in BadRegEx.x(String)  At BadRegEx.java:[line 17]
M C RE: Invalid syntax for regular expression in BadRegEx.y(String)  At BadRegEx.java:[line 20]
M C RE: Invalid syntax for regular expression in BadRegEx.z(String)  At BadRegEx.java:[line 23]
M C BRSA: Method BadResultSetAccessTest.test0(java.sql.ResultSet) attempts to access a result set field with index 0  At BadResultSetAccessTest.java:[line 16]
M C BRSA: Method BadResultSetAccessTest.test1(java.sql.ResultSet) attempts to access a result set field with index 0  At BadResultSetAccessTest.java:[line 22]
M C BRSA: Method BadResultSetAccessTest.test1(java.sql.ResultSet) attempts to access a result set field with index 0  At BadResultSetAccessTest.java:[line 24]
M C BRSA: Method BadResultSetAccessTest.test2(java.sql.ResultSet) attempts to access a result set field with index 0  At BadResultSetAccessTest.java:[line 28]
M C BRSA: Method BadResultSetAccessTest.test2(java.sql.ResultSet) attempts to access a result set field with index 0  At BadResultSetAccessTest.java:[line 30]
M C BRSA: Method BadResultSetAccessTest.test6(java.sql.ResultSet,boolean) attempts to access a result set field with index 0  At BadResultSetAccessTest.java:[line 54]
M C BRSA: Method BadResultSetAccessTest.test7(java.sql.PreparedStatement) attempts to access a result set field with index 0  At BadResultSetAccessTest.java:[line 58]
L S DLS: Dead store to local variable in method BadResultSetAccessTest.test5(java.sql.ResultSet)  At BadResultSetAccessTest.java:[line 46]
M S DLS: Dead store to local variable in method BadResultSetAccessTest.test5(java.sql.ResultSet)  At BadResultSetAccessTest.java:[line 47]
M S DLS: Dead store to local variable in method BadResultSetAccessTest.test5(java.sql.ResultSet)  At BadResultSetAccessTest.java:[line 48]
L S DLS: Dead store to local variable in method BadResultSetAccessTest.test5(java.sql.ResultSet)  At BadResultSetAccessTest.java:[line 49]
M S DLS: Dead store to local variable in method BadResultSetAccessTest.test5(java.sql.ResultSet)  At BadResultSetAccessTest.java:[line 50]
M S DLS: Dead store to local variable in method BadResultSetAccessTest.test6(java.sql.ResultSet,boolean)  At BadResultSetAccessTest.java:[line 54]
M C Se: BadSerial$NotFinal.serialVersionUID isn't final
L C Se: BadSerial$NotLong.serialVersionUID isn't long
M C Se: BadSerial$NotStatic.serialVersionUID isn't static
H C Nm: Class BadSpellingOfEquals defines equal(); should it be equals()?  At BadSpellingOfEquals.java:[line 4]
M C AM: Empty zip file entry created in BadZipFileCreator.main(String[])  At BadZipFileCreator.java:[line 11]
M C BOA: Class BadlyOverriddenAdapterTest$1 overrides a method BadlyOverriddenAdapterTest$1.windowClosing() implemented in super class Adapter wrongly  At BadlyOverriddenAdapterTest.java:[line 13]
M P FI: Blat$Bleem.finalize() is empty and should be deleted  At Blat.java:[line 36]
M P Dm: Blat.other(Blat) invokes dubious Boolean constructor; use Boolean.valueOf(...) instead  At Blat.java:[line 47]
M P Dm: Blat.badlock() invokes dubious new String() constructor; just use ""  At Blat.java:[line 61]
M P Dm: Blat.getYoom() invokes dubious new String(String) constructor; just use the argument  At Blat.java:[line 76]
M V FI: Blat.finalize() is public; should be protected  At Blat.java:[lines 42-43]
M C FI: Blat.other(Blat) explicitly invokes Blat.finalize()  At Blat.java:[line 46]
M M NN: Naked notify in Blat.getYoom()  At Blat.java:[line 69]
M V MS: public static Blat.getFoobar() may expose internal representation by returning Blat.foobar  At Blat.java:[line 103]
M M Ru: Blat.xxx() explicitly invokes run on a thread (did you mean to start it instead?)  At Blat.java:[line 29]
M M SP: Spinning on Blat.lock in Blat.spin()  At Blat.java:[line 91]
M M UW: Unconditional wait in Blat.getYoom()  At Blat.java:[line 73]
M C UR: Uninitialized read of Blat.lock in Blat.<init>()  At Blat.java:[line 22]
M C It: Blat.next() can't throw NoSuchElement exception  At Blat.java:[line 96]
M M ML: Blat.badlock() synchronizes on updated field Blat.lock  At Blat.java:[line 57]
M C RR: Blat.gimme(java.io.InputStream) ignores result of java.io.InputStream.read(byte[])  At Blat.java:[line 84]
M C Se: Blat.serialVersionUID isn't static
M M SC: Blat.<init>() invokes Blat$Y.start()  At Blat.java:[line 23]
M M Wa: Wait not in loop in Blat.getYoom()  At Blat.java:[line 73]
L M No: Using notify rather than notifyAll in Blat.getYoom()  At Blat.java:[line 69]
M C Dm: CallSystemExit.equals(Object) invokes System.exit(...), which shuts down the entire virtual machine  At CallSystemExit.java:[line 6]
M C HE: CallSystemExit defines equals and uses Object.hashCode()
M M UG: Blat.getYoom() is unsynchronized, Blat.setYoom(int) is synchronized  At Blat.java:[lines 67-77]
H S DLS: Dead store to local variable in method Circ2.<init>()  At CircularDepsTest.java:[line 30]
H S DLS: Dead store to local variable in method CircularDepsTest.test1()  At CircularDepsTest.java:[line 7]
H S DLS: Dead store to local variable in method CircularDepsTest.test1()  At CircularDepsTest.java:[line 8]
H S DLS: Dead store to local variable in method CircularDepsTest.test1()  At CircularDepsTest.java:[line 9]
M C CN: Class CloneIdiom1 implements Cloneable but does not define or use clone method
M C CN: clone method CloneIdiom3.clone() does not call super.clone()  At CloneIdiom3.java:[line 3]
L S DLS: Dead store to local variable in method CloseStream.writeFile(java.io.File,Object)  At CloseStream.java:[line 8]
M C EC: CompareArrays.cmpArrays(int[],int[]) invokes equals() on an array, which is equivalent to ==  At CompareArrays.java:[line 7]
M C EC: CompareArrays.cmpArrays(String[],String[]) invokes equals() on an array, which is equivalent to ==  At CompareArrays.java:[line 12]
L C ISC: Method CreateStaticObject.test() needlessly instantiates a class that only supplies static methods  At CreateStaticObject.java:[line 7]
M V EI2: DangerousStoreIntoField.h(int,String,String[]) may expose internal representation by storing an externally mutable object into DangerousStoreIntoField.z  At DangerousStoreIntoField.java:[line 17]
M V EI2: DangerousStoreIntoField.i(int,String,String[]) may expose internal representation by storing an externally mutable object into DangerousStoreIntoField.z  At DangerousStoreIntoField.java:[line 22]
M V EI2: DangerousStoreIntoField.j(java.util.Date) may expose internal representation by storing an externally mutable object into DangerousStoreIntoField.w  At DangerousStoreIntoField.java:[line 27]
L S NP: Load of known null value in DatabaseStreams.method()  At DatabaseStreams.java:[line 19]
M S DLS: Dead store to local variable in method DeadStore.main(String[])  At DeadStore.java:[line 6]
M C IP: A parameter to DeadStore.main(String[]) is dead upon entry but overwritten  At DeadStore.java:[line 9]
H S DLS: Dead store to local variable in method DeadStore.main(String[])  At DeadStore.java:[line 9]
L S DLS: Dead store to local variable in method DeadStore.finalLocalDNR(int)  At DeadStore.java:[line 15]
L S DLS: Dead store to local variable in method DeadStore.killedByStoreDNR(int)  At DeadStore.java:[line 37]
M S DLS: Dead store to local variable in method DeadStore.notReportedin086(Object)  At DeadStore.java:[line 49]
M C IP: A parameter to DeadStore.cachingFields(int,int,int,int,int) is dead upon entry but overwritten  At DeadStore.java:[line 56]
M S DLS: Dead store to local variable in method DeadStore.cachingFields(int,int,int,int,int)  At DeadStore.java:[line 56]
M C IP: A parameter to DeadStore.cachingFields(int,int,int,int,int) is dead upon entry but overwritten  At DeadStore.java:[line 57]
H S DLS: Dead store to local variable in method DeadStore.cachingFields(int,int,int,int,int)  At DeadStore.java:[line 57]
M C IP: A parameter to DeadStore.cachingFields(int,int,int,int,int) is dead upon entry but overwritten  At DeadStore.java:[line 58]
H S DLS: Dead store to local variable in method DeadStore.cachingFields(int,int,int,int,int)  At DeadStore.java:[line 58]
M C IP: A parameter to DeadStore.cachingFields(int,int,int,int,int) is dead upon entry but overwritten  At DeadStore.java:[line 59]
H S DLS: Dead store to local variable in method DeadStore.cachingFields(int,int,int,int,int)  At DeadStore.java:[line 59]
M P Dm: DemonstrateStringError.<clinit>() invokes dubious new String(String) constructor; just use the argument  At DemonstrateStringError.java:[line 12]
H C IMSE: Dubious catching of IllegalMonitorStateException in DontCatchIllegalMonitor.foo()  At DontCatchIllegalMonitor.java:[line 10]
M M Wa: Wait not in loop in DontCatchIllegalMonitor.foo()  At DontCatchIllegalMonitor.java:[line 8]
M M DC: Possible doublecheck on Doublecheck.o in Doublecheck.standardDoubleCheck()  At Doublecheck.java:[lines 11-13]
M M DC: Possible doublecheck on Doublecheck.ready in Doublecheck.getData()  At Doublecheck.java:[lines 80-82]
M C DMI: DumbMethodInvocations.f(String) invokes substring(0), which returns the original value  At DumbMethodInvocations.java:[line 6]
M C DMI: DumbMethodInvocations.hasNext() invokes DumbMethodInvocations.next()  At DumbMethodInvocations.java:[line 16]
M C It: DumbMethodInvocations.next() can't throw NoSuchElement exception  At DumbMethodInvocations.java:[line 20]
M P Dm: Method DumbMethods.getStringOfString(String) invokes toString() method on a String; just use the String  At DumbMethods.java:[line 6]
M C IP: A parameter to DuplicateBranches.doit3(int,int) is dead upon entry but overwritten  At DuplicateBranches.java:[line 56]
L S DB: Method DuplicateBranches.doit(boolean,int,int) uses the same code for two branches  At DuplicateBranches.java:[lines 9-10]
L S DB: Method DuplicateBranches.doit2(int,int) uses the same code for two branches  At DuplicateBranches.java:[lines 25-27]
L S DB: Method DuplicateBranches.doit2(int,int) uses the same code for two branches  At DuplicateBranches.java:[lines 31-33]
L S DB: Method DuplicateBranches.doit3(int,int) uses the same code for two branches  At DuplicateBranches.java:[lines 56-57]
L S DB: Method DuplicateBranches.doit3(int,int) uses the same code for two branches  At DuplicateBranches.java:[lines 60-61]
M C AM: Empty zip file entry created in EmptyEntry.testZip(java.util.zip.ZipOutputStream)  At EmptyEntry.java:[line 10]
M C AM: Empty jar file entry created in EmptyEntry.testJar(java.util.jar.JarOutputStream)  At EmptyEntry.java:[line 16]
M C UCF: Useless control flow in EmptyIfStatement.main(String[])  At EmptyIfStatement.java:[line 3]
L S PZLA: Should EncapsulationViolation.getExtensionValue() return a zero length array rather than null?  At EncapsulationViolation.java:[line 6]
L C Eq: Abstract Eq defines equals(Eq) method
L C ES: Comparison of String objects using == or != in EqStringTestIsBetter.test(String)   At EqStringTestIsBetter.java:[line 5]
H C EC: Call to equals() comparing different types in EqualsComparison.badEqualsComparision()  At EqualsComparison.java:[line 9]
M C EC: Call to equals() with null argument in EqualsComparison.isEqualToNull(String)  At EqualsComparison.java:[line 17]
M C EC: Call to equals() comparing different interface types in EqualsComparison.unrelatedInterfaceComparison(EqualsComparison$A,EqualsComparison$B)  At EqualsComparison.java:[line 22]
L S PZLA: Should Extension.getExtensionValue() return a zero length array rather than null?  At Extension.java:[line 151]
H C Se: ExternalizableTest is Externalizable but doesn't define a void constructor
M C Se: ExternalizableTest2$ExternalizableTest2a is Externalizable but doesn't define a void constructor
H C Se: ExternalizableTest2 is Externalizable but doesn't define a void constructor
M C Nm: Class FalseException is not derived from an Exception, even though it is named as such
L M No: Using notify rather than notifyAll in FaultyPublicSemaphore$1.run()  At FaultyPublicSemaphore.java:[line 23]
L M No: Using notify rather than notifyAll in FaultyPublicSemaphore$2.run()  At FaultyPublicSemaphore.java:[line 42]
L C DE: FaultyPublicSemaphore.main(String[]) might ignore java.lang.Exception  At FaultyPublicSemaphore.java:[line 62]
M M SC: FaultyPublicSemaphore.<init>() invokes FaultyPublicSemaphore.start()  At FaultyPublicSemaphore.java:[line 68]
L M No: Using notify rather than notifyAll in FaultyPublicSemaphore.add(String)  At FaultyPublicSemaphore.java:[line 77]
L M No: Using notify rather than notifyAll in FaultyPublicSemaphore.run()  At FaultyPublicSemaphore.java:[line 91]
M S PS: Class FaultyPublicSemaphore exposes synchronization and semaphores in its public interface.  At FaultyPublicSemaphore.java:[line 73]
L C HE: FieldsNotSetInConstructor defines hashCode and uses Object.equals()
M P FI: Finalize.finalize() is empty and should be deleted  At Finalize.java:[line 3]
M C RR: FindRRTest.main(String[]) ignores result of java.io.BufferedInputStream.read(byte[])  At FindRRTest.java:[line 17]
L S DLS: Dead store to local variable in method FloatMath.main(String[])  At FloatMath.java:[line 4]
M M UG: Getter.getX() is unsynchronized, Getter.setX(int) is synchronized  At Getter.java:[line 4]
L C Co: Abstract Hashcode defines compareTo(Hashcode) method
L C HE: Hashcode defines hashCode and uses Object.equals()
M C ICAST: Integer division result cast to double in IDiv.main(String[])  At IDiv.java:[line 6]
M C Nm: Class IgnoredException is not derived from an Exception, even though it is named as such
H C RV: IgnoredReturnValue.main(String[]) ignores return value of java.lang.String.trim()  At IgnoredReturnValue.java:[line 9]
H C RV: IgnoredReturnValue.main(String[]) ignores return value of java.lang.String.equals(Object)  At IgnoredReturnValue.java:[line 10]
H C RV: IgnoredReturnValue.main(String[]) ignores return value of java.util.concurrent.Semaphore.tryAcquire()  At IgnoredReturnValue.java:[line 12]
H C RV: IgnoredReturnValue.main(String[]) ignores return value of java.util.concurrent.Semaphore.tryAcquire(long,TimeUnit)  At IgnoredReturnValue.java:[line 13]
H C RV: IgnoredReturnValue.main(String[]) ignores return value of java.util.concurrent.BlockingQueue.offer(Object)  At IgnoredReturnValue.java:[line 15]
H C RV: IgnoredReturnValue.main(String[]) ignores return value of java.util.concurrent.BlockingQueue.offer(Object,long,TimeUnit)  At IgnoredReturnValue.java:[line 16]
H C RV: IgnoredReturnValue.main(String[]) ignores return value of java.util.concurrent.BlockingQueue.poll(long,TimeUnit)  At IgnoredReturnValue.java:[line 17]
H C RV: IgnoredReturnValue.main(String[]) ignores return value of java.util.concurrent.BlockingQueue.poll()  At IgnoredReturnValue.java:[line 18]
H C RV: IgnoredReturnValue.main(String[]) ignores return value of java.util.concurrent.locks.Condition.await(long,java.util.concurrent.TimeUnit)  At IgnoredReturnValue.java:[line 25]
H C RV: IgnoredReturnValue.main(String[]) ignores return value of java.util.concurrent.BlockingQueue.poll()  At IgnoredReturnValue.java:[line 30]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.foo()  At IncompatMaskTest.java:[line 8]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.foo()  At IncompatMaskTest.java:[line 9]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.foo()  At IncompatMaskTest.java:[line 10]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.foo()  At IncompatMaskTest.java:[line 11]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 30]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 31]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 32]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 33]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 34]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 35]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 37]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 38]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 39]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 40]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 41]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 42]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.moreBars(short)  At IncompatMaskTest.java:[line 46]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.moreBars(short)  At IncompatMaskTest.java:[line 50]
H C IL: There is an apparent infinite recursive loop in InfiniteRecursiveLoop.<init>(int,int).  At InfiniteRecursiveLoop.java:[line 7]
H C IL: There is an apparent infinite recursive loop in InfiniteRecursiveLoop.more().  At InfiniteRecursiveLoop.java:[line 11]
H C IL: There is an apparent infinite recursive loop in InfiniteRecursiveLoop.muchMore().  At InfiniteRecursiveLoop.java:[line 15]
H C IL: There is an apparent infinite recursive loop in InfiniteRecursiveLoop.equals(Object).  At InfiniteRecursiveLoop.java:[line 19]
H C IL: There is an apparent infinite recursive loop in InfiniteRecursiveLoop.hashCode().  At InfiniteRecursiveLoop.java:[line 24]
H S DLS: Dead store to local variable in method InfiniteRecursiveLoop.<init>(int,int)  At InfiniteRecursiveLoop.java:[line 7]
M C UI: Usage of GetResource in InheritanceUnsafeClass.getResource(String) may be unsafe if class is extended  At InheritanceUnsafeClass.java:[line 15]
H P Dm: InvokeGC.finalize() forces garbage collection; extremely dubious except in benchmarking code  At InvokeGC.java:[line 8]
H P Dm: InvokeGC.bad() forces garbage collection; extremely dubious except in benchmarking code  At InvokeGC.java:[line 12]
H P Dm: InvokeGC.tricky() forces garbage collection; extremely dubious except in benchmarking code  At InvokeGC.java:[line 30]
M C It: IteratorIdiomsTest.next() can't throw NoSuchElement exception  At IteratorIdiomsTest.java:[line 8]
H M Dm: Monitor wait() called on a Condition in JSR166.waitOnCondition(java.util.concurrent.locks.Condition)  At JSR166.java:[line 36]
H M Dm: Monitor wait() called on a Condition in JSR166.waitOnCondition(java.util.concurrent.locks.Condition)  At JSR166.java:[line 37]
H M Dm: Monitor wait() called on a Condition in JSR166.waitOnCondition(java.util.concurrent.locks.Condition)  At JSR166.java:[line 38]
M M Wa: Condition.await() not in loop in JSR166.awaitNotInLoop(java.util.concurrent.locks.Condition)  At JSR166.java:[line 43]
H M UL: JSR166.l() does not release lock on all paths  At JSR166.java:[line 8]
H M UL: JSR166.foo() does not release lock on all paths  At JSR166.java:[line 12]
M M UL: JSR166.increment() does not release lock on all exception paths  At JSR166.java:[line 19]
L S Nm: The method name LongNaming$B.Wait() doesn't start with an lower case letter  At LongNaming.java:[line 19]
M C MF: Class MaskMe$DerivedMaskMe defines field that obscures superclass field MaskMe.base_class_var
M S DLS: Dead store to local variable in method MaskMe.modify_base_class_var()  At MaskMe.java:[line 16]
L S Nm: The method name MethodCapitalization.MethodCapitalization() doesn't start with an lower case letter  At MethodCapitalization.java:[line 4]
M C Nm: Method MethodCapitalization.MethodCapitalization() was probably intended to be a constructor  At MethodCapitalization.java:[line 4]
H C Nm: Class MethodCapitalization defines hashcode(); should it be hashCode()?  At MethodCapitalization.java:[line 10]
M M UW: Unconditional wait in MismatchedWait.foo(Object,Object)  At MismatchedWait.java:[line 5]
M M Wa: Wait not in loop in MismatchedWait.foo(Object,Object)  At MismatchedWait.java:[line 5]
L M No: Using notify rather than notifyAll in MismatchedWait.bar(Object,Object)  At MismatchedWait.java:[line 11]
M C MWN: Mismatched wait() in MismatchedWait.foo(Object,Object)  At MismatchedWait.java:[line 5]
M C MWN: Mismatched notify() in MismatchedWait.bar(Object,Object)  At MismatchedWait.java:[line 11]
M C MWN: Mismatched notify() in MismatchedWait.bar(Object,Object)  At MismatchedWait.java:[line 12]
M C MWN: Mismatched wait() in MismatchedWait.doNotReportClassRef()  At MismatchedWait.java:[line 37]
H C Nm: Class N2 defines tostring(); should it be toString()?  At N2.java:[line 4]
H C Nm: Class N2 defines hashcode(); should it be hashCode()?  At N2.java:[line 5]
M S NP: Load of known null value in NP.main(String[])  At NP.java:[line 11]
H C NP: Null pointer dereference in NP.main(String[])  At NP.java:[line 11]
M C RCN: Redundant comparison to null in NP.main(String[])  At NP.java:[line 14]
L C RCN: Redundant comparison to null in NP.main(String[])  At NP.java:[line 19]
L S DB: Method NP.main(String[]) uses the same code for two branches  At NP.java:[line 11]
L S DB: Method NP.main(String[]) uses the same code for two branches  At NP.java:[line 15]
M C NP: Possible null pointer dereference in NP0.getHash(String,int)  At NP0.java:[line 9]
M M NN: Naked notify in NakedWait.makeReady()  At NakedWait.java:[line 9]
M M UW: Unconditional wait in NakedWait.waitForReady()  At NakedWait.java:[line 17]
L M No: Using notify rather than notifyAll in NakedWait.makeReady()  At NakedWait.java:[line 9]
H C RV: NeedsToCheckReturnValue.bar(NeedsReturnValueChecked) ignores return value of NeedsReturnValueChecked.foo()  At NeedsToCheckReturnValue.java:[line 6]
L P Dm: Method NewForGetClass.main(String[]) allocates an object, only to get the class object  At NewForGetClass.java:[line 8]
M S DLS: Dead store to local variable in method NewForGetClass.main(String[])  At NewForGetClass.java:[line 8]
L C ISC: Method NewForGetClass.main(String[]) needlessly instantiates a class that only supplies static methods  At NewForGetClass.java:[line 8]
L C FE: Test for floating point equality in NoNaNCompare.checkIt(double).  At NoNaNCompare.java:[line 7]
L C FE: Test for floating point equality in NoNaNCompare.checkIt(float).  At NoNaNCompare.java:[line 12]
M C NS: Questionable use of non-short-circuit logic in NonShortCircuit.ordered(int,int,int)  At NonShortCircuit.java:[line 12]
L C NS: Questionable use of non-short-circuit logic in NonShortCircuit.ordered(int,int,int)  At NonShortCircuit.java:[line 13]
L C NS: Questionable use of non-short-circuit logic in NonShortCircuit.nonEmpty(Object[])  At NonShortCircuit.java:[line 16]
M C NP: Possible null pointer dereference in NonShortCircuit.nonEmpty(Object[])  At NonShortCircuit.java:[line 16]
L M Dm: Method NoopThread.test1() creates a thread using the default empty run method  At NoopThread.java:[line 12]
L M Dm: Method NoopThread.test2() creates a thread using the default empty run method  At NoopThread.java:[line 18]
L M Dm: Method NoopThread.test3() creates a thread using the default empty run method  At NoopThread.java:[line 25]
L S NP: Load of known null value in NullDeref.main(String[])  At NullDeref.java:[line 11]
M S NP: Load of known null value in NullDeref.main(String[])  At NullDeref.java:[line 16]
H C NP: Null pointer dereference in NullDeref.main(String[])  At NullDeref.java:[line 16]
H C NP: Null pointer dereference in NullDeref.main(String[])  At NullDeref.java:[line 32]
M C RCN: Redundant comparison to null in NullDeref.main(String[])  At NullDeref.java:[line 11]
M C RCN: Redundant comparison to null in NullDeref.main(String[])  At NullDeref.java:[line 14]
M S DLS: Dead store to local variable in method NullDeref.main(String[])  At NullDeref.java:[line 6]
L S DLS: Dead store to local variable in method NullDeref.main(String[])  At NullDeref.java:[line 23]
L S DLS: Dead store to local variable in method NullDeref.main(String[])  At NullDeref.java:[line 32]
L S DLS: Dead store to local variable in method NullDeref.main(String[])  At NullDeref.java:[line 51]
L C ISC: Method NullDeref.main(String[]) needlessly instantiates a class that only supplies static methods  At NullDeref.java:[line 6]
M C NP: Possible null pointer dereference in NullDeref10.foo(Object)  At NullDeref10.java:[line 6]
M C NS: Questionable use of non-short-circuit logic in NullDeref11.foo(Object)  At NullDeref11.java:[line 4]
M C NP: Possible null pointer dereference in NullDeref11.foo(Object)  At NullDeref11.java:[line 4]
L S PZLA: Should NullDeref12.get() return a zero length array rather than null?  At NullDeref12.java:[line 11]
M S NP: Load of known null value in NullDeref2.detectedNullPointerInExceptionPath()  At NullDeref2.java:[line 11]
L C NP: Null pointer dereference in NullDeref2.detectedNullPointerInExceptionPath() on exception path  At NullDeref2.java:[line 11]
M C RCN: Redundant comparison to null in NullDeref2.detectedNullPointerInExceptionPath()  At NullDeref2.java:[line 5]
L C NP: Possible null pointer dereference in NullDeref2.possibleNullPointerInExceptionPath() on exception path  At NullDeref2.java:[line 25]
M C RCN: Redundant comparison to null in NullDeref2.possibleNullPointerInExceptionPath()  At NullDeref2.java:[line 18]
M C NP: Possible null pointer dereference in NullDeref2.possibleNullPointerInNormalPath()  At NullDeref2.java:[line 38]
M C RCN: Redundant comparison to null in NullDeref2.possibleNullPointerInNormalPath()  At NullDeref2.java:[line 31]
M S DLS: Dead store to local variable in method NullDeref2.detectedNullPointerInExceptionPath()  At NullDeref2.java:[line 8]
M C NP: Possible null pointer dereference in NullDeref3.same1(int[],int[])  At NullDeref3.java:[line 14]
M C NP: Possible null pointer dereference in NullDeref3.same2(Object,Object)  At NullDeref3.java:[line 20]
M C NP: Possible null pointer dereference in NullDeref3.same3(Object,Object)  At NullDeref3.java:[line 28]
L C RCN: Redundant comparison to null in NullDeref4.foo()  At NullDeref4.java:[line 7]
L M No: Using notify rather than notifyAll in NullDeref5.foo()  At NullDeref5.java:[line 14]
M S NP: Load of known null value in NullDeref6.bar(Object)  At NullDeref6.java:[line 29]
L C RCN: Redundant comparison to null in NullDeref6.foo(Object)  At NullDeref6.java:[line 16]
H C NP: Null pointer dereference in NullDeref6.bar(Object)  At NullDeref6.java:[line 29]
L C RCN: Redundant comparison to null in NullDeref6.bar(Object)  At NullDeref6.java:[line 25]
M C RCN: Redundant comparison to null in NullDeref6.bar(Object)  At NullDeref6.java:[line 31]
M S NP: Load of known null value in NullDeref7.bar(Object)  At NullDeref7.java:[line 18]
M C NP: Possible null pointer dereference in NullDeref7.bar(Object)  At NullDeref7.java:[line 19]
L S NP: Load of known null value in NullDeref8.foo(String)  At NullDeref8.java:[line 11]
M C OS: NullDeref8.foo(String) may fail to close stream  At NullDeref8.java:[line 8]
M C RCN: Redundant comparison to null in NullPointerLattice.f(Object,boolean)  At NullPointerLattice.java:[line 9]
M C ODR: OpenDatabase.openConnection() may fail to close database resource  At OpenDatabase.java:[line 5]
M S DLS: Dead store to local variable in method OpenDatabase.openConnection()  At OpenDatabase.java:[line 5]
M S DLS: Dead store to local variable in method OpenDatabase.openStatement(java.sql.Connection)  At OpenDatabase.java:[line 9]
L S NP: Load of known null value in OpenStream.main(String[])  At OpenStream.java:[line 22]
L C NP: Null pointer dereference in OpenStream.main(String[]) on exception path  At OpenStream.java:[line 14]
M C OS: OpenStream.wrappedStreamClosedDoNotReport() may fail to close stream  At OpenStream.java:[line 61]
M C OS: OverbroadCatch.foo(String) may fail to close stream  At OverbroadCatch.java:[line 6]
H S DLS: Dead store to local variable in method OverbroadCatch.foo(String)  At OverbroadCatch.java:[line 6]
M P Dm: Overloaded.foo(int) invokes dubious Boolean constructor; use Boolean.valueOf(...) instead  At Overloaded.java:[line 3]
M P Dm: Overloaded.foo(String) invokes dubious Boolean constructor; use Boolean.valueOf(...) instead  At Overloaded.java:[line 7]
M P Dm: Overloaded.foo(String,boolean) invokes dubious Boolean constructor; use Boolean.valueOf(...) instead  At Overloaded.java:[line 11]
L S PZLA: Should PreferZeroLengthArrays.foo(int) return a zero length array rather than null?  At PreferZeroLengthArrays.java:[line 5]
L S REC: Method RECTest.testFail() catches Exception, but Exception is not thrown in the try block and RuntimeException is not explicitly caught  At RECTest.java:[line 32]
L S REC: Method RECTest.testFail2() catches Exception, but Exception is not thrown in the try block and RuntimeException is not explicitly caught  At RECTest.java:[line 45]
L S REC: Method RECTest.testFail3() catches Exception, but Exception is not thrown in the try block and RuntimeException is not explicitly caught  At RECTest.java:[line 59]
L S REC: Method RECTest.testFail4() catches Exception, but Exception is not thrown in the try block and RuntimeException is not explicitly caught  At RECTest.java:[line 72]
L S REC: Method RECTest.testFail5() catches Exception, but Exception is not thrown in the try block and RuntimeException is not explicitly caught  At RECTest.java:[line 85]
M S REC: Method RECTest.testFail6() catches Exception, but Exception is not thrown in the try block and RuntimeException is not explicitly caught  At RECTest.java:[line 98]
L S RI: Class RI implements same interface as superclass.
M P Dm: RV.main(String[]) invokes dubious new String(String) constructor; just use the argument  At RV.java:[line 3]
H C RV: RV.main(String[]) ignores return value of java.lang.String.trim()  At RV.java:[line 5]
M C RV: RV.main(String[]) ignores return value of RV.<init>()  At RV.java:[line 6]
H C RV: RV.f(java.security.MessageDigest,byte[]) ignores return value of java.security.MessageDigest.digest(byte[])  At RV.java:[line 11]
H C RV: RV.f(java.security.MessageDigest,byte[]) ignores return value of java.lang.IllegalStateException.<init>(String)  At RV.java:[line 12]
L C RV: RV.g(java.io.File) ignores return value of java.io.File.createNewFile()  At RV.java:[line 16]
M M RS: ReadObject's readObject method is synchronized
L M WS: ReadObject's writeObject method is synchronized but nothing else is
M C DMI: ReallyDumb.next() invokes substring(0), which returns the original value  At ReallyDumb.java:[line 11]
M C DMI: ReallyDumb.hasNext() invokes ReallyDumb.next()  At ReallyDumb.java:[line 7]
M C It: ReallyDumb.next() can't throw NoSuchElement exception  At ReallyDumb.java:[line 11]
M C RCN: Redundant comparison to null in RedundantNullCheck.foo(String)  At RedundantNullCheck.java:[line 5]
L C RCN: Redundant comparison to null in RedundantNullCheck.foo(String)  At RedundantNullCheck.java:[line 8]
L C RCN: Redundant comparison to null in RedundantNullCheck.foo(String)  At RedundantNullCheck.java:[line 14]
M C RCN: Redundant comparison to null in RedundantNullCheck.foo(String)  At RedundantNullCheck.java:[line 19]
H C Dm: RunFinalizersOnExit.f() invokes runFinalizersOnExit, one of the most dangerous methods in the Java libraries.    At RunFinalizersOnExit.java:[line 5]
M P SBSC: Method SBConcatTest.doConcat1(String[]) concatenates strings using + in a loop  At SBConcatTest.java:[line 10]
M P SBSC: Method SBConcatTest.doConcat2(String[]) concatenates strings using + in a loop  At SBConcatTest.java:[line 22]
L S DLS: Dead store to local variable in method SBConcatTest.doConcat4DoNotReport(String[])  At SBConcatTest.java:[line 41]
M S SA: Self assignment of local variable in SelfAssignment.foo()  At SelfAssignment.java:[line 4]
H C Se: Serializable2$Inner is Serializable  but its superclass doesn't define an accessible void constructor
H S DLS: Dead store to local variable in method Serializable2.exampleOfSerializableAnonymousClass()  At Serializable2.java:[line 20]
L P Dm: Method SillyBoxedUsage.testBad1(int) allocates a boxed primitive just to call toString  At SillyBoxedUsage.java:[line 7]
L P Dm: Method SillyBoxedUsage.testBad2(float) allocates a boxed primitive just to call toString  At SillyBoxedUsage.java:[line 17]
L P Dm: Method SillyBoxedUsage.testBad3(double) allocates a boxed primitive just to call toString  At SillyBoxedUsage.java:[line 27]
M C RR: SkipBufferedInputStream.main(String[]) ignores result of java.io.BufferedInputStream.read(byte[])  At SkipBufferedInputStream.java:[line 12]
M C RR: SkipBufferedInputStream2.main(String[]) ignores result of java.io.BufferedInputStream.read(byte[])  At SkipBufferedInputStream2.java:[line 13]
M M SWL: SleepWithLock.sleepWithLock() calls Thread.sleep() with a lock held  At SleepWithLock.java:[line 9]
M M SP: Spinning on SpinWait.flag in SpinWait.waitForTrue()  At SpinWait.java:[line 5]
M M SP: Spinning on SpinWait.vflag in SpinWait.waitForVolatileTrue()  At SpinWait.java:[line 8]
M M SP: Spinning on SpinWait.foo in SpinWait.waitForNonNull()  At SpinWait.java:[line 14]
M M SP: Spinning on SpinWait.foo in SpinWait.waitForNonNullIndirect(int,SpinWait)  At SpinWait.java:[line 17]
M M SP: Spinning on SpinWait.bar in SpinWait.waitForNonNullIndirect(int,SpinWait)  At SpinWait.java:[line 18]
M M SP: Spinning on SpinWait.sflag in SpinWait.waitForStatic()  At SpinWait.java:[line 22]
H C ES: Comparison of String objects using == or != in StringComparision.isOrigin()   At StringComparision.java:[line 9]
M C RC: Suspicious comparison of java.lang.Boolean references in StringComparision.compareBool(Boolean,Boolean)  At StringComparision.java:[line 15]
L C ES: Comparison of String objects using == or != in StringComparision.compareTwo(String,String)   At StringComparision.java:[line 18]
L C ES: Comparison of String objects using == or != in StringComparision.searchFields(java.lang.reflect.Field[],String)   At StringComparision.java:[line 26]
M C ES: Comparison of String objects using == or != in StringEqualityTest.almostEmpty(String)   At StringEqualityTest.java:[line 4]
L C ES: Comparison of String objects using == or != in StringEqualsTest.test(String)   At StringEqualsTest.java:[line 5]
M C CN: Class SuperRI implements Cloneable but does not define or use clone method
L C SW: Call to swing method in Swing1.main(String[]) needs to be performed in Swing event thread  At Swing1.java:[line 15]
L C SW: Call to swing method in Swing1.main(String[]) needs to be performed in Swing event thread  At Swing1.java:[line 16]
L C SW: Call to swing method in Swing1.main(String[]) needs to be performed in Swing event thread  At Swing1.java:[line 17]
M S SF: Switch statement found in SwitchFallthrough.test1(int) where one case falls thru to the next case  At SwitchFallthrough.java:[lines 8-11]
M S SF: Switch statement found in SwitchFallthrough.test1(int) where one case falls thru to the next case  At SwitchFallthrough.java:[lines 11-13]
M S SF: Switch statement found in SwitchFallthrough.test1(int) where one case falls thru to the next case  At SwitchFallthrough.java:[lines 13-16]
M S SF: Switch statement found in SwitchFallthrough.test1(int) where one case falls thru to the next case  At SwitchFallthrough.java:[lines 16-20]
M S SF: Switch statement found in SwitchFallthrough.test2(int,int) where one case falls thru to the next case  At SwitchFallthrough.java:[lines 31-35]
L M No: Using notify rather than notifyAll in TestFalsePositiveMWN.set()  At TestFalsePositiveMWN.java:[line 9]
L S DLS: Dead store to local variable in method TestFloatEquality.main(String[])  At TestFloatEquality.java:[line 7]
L S DLS: Dead store to local variable in method TestFloatEquality.main(String[])  At TestFloatEquality.java:[line 8]
L C FE: Test for floating point equality in TestFloatEquality.main(String[]).  At TestFloatEquality.java:[line 18]
L C FE: Test for floating point equality in TestFloatEquality.main(String[]).  At TestFloatEquality.java:[line 31]
L C FE: Test for floating point equality in TestFloatEquality.main(String[]).  At TestFloatEquality.java:[line 52]
L C FE: Test for floating point equality in TestFloatEquality.main(String[]).  At TestFloatEquality.java:[line 65]
M C RR: TestReadandSkipReturnShouldBeChecked.test() ignores result of java.io.BufferedInputStream.read(byte[])  At TestReadandSkipReturnShouldBeChecked.java:[line 18]
H C RR: TestReadandSkipReturnShouldBeChecked.test() ignores result of java.io.BufferedInputStream.skip(long)  At TestReadandSkipReturnShouldBeChecked.java:[line 19]
M C RR: TestReadandSkipReturnShouldBeChecked.test() ignores result of java.io.BufferedInputStream.read(byte[])  At TestReadandSkipReturnShouldBeChecked.java:[line 20]
H C RV: TryLock.main(String[]) ignores return value of java.util.concurrent.locks.ReadWriteLock.readLock()  At TryLock.java:[line 10]
H C RV: TryLock.main(String[]) ignores return value of java.util.concurrent.locks.ReentrantLock.newCondition()  At TryLock.java:[line 12]
H C RV: TryLock.main(String[]) ignores return value of java.util.concurrent.locks.Lock.newCondition()  At TryLock.java:[line 13]
H C RV: TryLock.main(String[]) ignores return value of java.util.concurrent.locks.ReentrantLock.tryLock()  At TryLock.java:[line 14]
H C RV: TryLock.main(String[]) ignores return value of java.util.concurrent.locks.Lock.tryLock()  At TryLock.java:[line 15]
H C RV: TryLock.main(String[]) ignores return value of java.util.concurrent.locks.Lock.tryLock()  At TryLock.java:[line 16]
M M JLM: Synchronization performed on java.util.concurrent Lock in method TryLock.main(String[])  At TryLock.java:[line 18]
M M TLW: wait() with two locks held in TwoLockWait.myMethod(Object,Object)  At TwoLockWait.java:[line 8]
M M UW: Unconditional wait in TwoLockWait.myMethod(Object,Object)  At TwoLockWait.java:[line 8]
M M Wa: Wait not in loop in TwoLockWait.myMethod(Object,Object)  At TwoLockWait.java:[line 8]
M M UW: Unconditional wait in TwoLocksWhileWaitingFalsePositive.clueless()  At TwoLocksWhileWaitingFalsePositive.java:[line 8]
M M Wa: Wait not in loop in TwoLocksWhileWaitingFalsePositive.clueless()  At TwoLocksWhileWaitingFalsePositive.java:[line 8]
L C OS: TwoStreams.twoStreamsWrong() may fail to close stream on exception  At TwoStreams.java:[line 12]
M P UPM: Private method UncalledPrivateMethod.foobar(int) is never called  At UncalledPrivateMethod.java:[line 20]
L P UPM: Private method UncalledPrivateMethod.foo(String) is never called  At UncalledPrivateMethod.java:[lines 11-12]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 9]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 10]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 11]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 12]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 13]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 14]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 15]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 16]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 17]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 18]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 19]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 20]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 21]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 22]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 23]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 24]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 25]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 26]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 27]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 30]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 31]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 32]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 33]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 34]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 35]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 36]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 37]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 38]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 39]
L S UM: Method calls static Math class method on a constant value  At UnnecessaryMathTest.java:[line 40]
L C SIO: Method UnneededInstanceOf.test1(java.util.ArrayList) does an unnecessary type check using instanceof operator when it can be determined statically  At UnneededInstanceOf.java:[line 9]
L C SIO: Method UnneededInstanceOf.test2(java.io.BufferedOutputStream) does an unnecessary type check using instanceof operator when it can be determined statically  At UnneededInstanceOf.java:[line 15]
L C SIO: Method UnneededInstanceOf.test3(java.util.SortedSet) does an unnecessary type check using instanceof operator when it can be determined statically  At UnneededInstanceOf.java:[line 21]
M S BC: instanceof will always return true in UnneededInstanceOf.test1(java.util.ArrayList), since all java.util.ArrayList are instances of java.util.List  At UnneededInstanceOf.java:[line 9]
M S BC: instanceof will always return true in UnneededInstanceOf.test2(java.io.BufferedOutputStream), since all java.io.BufferedOutputStream are instances of java.io.OutputStream  At UnneededInstanceOf.java:[line 15]
M S BC: instanceof will always return true in UnneededInstanceOf.test3(java.util.SortedSet), since all java.util.SortedSet are instances of java.util.Set  At UnneededInstanceOf.java:[line 21]
M C SA: Self assignment of field UselessAssignments.foo in UselessAssignments.<init>(int,int)  At UselessAssignments.java:[line 6]
M C UR: Uninitialized read of UselessAssignments.foo in UselessAssignments.<init>(int,int)  At UselessAssignments.java:[line 6]
M S SA: Self assignment of local variable in UselessAssignments.<init>(int,int)  At UselessAssignments.java:[line 7]
L S DLS: Dead store to local variable in method UselessAssignments.<init>(int,int)  At UselessAssignments.java:[line 7]
L C STI: Method UselessCurrentThread.run() makes an unneeded call to currentThread() just to call interrupted()  At UselessCurrentThread.java:[line 21]
L C STI: Method UselessCurrentThread.run() makes an unneeded call to currentThread() just to call interrupted()  At UselessCurrentThread.java:[line 27]
M C STI: Method UselessCurrentThread.run() makes a call to the static Thread.interrupted() method, mistakenly attempting to call it on an arbitrary Thread object  At UselessCurrentThread.java:[line 32]
M P FI: UselessFinalize.finalize() does nothing except call super.finalize(); delete it  At UselessFinalize.java:[lines 4-5]
M C NP: Possible null pointer dereference in UserAss3rtion.f(Object)  At UserAss3rtion.java:[line 8]
M P WMI: Method WMITest.test(java.util.Map) makes inefficient use of keySet iterator instead of entrySet iterator  At WMITest.java:[line 12]
M P WMI: Method WMITest.test2(int,int,int,int,java.util.Map) makes inefficient use of keySet iterator instead of entrySet iterator  At WMITest.java:[line 23]
M P WMI: Method WMITest.test3(java.util.Map) makes inefficient use of keySet iterator instead of entrySet iterator  At WMITest.java:[line 35]
M P WMI: Method WMITest.test4(java.util.Map) makes inefficient use of keySet iterator instead of entrySet iterator  At WMITest.java:[line 46]
L M VO: VolatileUsage.e is a volatile reference to an array; the array elements are non-volatile.
L M VO: VolatileUsage2.f is a volatile reference to an array; the array elements are non-volatile.
L M VO: VolatileUsage.d is a volatile reference to an array; the array elements are non-volatile.
L M VO: VolatileUsage2.d is a volatile reference to an array; the array elements are non-volatile.
M M VO: VolatileUsage2.a is a volatile reference to an array; the array elements are non-volatile.
L M VO: VolatileUsage.f is a volatile reference to an array; the array elements are non-volatile.
M M VO: VolatileUsage.a is a volatile reference to an array; the array elements are non-volatile.
M C IC: Initialization circularity between Bar and Foo
M V MS: FaultyPublicSemaphore.objectId should be package protected
M V MS: MutableStatic.h should be package protected
M V MS: MutableStatic.data should be package protected
M V MS: MutableStatic.data2 should be both final and package protected
H V MS: MutableStatic.p isn't final but should be
H V MS: RECTest.anException isn't final but should be
H C Nm: VERY confusing to have methods MethodCapitalization$Foo.getx() and MethodCapitalization.getX()
L C Nm: Confusing to have methods java.awt.Component.getX() and MethodCapitalization$Bar.getx()
H C Nm: VERY confusing to have methods LongNaming$B.methodG() and LongNaming$A.methodg()
H C Nm: VERY confusing to have methods LongNaming$B.methodF() and LongNaming.methodf()
H C Nm: VERY confusing to have methods N2.mincemeaT() and N1.mincemeat()
H C Nm: VERY confusing to have methods LongNaming$B.Wait() and java.lang.Object.wait()
L S UwF: Field not initialized in constructor: FieldsNotSetInConstructor.e
M C NP: Read of unwritten field in FieldsNotSetInConstructor.hashCode()  At FieldsNotSetInConstructor.java:[line 15]
H C UwF: Unwritten field: FieldsNotSetInConstructor.c
M C UwF: Unwritten field: FieldsNotSetInConstructor.d
M C UwF: Unwritten field: NullDeref5.lock
L C UwF: Unwritten field: SleepWithLock.ready
M C UwF: Unwritten field: SpinWait.bar
L C UwF: Unwritten field: SpinWait.flag
M C UwF: Unwritten field: SpinWait.foo
L C UwF: Unwritten field: SpinWait.sflag
L C UwF: Unwritten field: SpinWait.vflag
L C UwF: Unwritten field: StringComparision.y
M P SS: Unread field: Blat.yarg; should this field be static?
M P SIC: Should Blat$Bleem be a _static_ inner class?
M P UrF: Unread field: CreateBeforeInitialization.foo
M P UrF: Unread field: DangerousStoreIntoField.w
M P UrF: Unread field: DangerousStoreIntoField.z
M P SS: Unread field: F.FOOBAR; should this field be static?
M P UuF: Unused field: F.blat
M P UrF: Unread field: F.thud
L P SIC: The class F$1 could be refactored into a named _static_ inner class
M P UrF: Unread field: IntHolder.value
L P SIC: The class Serializable2$1 could be refactored into a named _static_ inner class
M P UrF: Unread field: UncalledPrivateMethod.s
M P UuF: Unused field: UselessAssignments.bar
M P UrF: Unread field: VolatileUsage.a
M P UuF: Unused field: VolatileUsage.b
M P UuF: Unused field: VolatileUsage.c
M P UrF: Unread field: VolatileUsage.d
M P UrF: Unread field: VolatileUsage.e
M P UuF: Unused field: VolatileUsage.f
M P UuF: Unused field: VolatileUsage2.b
M P UuF: Unused field: VolatileUsage2.c
M P UuF: Unused field: VolatileUsage2.f
L M IS2: Inconsistent synchronization of Getter.x; locked 75% of time  Unsynchronized access at Getter.java:[line 4]
M M IS2: Inconsistent synchronization of Blat.yoom; locked 50% of time  Unsynchronized access at Blat.java:[line 77]
M M IS2: Inconsistent synchronization of SynchronizationTest2.x; locked 85% of time  Unsynchronized access at SynchronizationTest2.java:[line 23]
L M IS2: Inconsistent synchronization of SynchronizationTest4.x; locked 92% of time  Unsynchronized access at SynchronizationTest4.java:[line 23]
L M IS2: Inconsistent synchronization of SynchronizationTest3.x; locked 92% of time  Unsynchronized access at SynchronizationTest3.java:[line 23]
M S CD: Class CircularDepsTest has a circular dependency with other classes.
M S CD: Class CircularDepsTest has a circular dependency with other classes.
