L C HE: AbstractMissingHashCode defines equals and uses Object.hashCode()
M C HE: AbstractMissingHashCode$StillMissingHashCode inherits equals and uses Object.hashCode()
H C Nm: Confusing method name: BadConstructor.BadConstructor()  At BadConstructor.java:[line 4]
M C Se: BadSerial$NotFinal.serialVersionUID isn't final
L C Se: BadSerial$NotLong.serialVersionUID isn't long
M C Se: BadSerial$NotStatic.serialVersionUID isn't static
H C Nm: Class BadSpellingOfEquals defines equal(); should it be equals()?  At BadSpellingOfEquals.java:[line 4]
M C BOA: Method overrides a method implemented in super class Adapter wrongly  At BadlyOverriddenAdapterTest.java:[line 16]
M C IC: Initialization circularity between Bar and Foo
M P Dm: Blat.other(Blat) invokes dubious Boolean constructor; use Boolean.valueOf(...) instead  At Blat.java:[line 47]
M P Dm: Blat.getYoom() invokes dubious new String(String) constructor; just use the argument  At Blat.java:[line 76]
M P Dm: Blat.badlock() invokes dubious new String() constructor; just use ""  At Blat.java:[line 61]
M C FI: Blat.other(Blat) explicitly invokes Blat.finalize()  At Blat.java:[line 46]
M V FI: Blat.finalize() is public; should be protected  At Blat.java:[lines 42-43]
M M IS2: Inconsistent synchronization of Blat.yoom; locked 50% of time  Unsynchronized access at Blat.java:[line 77]
M C It: Blat.next() can't throw NoSuchElement exception  At Blat.java:[line 96]
M M ML: Blat.badlock() synchronizes on updated field Blat.lock  At Blat.java:[line 57]
M V MS: public static Blat.getFoobar() may expose internal representation by returning Blat.foobar  At Blat.java:[line 103]
M M NN: Naked notify in Blat.getYoom()  At Blat.java:[line 69]
L M No: Using notify rather than notifyAll in Blat.getYoom()  At Blat.java:[line 69]
M C RR: Blat.gimme(java.io.InputStream) ignores result of java.io.InputStream.read(byte[])  At Blat.java:[line 84]
M M Ru: Blat.xxx() explicitly invokes run on a thread (did you mean to start it instead?)  At Blat.java:[line 29]
M M SC: Blat.<init>() invokes Blat$Y.start()  At Blat.java:[line 23]
M C Se: Blat.serialVersionUID isn't static
M M SP: Spinning on Blat.java:[line 91] in Blat.spin()  At Blat.java:[line 91]
M P SS: Unread field: Blat.yarg; should this field be static?
M M UG: Blat.getYoom() is unsynchronized, Blat.setYoom(int) is synchronized  At Blat.java:[lines 67-77]
M C UR: Uninitialized read of Blat.lock in Blat.<init>()  At Blat.java:[line 22]
M M UW: Unconditional wait in Blat.getYoom()  At Blat.java:[line 73]
M M Wa: Wait not in loop in Blat.getYoom()  At Blat.java:[line 73]
M P FI: Blat$Bleem.finalize() is empty and should be deleted  At Blat.java:[line 36]
M P SIC: Should Blat$Bleem be a _static_ inner class?
L C Dm: CallSystemExit.equals(Object) invokes System.exit(...), which shuts down the entire virtual machine  At CallSystemExit.java:[line 6]
M C HE: CallSystemExit defines equals and uses Object.hashCode()
M C CN: Class CloneIdiom1 implements Cloneable but does not define or use clone method
M C CN: clone method CloneIdiom3.clone() does not call super.clone()  At CloneIdiom3.java:[line 3]
L C OS: CloseStream.writeFile(java.io.File,Object) may fail to close stream on exception  At CloseStream.java:[line 7]
M V EI2: DangerousStoreIntoField.h(int,String,String[]) may expose internal representation by storing an externally mutable object into DangerousStoreIntoField.z  At DangerousStoreIntoField.java:[line 17]
M V EI2: DangerousStoreIntoField.i(int,String,String[]) may expose internal representation by storing an externally mutable object into DangerousStoreIntoField.z  At DangerousStoreIntoField.java:[line 22]
M V EI2: DangerousStoreIntoField.j(java.util.Date) may expose internal representation by storing an externally mutable object into DangerousStoreIntoField.w  At DangerousStoreIntoField.java:[line 27]
M P UrF: Unread field: DangerousStoreIntoField.w
M P UrF: Unread field: DangerousStoreIntoField.z
H C IMSE: Dubious catching of IllegalMonitorStateException in DontCatchIllegalMonitor.foo()  At DontCatchIllegalMonitor.java:[line 10]
M M Wa: Wait not in loop in DontCatchIllegalMonitor.foo()  At DontCatchIllegalMonitor.java:[line 8]
M M DC: Possible doublecheck on Doublecheck.ready in Doublecheck.getData()  At Doublecheck.java:[lines 80-82]
M M DC: Possible doublecheck on Doublecheck.o in Doublecheck.standardDoubleCheck()  At Doublecheck.java:[lines 11-13]
M C UCF: Useless control flow in EmptyIfStatement.main(String[])  At EmptyIfStatement.java:[line 3]
L C PZLA: Should EncapsulationViolation.getExtensionValue() return a zero length array rather than null?  At EncapsulationViolation.java:[line 6]
L C Eq: Abstract Eq defines equals(Eq) method
L C ES: Comparison of String objects using == or != in EqStringTestIsBetter.test(String)   At EqStringTestIsBetter.java:[line 5]
M C EC: Call to equals() comparing different interface types in EqualsComparison.unrelatedInterfaceComparison(EqualsComparison$A,EqualsComparison$B)  At EqualsComparison.java:[line 18]
H C EC: Call to equals() comparing different types in EqualsComparison.badEqualsComparision()  At EqualsComparison.java:[line 9]
L C PZLA: Should Extension.getExtensionValue() return a zero length array rather than null?  At Extension.java:[line 151]
H C Se: ExternalizableTest is Externalizable but doesn't define a void constructor
H C Se: ExternalizableTest2 is Externalizable but doesn't define a void constructor
M C Se: ExternalizableTest2$ExternalizableTest2a is Externalizable but doesn't define a void constructor
M P SS: Unread field: F.FOOBAR; should this field be static?
M P UrF: Unread field: F.thud
M P UuF: Unused field: F.blat
L P SIC: The class F$1 could be refactored into a named _static_ inner class
M C RR: FindRRTest.main(String[]) ignores result of java.io.BufferedInputStream.read(byte[])  At FindRRTest.java:[line 17]
L M IS2: Inconsistent synchronization of Getter.x; locked 75% of time  Unsynchronized access at Getter.java:[line 4]
M M UG: Getter.getX() is unsynchronized, Getter.setX(int) is synchronized  At Getter.java:[line 4]
L C Co: Abstract Hashcode defines compareTo(Hashcode) method
L C HE: Hashcode defines hashCode and uses Object.equals()
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 30]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 31]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 37]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 38]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.foo()  At IncompatMaskTest.java:[line 8]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.foo()  At IncompatMaskTest.java:[line 9]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 34]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 35]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 41]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 42]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 32]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 33]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 39]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 40]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.foo()  At IncompatMaskTest.java:[line 10]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.foo()  At IncompatMaskTest.java:[line 11]
L C NP: Possible null pointer dereference in Infeasible.foo() on exception path  At Infeasible.java:[line 24]
M C UI: Usage of GetResource in InheritanceUnsafeClass.getResource(String) may be unsafe if class is extended  At InheritanceUnsafeClass.java:[line 7]
M P UrF: Unread field: IntHolder.value
H P Dm: InvokeGC.bad() forces garbage collection; extremely dubious except in benchmarking code  At InvokeGC.java:[line 12]
H P Dm: InvokeGC.finalize() forces garbage collection; extremely dubious except in benchmarking code  At InvokeGC.java:[line 8]
H P Dm: InvokeGC.tricky() forces garbage collection; extremely dubious except in benchmarking code  At InvokeGC.java:[line 30]
H C Nm: VERY confusing to have methods LongNaming$B.Wait() and java.lang.Object.wait()
H C Nm: VERY confusing to have methods LongNaming$B.methodF() and LongNaming.methodf()
H C Nm: VERY confusing to have methods LongNaming$B.methodG() and LongNaming$A.methodg()
M C MF: Class MaskMe$DerivedMaskMe defines field that obscures superclass field MaskMe.base_class_var
H C Nm: Confusing method name: MethodCapitalization.MethodCapitalization()  At MethodCapitalization.java:[line 4]
H C Nm: Class MethodCapitalization defines hashcode(); should it be hashCode()?  At MethodCapitalization.java:[line 10]
H C Nm: VERY confusing to have methods MethodCapitalization$Foo.getx() and MethodCapitalization.getX()
M C MWN: Mismatched notify() in MismatchedWait.bar(Object,Object)  At MismatchedWait.java:[line 11]
M C MWN: Mismatched notify() in MismatchedWait.bar(Object,Object)  At MismatchedWait.java:[line 12]
M C MWN: Mismatched wait() in MismatchedWait.foo(Object,Object)  At MismatchedWait.java:[line 5]
L M No: Using notify rather than notifyAll in MismatchedWait.bar(Object,Object)  At MismatchedWait.java:[line 11]
M M UW: Unconditional wait in MismatchedWait.foo(Object,Object)  At MismatchedWait.java:[line 5]
M M Wa: Wait not in loop in MismatchedWait.foo(Object,Object)  At MismatchedWait.java:[line 5]
M V MS: MutableStatic.p isn't final but should be
H C Nm: Class N2 defines hashcode(); should it be hashCode()?  At N2.java:[line 5]
H C Nm: Class N2 defines tostring(); should it be toString()?  At N2.java:[line 4]
H C Nm: VERY confusing to have methods N2.mincemeaT() and N1.mincemeat()
H C NP: Null pointer dereference in NP.main(String[])  At NP.java:[line 11]
L C RCN: Redundant comparision to null of previously checked value in NP.main(String[])  At NP.java:[line 19]
M C RCN: Redundant comparison to null in NP.main(String[])  At NP.java:[line 14]
M M NN: Naked notify in NakedWait.makeReady()  At NakedWait.java:[line 9]
L M No: Using notify rather than notifyAll in NakedWait.makeReady()  At NakedWait.java:[line 9]
M M UW: Unconditional wait in NakedWait.waitForReady()  At NakedWait.java:[line 17]
M C NP: Possible null pointer dereference in NonShortCircuit.nonEmpty(Object[])  At NonShortCircuit.java:[line 16]
M C NS: Questionable use of non-short-circuit logic in NonShortCircuit.ordered(int,int,int)  At NonShortCircuit.java:[line 12]
L C NS: Questionable use of non-short-circuit logic in NonShortCircuit.nonEmpty(Object[])  At NonShortCircuit.java:[line 16]
L C NS: Questionable use of non-short-circuit logic in NonShortCircuit.ordered(int,int,int)  At NonShortCircuit.java:[line 13]
H C NP: Null pointer dereference in NullDeref.main(String[])  At NullDeref.java:[line 16]
H C NP: Null pointer dereference in NullDeref.main(String[])  At NullDeref.java:[line 32]
M C RCN: Redundant comparison to null in NullDeref.main(String[])  At NullDeref.java:[line 11]
M C RCN: Redundant comparison to null in NullDeref.main(String[])  At NullDeref.java:[line 14]
M C NP: Possible null pointer dereference in NullDeref10.foo(Object)  At NullDeref10.java:[line 6]
M C NP: Possible null pointer dereference in NullDeref11.foo(Object)  At NullDeref11.java:[line 4]
M C NS: Questionable use of non-short-circuit logic in NullDeref11.foo(Object)  At NullDeref11.java:[line 4]
L C PZLA: Should NullDeref12.get() return a zero length array rather than null?  At NullDeref12.java:[line 11]
L C DE: NullDeref2.possibleNullPointerInExceptionPath() might ignore java.lang.Exception  At NullDeref2.java:[line 21]
L C NP: Null pointer dereference in NullDeref2.detectedNullPointerInExceptionPath() on exception path  At NullDeref2.java:[line 10]
M C NP: Possible null pointer dereference in NullDeref2.possibleNullPointerInNormalPath()  At NullDeref2.java:[line 37]
L C NP: Possible null pointer dereference in NullDeref2.possibleNullPointerInExceptionPath() on exception path  At NullDeref2.java:[line 24]
M C RCN: Redundant comparison to null in NullDeref2.detectedNullPointerInExceptionPath()  At NullDeref2.java:[line 4]
M C RCN: Redundant comparison to null in NullDeref2.possibleNullPointerInExceptionPath()  At NullDeref2.java:[line 17]
M C RCN: Redundant comparison to null in NullDeref2.possibleNullPointerInNormalPath()  At NullDeref2.java:[line 30]
M C NP: Possible null pointer dereference in NullDeref3.same1(int[],int[])  At NullDeref3.java:[line 14]
M C NP: Possible null pointer dereference in NullDeref3.same2(Object,Object)  At NullDeref3.java:[line 20]
M C NP: Possible null pointer dereference in NullDeref3.same3(Object,Object)  At NullDeref3.java:[line 28]
L C RCN: Redundant comparision to null of previously checked value in NullDeref4.foo()  At NullDeref4.java:[line 7]
L M No: Using notify rather than notifyAll in NullDeref5.foo()  At NullDeref5.java:[line 14]
M C UwF: Unwritten field: NullDeref5.lock
H C NP: Null pointer dereference in NullDeref6.bar(Object)  At NullDeref6.java:[line 29]
L C RCN: Redundant comparision to null of previously checked value in NullDeref6.bar(Object)  At NullDeref6.java:[line 25]
L C RCN: Redundant comparision to null of previously checked value in NullDeref6.foo(Object)  At NullDeref6.java:[line 16]
M C RCN: Redundant comparison to null in NullDeref6.bar(Object)  At NullDeref6.java:[line 31]
M C NP: Possible null pointer dereference in NullDeref7.bar(Object)  At NullDeref7.java:[line 19]
M C OS: NullDeref8.foo(String) may fail to close stream  At NullDeref8.java:[line 8]
M C RCN: Redundant comparison to null in NullPointerLattice.f(Object,boolean)  At NullPointerLattice.java:[line 9]
M C ODR: OpenDatabase.openConnection() may fail to close database resource  At OpenDatabase.java:[line 5]
L C NP: Null pointer dereference in OpenStream.main(String[]) on exception path  At OpenStream.java:[line 14]
M C OS: OpenStream.wrappedStreamClosedDoNotReport() may fail to close stream  At OpenStream.java:[line 59]
L C OS: OpenStream.wrappedStreamClosedDoNotReport() may fail to close stream on exception  At OpenStream.java:[line 58]
M C OS: OverbroadCatch.foo(String) may fail to close stream  At OverbroadCatch.java:[line 6]
M P Dm: Overloaded.foo(int) invokes dubious Boolean constructor; use Boolean.valueOf(...) instead  At Overloaded.java:[line 3]
M P Dm: Overloaded.foo(String) invokes dubious Boolean constructor; use Boolean.valueOf(...) instead  At Overloaded.java:[line 7]
M P Dm: Overloaded.foo(String,boolean) invokes dubious Boolean constructor; use Boolean.valueOf(...) instead  At Overloaded.java:[line 11]
L C PZLA: Should PreferZeroLengthArrays.foo(int) return a zero length array rather than null?  At PreferZeroLengthArrays.java:[line 5]
M P Dm: RV.main(String[]) invokes dubious new String(String) constructor; just use the argument  At RV.java:[line 3]
M C RV: RV.f(java.security.MessageDigest,byte[]) ignores return value of java.lang.IllegalStateException.<init>(String)  At RV.java:[line 12]
M C RV: RV.f(java.security.MessageDigest,byte[]) ignores return value of java.security.MessageDigest.digest(byte[])  At RV.java:[line 11]
M C RV: RV.main(String[]) ignores return value of RV.<init>()  At RV.java:[line 6]
M C RV: RV.main(String[]) ignores return value of java.lang.String.trim()  At RV.java:[line 5]
L C RV: RV.g(java.io.File) ignores return value of java.io.File.createNewFile()  At RV.java:[line 16]
M M RS: ReadObject's readObject method is synchronized
L C RCN: Redundant comparision to null of previously checked value in RedundantNullCheck.foo(String)  At RedundantNullCheck.java:[line 8]
L C RCN: Redundant comparision to null of previously checked value in RedundantNullCheck.foo(String)  At RedundantNullCheck.java:[line 14]
M C RCN: Redundant comparison to null in RedundantNullCheck.foo(String)  At RedundantNullCheck.java:[line 5]
M C RCN: Redundant comparison to null in RedundantNullCheck.foo(String)  At RedundantNullCheck.java:[line 19]
M P SBSC: Method SBConcatTest.doConcat1(String[]) concatenates strings using + in a loop  At SBConcatTest.java:[line 10]
M P SBSC: Method SBConcatTest.doConcat2(String[]) concatenates strings using + in a loop  At SBConcatTest.java:[line 22]
M C SA: Self assignment of local variable in SelfAssignment.foo()  At SelfAssignment.java:[line 4]
H C Se: Class Ser defines non-transient non-serializable instance field Ser.holder
L C Se: Class Ser defines non-transient non-serializable instance field Ser.m
H C Se: Serializable2$Inner is Serializable  but its superclass doesn't define an accessible void constructor
M C RR: SkipBufferedInputStream.main(String[]) ignores result of java.io.BufferedInputStream.read(byte[])  At SkipBufferedInputStream.java:[line 12]
M C RR: SkipBufferedInputStream2.main(String[]) ignores result of java.io.BufferedInputStream.read(byte[])  At SkipBufferedInputStream2.java:[line 13]
M M SP: Spinning on SpinWait.java:[line 6] in SpinWait.waitForTrue()  At SpinWait.java:[line 6]
M M SP: Spinning on SpinWait.java:[line 9] in SpinWait.waitForVolatileTrue()  At SpinWait.java:[line 9]
M C UwF: Unwritten field: SpinWait.flag
M C UwF: Unwritten field: SpinWait.vflag
H C ES: Comparison of String objects using == or != in StringComparision.isOrigin()   At StringComparision.java:[line 9]
L C ES: Comparison of String objects using == or != in StringComparision.compareTwo(String,String)   At StringComparision.java:[line 18]
L C ES: Comparison of String objects using == or != in StringComparision.searchFields(java.lang.reflect.Field[],String)   At StringComparision.java:[line 26]
M C RC: Suspicious comparison of java.lang.Boolean references in StringComparision.compareBool(Boolean,Boolean)  At StringComparision.java:[line 15]
H C ES: Comparison of String objects using == or != in StringEqualityTest.almostEmpty(String)   At StringEqualityTest.java:[line 4]
L C ES: Comparison of String objects using == or != in StringEqualsTest.test(String)   At StringEqualsTest.java:[line 5]
M C SW: Call to swing method in Swing1.main(String[]) needs to be performed in Swing event thread  At Swing1.java:[line 15]
M C SW: Call to swing method in Swing1.main(String[]) needs to be performed in Swing event thread  At Swing1.java:[line 16]
M C SW: Call to swing method in Swing1.main(String[]) needs to be performed in Swing event thread  At Swing1.java:[line 17]
M M IS2: Inconsistent synchronization of SynchronizationTest2.x; locked 85% of time  Unsynchronized access at SynchronizationTest2.java:[line 23]
L M IS2: Inconsistent synchronization of SynchronizationTest3.x; locked 92% of time  Unsynchronized access at SynchronizationTest3.java:[line 23]
L M IS2: Inconsistent synchronization of SynchronizationTest4.x; locked 92% of time  Unsynchronized access at SynchronizationTest4.java:[line 23]
M C RR: TestReadandSkipReturnShouldBeChecked.test() ignores result of java.io.BufferedInputStream.read(byte[])  At TestReadandSkipReturnShouldBeChecked.java:[line 18]
M C RR: TestReadandSkipReturnShouldBeChecked.test() ignores result of java.io.BufferedInputStream.read(byte[])  At TestReadandSkipReturnShouldBeChecked.java:[line 20]
H C RR: TestReadandSkipReturnShouldBeChecked.test() ignores result of java.io.BufferedInputStream.skip(long)  At TestReadandSkipReturnShouldBeChecked.java:[line 19]
M M 2LW: wait() with two locks held in TwoLockWait.myMethod(Object,Object)  At TwoLockWait.java:[line 8]
M M UW: Unconditional wait in TwoLockWait.myMethod(Object,Object)  At TwoLockWait.java:[line 8]
M M Wa: Wait not in loop in TwoLockWait.myMethod(Object,Object)  At TwoLockWait.java:[line 8]
M M UW: Unconditional wait in TwoLocksWhileWaitingFalsePositive.clueless()  At TwoLocksWhileWaitingFalsePositive.java:[line 8]
M M Wa: Wait not in loop in TwoLocksWhileWaitingFalsePositive.clueless()  At TwoLocksWhileWaitingFalsePositive.java:[line 8]
L C OS: TwoStreams.nullDereferenceCheck(TwoStreams) may fail to close stream on exception  At TwoStreams.java:[line 28]
L C OS: TwoStreams.twoStreamsRight() may fail to close stream on exception  At TwoStreams.java:[line 39]
L C OS: TwoStreams.twoStreamsWrong() may fail to close stream on exception  At TwoStreams.java:[line 12]
M P UPM: Private method UncalledPrivateMethod.foobar(int) is never called  At UncalledPrivateMethod.java:[line 20]
L P UPM: Private method UncalledPrivateMethod.foo(String) is never called  At UncalledPrivateMethod.java:[lines 11-12]
M P UrF: Unread field: UncalledPrivateMethod.s
M C SA: Self assignment of field UselessAssignments.foo in UselessAssignments.<init>(int,int)  At UselessAssignments.java:[line 6]
M C SA: Self assignment of local variable in UselessAssignments.<init>(int,int)  At UselessAssignments.java:[line 7]
M C UR: Uninitialized read of UselessAssignments.foo in UselessAssignments.<init>(int,int)  At UselessAssignments.java:[line 6]
L C Nm: Confusing to have methods java.awt.Component.getX() and MethodCapitalization$Bar.getx()
