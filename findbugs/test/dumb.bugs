L C HE: AbstractMissingHashCode defines equals and uses Object.hashCode()
M C HE: AbstractMissingHashCode$StillMissingHashCode inherits equals and uses Object.hashCode()
H C Nm: Confusing method name: BadConstructor.BadConstructor()  At BadConstructor.java:[lines 5-6]
M S Nm: The method name BadConstructor.BadConstructor() doesn't start with an lower case letter  At BadConstructor.java:[lines 5-6]
M C UOE: Calls to equals on an Array equates to ==  At BadEquals.java:[line 8]
M C UOE: Calls to equals on an Array equates to ==  At BadEquals.java:[line 14]
M P Dm: Method BadRandomInt.nextInt(int) uses the nextDouble method of Random to generate a random integer; using nextInt is more efficient  At BadRandomInt.java:[line 7]
M C BRSA: Method BadResultSetAccessTest.test0(java.sql.ResultSet) attempts to access a result set field with index 0  At BadResultSetAccessTest.java:[line 14]
M C BRSA: Method BadResultSetAccessTest.test1(java.sql.ResultSet) attempts to access a result set field with index 0  At BadResultSetAccessTest.java:[line 20]
M C BRSA: Method BadResultSetAccessTest.test1(java.sql.ResultSet) attempts to access a result set field with index 0  At BadResultSetAccessTest.java:[line 22]
M C BRSA: Method BadResultSetAccessTest.test2(java.sql.ResultSet) attempts to access a result set field with index 0  At BadResultSetAccessTest.java:[line 26]
M C BRSA: Method BadResultSetAccessTest.test2(java.sql.ResultSet) attempts to access a result set field with index 0  At BadResultSetAccessTest.java:[line 28]
M C Se: BadSerial$NotFinal.serialVersionUID isn't final
L C Se: BadSerial$NotLong.serialVersionUID isn't long
M C Se: BadSerial$NotStatic.serialVersionUID isn't static
H C Nm: Class BadSpellingOfEquals defines equal(); should it be equals()?  At BadSpellingOfEquals.java:[line 4]
M C AM: Empty zip file entry created in BadZipFileCreator.main(String[])  At BadZipFileCreator.java:[line 11]
M C BOA: Class BadlyOverriddenAdapterTest$1 overrides a method BadlyOverriddenAdapterTest$1.windowClosing() implemented in super class Adapter wrongly  At BadlyOverriddenAdapterTest.java:[line 13]
M C IC: Initialization circularity between Bar and Foo
M P Dm: Blat.other(Blat) invokes dubious Boolean constructor; use Boolean.valueOf(...) instead  At Blat.java:[line 47]
M P Dm: Blat.getYoom() invokes dubious new String(String) constructor; just use the argument  At Blat.java:[line 76]
M P Dm: Blat.badlock() invokes dubious new String() constructor; just use ""  At Blat.java:[line 61]
M C FI: Blat.other(Blat) explicitly invokes Blat.finalize()  At Blat.java:[line 46]
M V FI: Blat.finalize() is public; should be protected  At Blat.java:[lines 42-43]
M M IS2: Inconsistent synchronization of Blat.yoom; locked 50% of time  Unsynchronized access at Blat.java:[line 77]
M C It: Blat.next() can't throw NoSuchElement exception  At Blat.java:[line 96]
M M ML: Blat.badlock() synchronizes on updated field Blat.lock  At Blat.java:[line 57]
M V MS: public static Blat.getFoobar() may expose internal representation by returning Blat.foobar  At Blat.java:[line 103]
M M NN: Naked notify in Blat.getYoom()  At Blat.java:[line 69]
L M No: Using notify rather than notifyAll in Blat.getYoom()  At Blat.java:[line 69]
M C RR: Blat.gimme(java.io.InputStream) ignores result of java.io.InputStream.read(byte[])  At Blat.java:[line 84]
M M Ru: Blat.xxx() explicitly invokes run on a thread (did you mean to start it instead?)  At Blat.java:[line 29]
M M SC: Blat.<init>() invokes Blat$Y.start()  At Blat.java:[line 23]
M C Se: Blat.serialVersionUID isn't static
M M SP: Spinning on Blat.lock in Blat.spin()  At Blat.java:[line 91]
M P SS: Unread field: Blat.yarg; should this field be static?
M M UG: Blat.getYoom() is unsynchronized, Blat.setYoom(int) is synchronized  At Blat.java:[lines 67-77]
M C UR: Uninitialized read of Blat.lock in Blat.<init>()  At Blat.java:[line 22]
M M UW: Unconditional wait in Blat.getYoom()  At Blat.java:[line 73]
M M Wa: Wait not in loop in Blat.getYoom()  At Blat.java:[line 73]
M P FI: Blat$Bleem.finalize() is empty and should be deleted  At Blat.java:[line 36]
M P SIC: Should Blat$Bleem be a _static_ inner class?
L C Dm: CallSystemExit.equals(Object) invokes System.exit(...), which shuts down the entire virtual machine  At CallSystemExit.java:[line 6]
M C HE: CallSystemExit defines equals and uses Object.hashCode()
M C CN: Class CloneIdiom1 implements Cloneable but does not define or use clone method
M C CN: clone method CloneIdiom3.clone() does not call super.clone()  At CloneIdiom3.java:[line 3]
L C OS: CloseStream.writeFile(java.io.File,Object) may fail to close stream on exception  At CloseStream.java:[line 7]
M C UOE: Calls to equals on an Array equates to ==  At CompareArrays.java:[line 7]
M C UOE: Calls to equals on an Array equates to ==  At CompareArrays.java:[line 12]
M V EI2: DangerousStoreIntoField.h(int,String,String[]) may expose internal representation by storing an externally mutable object into DangerousStoreIntoField.z  At DangerousStoreIntoField.java:[line 17]
M V EI2: DangerousStoreIntoField.i(int,String,String[]) may expose internal representation by storing an externally mutable object into DangerousStoreIntoField.z  At DangerousStoreIntoField.java:[line 22]
M V EI2: DangerousStoreIntoField.j(java.util.Date) may expose internal representation by storing an externally mutable object into DangerousStoreIntoField.w  At DangerousStoreIntoField.java:[line 27]
M P UrF: Unread field: DangerousStoreIntoField.w
M P UrF: Unread field: DangerousStoreIntoField.z
L C ODR: DatabaseStreams.method() may fail to close database resource on exception  At DatabaseStreams.java:[line 11]
H C DLS: Dead store to local variable in method DeadStore.main(String[])  At DeadStore.java:[line 7]
L C DLS: Dead store to local variable in method DeadStore.main(String[])  At DeadStore.java:[line 4]
M C IP: A parameter to DeadStore.main(String[]) is dead upon entry but overwritten  At DeadStore.java:[line 7]
M P Dm: DemonstrateStringError.<clinit>() invokes dubious new String(String) constructor; just use the argument  At DemonstrateStringError.java:[line 12]
H C IMSE: Dubious catching of IllegalMonitorStateException in DontCatchIllegalMonitor.foo()  At DontCatchIllegalMonitor.java:[line 10]
M M Wa: Wait not in loop in DontCatchIllegalMonitor.foo()  At DontCatchIllegalMonitor.java:[line 8]
M M DC: Possible doublecheck on Doublecheck.ready in Doublecheck.getData()  At Doublecheck.java:[lines 80-82]
M M DC: Possible doublecheck on Doublecheck.o in Doublecheck.standardDoubleCheck()  At Doublecheck.java:[lines 11-13]
M P Dm: Method DumbMethods.getStringOfString(String) invokes toString() method on a String; just use the String  At DumbMethods.java:[line 5]
M C AM: Empty jar file entry created in EmptyEntry.testJar(java.util.jar.JarOutputStream)  At EmptyEntry.java:[line 16]
M C AM: Empty zip file entry created in EmptyEntry.testZip(java.util.zip.ZipOutputStream)  At EmptyEntry.java:[line 10]
M C UCF: Useless control flow in EmptyIfStatement.main(String[])  At EmptyIfStatement.java:[line 3]
L C PZLA: Should EncapsulationViolation.getExtensionValue() return a zero length array rather than null?  At EncapsulationViolation.java:[line 6]
L C Eq: Abstract Eq defines equals(Eq) method
L C ES: Comparison of String objects using == or != in EqStringTestIsBetter.test(String)   At EqStringTestIsBetter.java:[line 5]
M C EC: Call to equals() with null argument in EqualsComparison.isEqualToNull(String)  At EqualsComparison.java:[line 17]
M C EC: Call to equals() comparing different interface types in EqualsComparison.unrelatedInterfaceComparison(EqualsComparison$A,EqualsComparison$B)  At EqualsComparison.java:[line 22]
H C EC: Call to equals() comparing different types in EqualsComparison.badEqualsComparision()  At EqualsComparison.java:[line 9]
L C PZLA: Should Extension.getExtensionValue() return a zero length array rather than null?  At Extension.java:[line 151]
H C Se: ExternalizableTest is Externalizable but doesn't define a void constructor
H C Se: ExternalizableTest2 is Externalizable but doesn't define a void constructor
M C Se: ExternalizableTest2$ExternalizableTest2a is Externalizable but doesn't define a void constructor
M P SS: Unread field: F.FOOBAR; should this field be static?
M P UrF: Unread field: F.thud
M P UuF: Unused field: F.blat
L P SIC: The class F$1 could be refactored into a named _static_ inner class
M P FI: Finalize.finalize() is empty and should be deleted  At Finalize.java:[line 3]
M C RR: FindRRTest.main(String[]) ignores result of java.io.BufferedInputStream.read(byte[])  At FindRRTest.java:[line 17]
L M IS2: Inconsistent synchronization of Getter.x; locked 75% of time  Unsynchronized access at Getter.java:[line 4]
M M UG: Getter.getX() is unsynchronized, Getter.setX(int) is synchronized  At Getter.java:[line 4]
L C Co: Abstract Hashcode defines compareTo(Hashcode) method
L C HE: Hashcode defines hashCode and uses Object.equals()
H C RV: IgnoredReturnValue.main(String[]) ignores return value of java.lang.String.equals(Object)  At IgnoredReturnValue.java:[line 10]
H C RV: IgnoredReturnValue.main(String[]) ignores return value of java.lang.String.trim()  At IgnoredReturnValue.java:[line 9]
M C RV: IgnoredReturnValue.main(String[]) ignores return value of java.util.concurrent.BlockingQueue.offer(Object)  At IgnoredReturnValue.java:[line 15]
M C RV: IgnoredReturnValue.main(String[]) ignores return value of java.util.concurrent.BlockingQueue.offer(Object,long,TimeUnit)  At IgnoredReturnValue.java:[line 16]
M C RV: IgnoredReturnValue.main(String[]) ignores return value of java.util.concurrent.BlockingQueue.poll()  At IgnoredReturnValue.java:[line 18]
M C RV: IgnoredReturnValue.main(String[]) ignores return value of java.util.concurrent.BlockingQueue.poll()  At IgnoredReturnValue.java:[line 30]
M C RV: IgnoredReturnValue.main(String[]) ignores return value of java.util.concurrent.BlockingQueue.poll(long,TimeUnit)  At IgnoredReturnValue.java:[line 17]
M C RV: IgnoredReturnValue.main(String[]) ignores return value of java.util.concurrent.Semaphore.tryAcquire()  At IgnoredReturnValue.java:[line 12]
M C RV: IgnoredReturnValue.main(String[]) ignores return value of java.util.concurrent.Semaphore.tryAcquire(long,TimeUnit)  At IgnoredReturnValue.java:[line 13]
M C RV: IgnoredReturnValue.main(String[]) ignores return value of java.util.concurrent.locks.Condition.await(long,java.util.concurrent.TimeUnit)  At IgnoredReturnValue.java:[line 25]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 30]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 31]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 37]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 38]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.foo()  At IncompatMaskTest.java:[line 8]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.foo()  At IncompatMaskTest.java:[line 9]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 34]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 35]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 41]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 42]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 32]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 33]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 39]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.bar()  At IncompatMaskTest.java:[line 40]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.foo()  At IncompatMaskTest.java:[line 10]
M C BIT: Incompatible bit masks yield a constant result in IncompatMaskTest.foo()  At IncompatMaskTest.java:[line 11]
L C NP: Possible null pointer dereference in Infeasible.foo() on exception path  At Infeasible.java:[line 24]
M C DLS: Dead store to local variable in method InfiniteRecursiveLoop.<init>(int,int)  At InfiniteRecursiveLoop.java:[line 7]
H C IL: There is an apparent infinite recursive loop in InfiniteRecursiveLoop.<init>(int,int).  At InfiniteRecursiveLoop.java:[lines 5-8]
H C IL: There is an apparent infinite recursive loop in InfiniteRecursiveLoop.more().  At InfiniteRecursiveLoop.java:[line 11]
H C IL: There is an apparent infinite recursive loop in InfiniteRecursiveLoop.muchMore().  At InfiniteRecursiveLoop.java:[line 15]
M C UI: Usage of GetResource in InheritanceUnsafeClass.getResource(String) may be unsafe if class is extended  At InheritanceUnsafeClass.java:[line 15]
M P UrF: Unread field: IntHolder.value
H P Dm: InvokeGC.bad() forces garbage collection; extremely dubious except in benchmarking code  At InvokeGC.java:[line 12]
H P Dm: InvokeGC.finalize() forces garbage collection; extremely dubious except in benchmarking code  At InvokeGC.java:[line 8]
H P Dm: InvokeGC.tricky() forces garbage collection; extremely dubious except in benchmarking code  At InvokeGC.java:[line 30]
M S Nm: The method name LongNaming$B.Wait() doesn't start with an lower case letter  At LongNaming.java:[line 19]
H C Nm: VERY confusing to have methods LongNaming$B.Wait() and java.lang.Object.wait()
H C Nm: VERY confusing to have methods LongNaming$B.methodF() and LongNaming.methodf()
H C Nm: VERY confusing to have methods LongNaming$B.methodG() and LongNaming$A.methodg()
M C DLS: Dead store to local variable in method MaskMe.modify_base_class_var()  At MaskMe.java:[line 16]
M C MF: Class MaskMe$DerivedMaskMe defines field that obscures superclass field MaskMe.base_class_var
M C Nm: Confusing method name: MethodCapitalization.MethodCapitalization()  At MethodCapitalization.java:[line 4]
H C Nm: Class MethodCapitalization defines hashcode(); should it be hashCode()?  At MethodCapitalization.java:[line 10]
M S Nm: The method name MethodCapitalization.MethodCapitalization() doesn't start with an lower case letter  At MethodCapitalization.java:[line 4]
H C Nm: VERY confusing to have methods MethodCapitalization$Foo.getx() and MethodCapitalization.getX()
M C MWN: Mismatched notify() in MismatchedWait.bar(Object,Object)  At MismatchedWait.java:[line 11]
M C MWN: Mismatched notify() in MismatchedWait.bar(Object,Object)  At MismatchedWait.java:[line 12]
M C MWN: Mismatched wait() in MismatchedWait.foo(Object,Object)  At MismatchedWait.java:[line 5]
L M No: Using notify rather than notifyAll in MismatchedWait.bar(Object,Object)  At MismatchedWait.java:[line 11]
M M UW: Unconditional wait in MismatchedWait.foo(Object,Object)  At MismatchedWait.java:[line 5]
M M Wa: Wait not in loop in MismatchedWait.foo(Object,Object)  At MismatchedWait.java:[line 5]
M V MS: MutableStatic.data2 should be both final and package protected
M V MS: MutableStatic.data should be package protected
M V MS: MutableStatic.h should be package protected
H V MS: MutableStatic.p isn't final but should be
H C Nm: Class N2 defines hashcode(); should it be hashCode()?  At N2.java:[line 5]
H C Nm: Class N2 defines tostring(); should it be toString()?  At N2.java:[line 4]
M S Nm: The method name N2.N1() doesn't start with an lower case letter  At N2.java:[line 3]
H C Nm: VERY confusing to have methods N2.mincemeaT() and N1.mincemeat()
H C NP: Null pointer dereference in NP.main(String[])  At NP.java:[line 11]
L C RCN: Redundant comparision to null of previously checked value in NP.main(String[])  At NP.java:[line 19]
M C RCN: Redundant comparison to null in NP.main(String[])  At NP.java:[line 14]
M M NN: Naked notify in NakedWait.makeReady()  At NakedWait.java:[line 9]
L M No: Using notify rather than notifyAll in NakedWait.makeReady()  At NakedWait.java:[line 9]
M M UW: Unconditional wait in NakedWait.waitForReady()  At NakedWait.java:[line 17]
M C RV: NeedsToCheckReturnValue.bar(NeedsReturnValueChecked) ignores return value of NeedsReturnValueChecked.foo()  At NeedsToCheckReturnValue.java:[line 6]
L C DLS: Dead store to local variable in method NewForGetClass.main(String[])  At NewForGetClass.java:[line 8]
L P Dm: Method NewForGetClass.main(String[]) allocates an object, only to get the class object  At NewForGetClass.java:[line 8]
M C NP: Possible null pointer dereference in NonShortCircuit.nonEmpty(Object[])  At NonShortCircuit.java:[line 16]
M C NS: Questionable use of non-short-circuit logic in NonShortCircuit.ordered(int,int,int)  At NonShortCircuit.java:[line 12]
L C NS: Questionable use of non-short-circuit logic in NonShortCircuit.nonEmpty(Object[])  At NonShortCircuit.java:[line 16]
L C NS: Questionable use of non-short-circuit logic in NonShortCircuit.ordered(int,int,int)  At NonShortCircuit.java:[line 13]
L C Dm: Method NoopThread.test1() creates a thread using the default empty run method  At NoopThread.java:[line 12]
L C Dm: Method NoopThread.test2() creates a thread using the default empty run method  At NoopThread.java:[line 18]
L C Dm: Method NoopThread.test3() creates a thread using the default empty run method  At NoopThread.java:[line 25]
H C NP: Null pointer dereference in NullDeref.main(String[])  At NullDeref.java:[line 16]
H C NP: Null pointer dereference in NullDeref.main(String[])  At NullDeref.java:[line 32]
M C RCN: Redundant comparison to null in NullDeref.main(String[])  At NullDeref.java:[line 11]
M C RCN: Redundant comparison to null in NullDeref.main(String[])  At NullDeref.java:[line 14]
M C NP: Possible null pointer dereference in NullDeref10.foo(Object)  At NullDeref10.java:[line 6]
M C NP: Possible null pointer dereference in NullDeref11.foo(Object)  At NullDeref11.java:[line 4]
M C NS: Questionable use of non-short-circuit logic in NullDeref11.foo(Object)  At NullDeref11.java:[line 4]
L C PZLA: Should NullDeref12.get() return a zero length array rather than null?  At NullDeref12.java:[line 11]
L C DLS: Dead store to local variable in method NullDeref2.detectedNullPointerInExceptionPath()  At NullDeref2.java:[line 8]
L C NP: Null pointer dereference in NullDeref2.detectedNullPointerInExceptionPath() on exception path  At NullDeref2.java:[line 11]
M C NP: Possible null pointer dereference in NullDeref2.possibleNullPointerInNormalPath()  At NullDeref2.java:[line 38]
L C NP: Possible null pointer dereference in NullDeref2.possibleNullPointerInExceptionPath() on exception path  At NullDeref2.java:[line 25]
M C RCN: Redundant comparison to null in NullDeref2.detectedNullPointerInExceptionPath()  At NullDeref2.java:[line 5]
M C RCN: Redundant comparison to null in NullDeref2.possibleNullPointerInExceptionPath()  At NullDeref2.java:[line 18]
M C RCN: Redundant comparison to null in NullDeref2.possibleNullPointerInNormalPath()  At NullDeref2.java:[line 31]
M C NP: Possible null pointer dereference in NullDeref3.same1(int[],int[])  At NullDeref3.java:[line 14]
M C NP: Possible null pointer dereference in NullDeref3.same2(Object,Object)  At NullDeref3.java:[line 20]
M C NP: Possible null pointer dereference in NullDeref3.same3(Object,Object)  At NullDeref3.java:[line 28]
L C RCN: Redundant comparision to null of previously checked value in NullDeref4.foo()  At NullDeref4.java:[line 7]
L M No: Using notify rather than notifyAll in NullDeref5.foo()  At NullDeref5.java:[line 14]
M C UwF: Unwritten field: NullDeref5.lock
H C NP: Null pointer dereference in NullDeref6.bar(Object)  At NullDeref6.java:[line 29]
L C RCN: Redundant comparision to null of previously checked value in NullDeref6.bar(Object)  At NullDeref6.java:[line 25]
L C RCN: Redundant comparision to null of previously checked value in NullDeref6.foo(Object)  At NullDeref6.java:[line 16]
M C RCN: Redundant comparison to null in NullDeref6.bar(Object)  At NullDeref6.java:[line 31]
M C NP: Possible null pointer dereference in NullDeref7.bar(Object)  At NullDeref7.java:[line 19]
M C OS: NullDeref8.foo(String) may fail to close stream  At NullDeref8.java:[line 8]
M C RCN: Redundant comparison to null in NullPointerLattice.f(Object,boolean)  At NullPointerLattice.java:[line 9]
L C DLS: Dead store to local variable in method OpenDatabase.openConnection()  At OpenDatabase.java:[line 5]
M C ODR: OpenDatabase.openConnection() may fail to close database resource  At OpenDatabase.java:[line 5]
L C NP: Null pointer dereference in OpenStream.main(String[]) on exception path  At OpenStream.java:[line 14]
M C OS: OpenStream.wrappedStreamClosedDoNotReport() may fail to close stream  At OpenStream.java:[line 61]
M C DLS: Dead store to local variable in method OverbroadCatch.foo(String)  At OverbroadCatch.java:[line 6]
M C OS: OverbroadCatch.foo(String) may fail to close stream  At OverbroadCatch.java:[line 6]
M P Dm: Overloaded.foo(int) invokes dubious Boolean constructor; use Boolean.valueOf(...) instead  At Overloaded.java:[line 3]
M P Dm: Overloaded.foo(String) invokes dubious Boolean constructor; use Boolean.valueOf(...) instead  At Overloaded.java:[line 7]
M P Dm: Overloaded.foo(String,boolean) invokes dubious Boolean constructor; use Boolean.valueOf(...) instead  At Overloaded.java:[line 11]
L C PZLA: Should PreferZeroLengthArrays.foo(int) return a zero length array rather than null?  At PreferZeroLengthArrays.java:[line 5]
H V MS: RECTest.anException isn't final but should be
M S REC: Method RECTest.testFail() catches Exception, but Exception is not thrown in the try block and RuntimeException is not explicitly caught  At RECTest.java:[line 25]
M S REC: Method RECTest.testFail2() catches Exception, but Exception is not thrown in the try block and RuntimeException is not explicitly caught  At RECTest.java:[line 35]
M S REC: Method RECTest.testFail3() catches Exception, but Exception is not thrown in the try block and RuntimeException is not explicitly caught  At RECTest.java:[line 46]
M S REC: Method RECTest.testFail4() catches Exception, but Exception is not thrown in the try block and RuntimeException is not explicitly caught  At RECTest.java:[line 56]
M S REC: Method RECTest.testFail5() catches Exception, but Exception is not thrown in the try block and RuntimeException is not explicitly caught  At RECTest.java:[line 66]
M P Dm: RV.main(String[]) invokes dubious new String(String) constructor; just use the argument  At RV.java:[line 3]
H C RV: RV.f(java.security.MessageDigest,byte[]) ignores return value of java.lang.IllegalStateException.<init>(String)  At RV.java:[line 12]
H C RV: RV.main(String[]) ignores return value of java.lang.String.trim()  At RV.java:[line 5]
M C RV: RV.f(java.security.MessageDigest,byte[]) ignores return value of java.security.MessageDigest.digest(byte[])  At RV.java:[line 11]
M C RV: RV.main(String[]) ignores return value of RV.<init>()  At RV.java:[line 6]
L C RV: RV.g(java.io.File) ignores return value of java.io.File.createNewFile()  At RV.java:[line 16]
M M RS: ReadObject's readObject method is synchronized
L M WS: ReadObject's writeObject method is synchronized but nothing else is
L C RCN: Redundant comparision to null of previously checked value in RedundantNullCheck.foo(String)  At RedundantNullCheck.java:[line 8]
L C RCN: Redundant comparision to null of previously checked value in RedundantNullCheck.foo(String)  At RedundantNullCheck.java:[line 14]
M C RCN: Redundant comparison to null in RedundantNullCheck.foo(String)  At RedundantNullCheck.java:[line 5]
M C RCN: Redundant comparison to null in RedundantNullCheck.foo(String)  At RedundantNullCheck.java:[line 19]
M P SBSC: Method SBConcatTest.doConcat1(String[]) concatenates strings using + in a loop  At SBConcatTest.java:[line 10]
M P SBSC: Method SBConcatTest.doConcat2(String[]) concatenates strings using + in a loop  At SBConcatTest.java:[line 22]
M S SA: Self assignment of local variable in SelfAssignment.foo()  At SelfAssignment.java:[line 4]
H C Se: Class Ser defines non-transient non-serializable instance field Ser.holder
L C Se: Class Ser defines non-transient non-serializable instance field Ser.m
M C DLS: Dead store to local variable in method Serializable2.exampleOfSerializableAnonymousClass()  At Serializable2.java:[line 20]
L C Se: Class Serializable2$1 defines non-transient non-serializable instance field Serializable2$1.this$0
L P SIC: The class Serializable2$1 could be refactored into a named _static_ inner class
H C Se: Serializable2$Inner is Serializable  but its superclass doesn't define an accessible void constructor
L P Dm: Method SillyBoxedUsage.testBad1(int) allocates a boxed primitive just to call toString  At SillyBoxedUsage.java:[line 7]
L P Dm: Method SillyBoxedUsage.testBad2(float) allocates a boxed primitive just to call toString  At SillyBoxedUsage.java:[line 17]
L P Dm: Method SillyBoxedUsage.testBad3(double) allocates a boxed primitive just to call toString  At SillyBoxedUsage.java:[line 27]
M C RR: SkipBufferedInputStream.main(String[]) ignores result of java.io.BufferedInputStream.read(byte[])  At SkipBufferedInputStream.java:[line 12]
M C RR: SkipBufferedInputStream2.main(String[]) ignores result of java.io.BufferedInputStream.read(byte[])  At SkipBufferedInputStream2.java:[line 13]
M M SP: Spinning on SpinWait.flag in SpinWait.waitForTrue()  At SpinWait.java:[line 6]
M M SP: Spinning on SpinWait.vflag in SpinWait.waitForVolatileTrue()  At SpinWait.java:[line 9]
M C UwF: Unwritten field: SpinWait.flag
M C UwF: Unwritten field: SpinWait.vflag
H C ES: Comparison of String objects using == or != in StringComparision.isOrigin()   At StringComparision.java:[line 9]
L C ES: Comparison of String objects using == or != in StringComparision.compareTwo(String,String)   At StringComparision.java:[line 18]
L C ES: Comparison of String objects using == or != in StringComparision.searchFields(java.lang.reflect.Field[],String)   At StringComparision.java:[line 26]
M C RC: Suspicious comparison of java.lang.Boolean references in StringComparision.compareBool(Boolean,Boolean)  At StringComparision.java:[line 15]
H C ES: Comparison of String objects using == or != in StringEqualityTest.almostEmpty(String)   At StringEqualityTest.java:[line 4]
L C ES: Comparison of String objects using == or != in StringEqualsTest.test(String)   At StringEqualsTest.java:[line 5]
L C SW: Call to swing method in Swing1.main(String[]) needs to be performed in Swing event thread  At Swing1.java:[line 15]
L C SW: Call to swing method in Swing1.main(String[]) needs to be performed in Swing event thread  At Swing1.java:[line 16]
L C SW: Call to swing method in Swing1.main(String[]) needs to be performed in Swing event thread  At Swing1.java:[line 17]
L S SF: A switch statement found in SwitchFallthrough.num(int) where one case falls thru to the next case  At SwitchFallthrough.java:[lines 8-11]
L S SF: A switch statement found in SwitchFallthrough.num(int) where one case falls thru to the next case  At SwitchFallthrough.java:[lines 11-13]
L S SF: A switch statement found in SwitchFallthrough.num(int) where one case falls thru to the next case  At SwitchFallthrough.java:[lines 13-16]
L S SF: A switch statement found in SwitchFallthrough.num(int) where one case falls thru to the next case  At SwitchFallthrough.java:[lines 16-20]
M M IS2: Inconsistent synchronization of SynchronizationTest2.x; locked 85% of time  Unsynchronized access at SynchronizationTest2.java:[line 23]
L M IS2: Inconsistent synchronization of SynchronizationTest3.x; locked 92% of time  Unsynchronized access at SynchronizationTest3.java:[line 23]
L M IS2: Inconsistent synchronization of SynchronizationTest4.x; locked 92% of time  Unsynchronized access at SynchronizationTest4.java:[line 23]
M S REC: Method Test.main(String[]) catches Exception, but Exception is not thrown in the try block and RuntimeException is not explicitly caught  At Test.java:[line 35]
M S REC: Method Test.main(String[]) catches Exception, but Exception is not thrown in the try block and RuntimeException is not explicitly caught  At Test.java:[line 41]
M S REC: Method Test.main(String[]) catches Exception, but Exception is not thrown in the try block and RuntimeException is not explicitly caught  At Test.java:[line 46]
M S REC: Method Test.main(String[]) catches Exception, but Exception is not thrown in the try block and RuntimeException is not explicitly caught  At Test.java:[line 49]
L M No: Using notify rather than notifyAll in TestFalsePositiveMWN.set()  At TestFalsePositiveMWN.java:[line 9]
M C RR: TestReadandSkipReturnShouldBeChecked.test() ignores result of java.io.BufferedInputStream.read(byte[])  At TestReadandSkipReturnShouldBeChecked.java:[line 18]
M C RR: TestReadandSkipReturnShouldBeChecked.test() ignores result of java.io.BufferedInputStream.read(byte[])  At TestReadandSkipReturnShouldBeChecked.java:[line 20]
H C RR: TestReadandSkipReturnShouldBeChecked.test() ignores result of java.io.BufferedInputStream.skip(long)  At TestReadandSkipReturnShouldBeChecked.java:[line 19]
M C RV: TryLock.main(String[]) ignores return value of java.util.concurrent.locks.Lock.newCondition()  At TryLock.java:[line 13]
M C RV: TryLock.main(String[]) ignores return value of java.util.concurrent.locks.Lock.tryLock()  At TryLock.java:[line 15]
M C RV: TryLock.main(String[]) ignores return value of java.util.concurrent.locks.Lock.tryLock()  At TryLock.java:[line 16]
M C RV: TryLock.main(String[]) ignores return value of java.util.concurrent.locks.ReadWriteLock.readLock()  At TryLock.java:[line 10]
M C RV: TryLock.main(String[]) ignores return value of java.util.concurrent.locks.ReentrantLock.newCondition()  At TryLock.java:[line 12]
M C RV: TryLock.main(String[]) ignores return value of java.util.concurrent.locks.ReentrantLock.tryLock()  At TryLock.java:[line 14]
M M 2LW: wait() with two locks held in TwoLockWait.myMethod(Object,Object)  At TwoLockWait.java:[line 8]
M M UW: Unconditional wait in TwoLockWait.myMethod(Object,Object)  At TwoLockWait.java:[line 8]
M M Wa: Wait not in loop in TwoLockWait.myMethod(Object,Object)  At TwoLockWait.java:[line 8]
M M UW: Unconditional wait in TwoLocksWhileWaitingFalsePositive.clueless()  At TwoLocksWhileWaitingFalsePositive.java:[line 8]
M M Wa: Wait not in loop in TwoLocksWhileWaitingFalsePositive.clueless()  At TwoLocksWhileWaitingFalsePositive.java:[line 8]
L C OS: TwoStreams.nullDereferenceCheck(TwoStreams) may fail to close stream on exception  At TwoStreams.java:[line 28]
L C OS: TwoStreams.twoStreamsRight() may fail to close stream on exception  At TwoStreams.java:[line 39]
L C OS: TwoStreams.twoStreamsWrong() may fail to close stream on exception  At TwoStreams.java:[line 12]
M P UPM: Private method UncalledPrivateMethod.foobar(int) is never called  At UncalledPrivateMethod.java:[line 20]
L P UPM: Private method UncalledPrivateMethod.foo(String) is never called  At UncalledPrivateMethod.java:[lines 11-12]
M P UrF: Unread field: UncalledPrivateMethod.s
L C SIO: Method UnneededInstanceOf.test1(java.util.ArrayList) does an unnecessary type check using instanceof operator when it can be determined statically  At UnneededInstanceOf.java:[line 9]
L C SIO: Method UnneededInstanceOf.test2(java.io.BufferedOutputStream) does an unnecessary type check using instanceof operator when it can be determined statically  At UnneededInstanceOf.java:[line 15]
L C SIO: Method UnneededInstanceOf.test3(java.util.SortedSet) does an unnecessary type check using instanceof operator when it can be determined statically  At UnneededInstanceOf.java:[line 21]
M C SA: Self assignment of field UselessAssignments.foo in UselessAssignments.<init>(int,int)  At UselessAssignments.java:[line 6]
M S SA: Self assignment of local variable in UselessAssignments.<init>(int,int)  At UselessAssignments.java:[line 7]
M C UR: Uninitialized read of UselessAssignments.foo in UselessAssignments.<init>(int,int)  At UselessAssignments.java:[line 6]
M P FI: UselessFinalize.finalize() does nothing except call super.finalize(); delete it  At UselessFinalize.java:[lines 4-5]
M P UrF: Unread field: VolatileUsage.a
M P UrF: Unread field: VolatileUsage.d
M P UrF: Unread field: VolatileUsage.e
M P UuF: Unused field: VolatileUsage.b
M P UuF: Unused field: VolatileUsage.c
M P UuF: Unused field: VolatileUsage.f
M M VO: VolatileUsage.a is a volatile reference to an array; the array elements are non-volatile.
L M VO: VolatileUsage.d is a volatile reference to an array; the array elements are non-volatile.
L M VO: VolatileUsage.e is a volatile reference to an array; the array elements are non-volatile.
L M VO: VolatileUsage.f is a volatile reference to an array; the array elements are non-volatile.
M P UuF: Unused field: VolatileUsage2.b
M P UuF: Unused field: VolatileUsage2.c
M P UuF: Unused field: VolatileUsage2.f
M M VO: VolatileUsage2.a is a volatile reference to an array; the array elements are non-volatile.
L M VO: VolatileUsage2.d is a volatile reference to an array; the array elements are non-volatile.
L M VO: VolatileUsage2.f is a volatile reference to an array; the array elements are non-volatile.
M P WMI: Method WMITest.test(java.util.Map) makes inefficient use of keySet iterator instead of entrySet iterator  At WMITest.java:[line 12]
M P WMI: Method WMITest.test2(int,int,int,int,java.util.Map) makes inefficient use of keySet iterator instead of entrySet iterator  At WMITest.java:[line 23]
M P WMI: Method WMITest.test3(java.util.Map) makes inefficient use of keySet iterator instead of entrySet iterator  At WMITest.java:[line 35]
M P WMI: Method WMITest.test4(java.util.Map) makes inefficient use of keySet iterator instead of entrySet iterator  At WMITest.java:[line 46]
M P Dm: foo.RV.main(String[]) invokes dubious new String(String) constructor; just use the argument  At RV.java:[line 5]
L C Nm: Confusing to have methods java.awt.Component.getX() and MethodCapitalization$Bar.getx()
M V MS: package1.InterfaceWithMutableField.a should be moved out of an interface and made package protected
M V MS: package1.MutableStatic.q isn't final and can't be protected from malicious code 
M V MS: package1.MutableStatic.data3 should be both final and package protected
H V MS: package1.MutableStatic.data2 is a mutable array
M V MS: package1.MutableStatic.data is a mutable array
M V MS: package1.MutableStatic.h is a mutable Hashtable
H V MS: package1.MutableStatic.p isn't final but should be
